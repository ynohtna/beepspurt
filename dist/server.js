"format global";

/* */ 
"format global";
(function (global) {
  var babelHelpers = global.babelHelpers = {};

  babelHelpers.inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  babelHelpers.defaults = function (obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);

      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }

    return obj;
  };

  babelHelpers.createClass = (function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();

  babelHelpers.createDecoratedClass = (function () {
    function defineProperties(target, descriptors, initializers) {
      for (var i = 0; i < descriptors.length; i++) {
        var descriptor = descriptors[i];
        var decorators = descriptor.decorators;
        var key = descriptor.key;
        delete descriptor.key;
        delete descriptor.decorators;
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor || descriptor.initializer) descriptor.writable = true;

        if (decorators) {
          for (var f = 0; f < decorators.length; f++) {
            var decorator = decorators[f];

            if (typeof decorator === "function") {
              descriptor = decorator(target, key, descriptor) || descriptor;
            } else {
              throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator);
            }
          }

          if (descriptor.initializer !== undefined) {
            initializers[key] = descriptor;
            continue;
          }
        }

        Object.defineProperty(target, key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers);
      if (staticProps) defineProperties(Constructor, staticProps, staticInitializers);
      return Constructor;
    };
  })();

  babelHelpers.createDecoratedObject = function (descriptors) {
    var target = {};

    for (var i = 0; i < descriptors.length; i++) {
      var descriptor = descriptors[i];
      var decorators = descriptor.decorators;
      var key = descriptor.key;
      delete descriptor.key;
      delete descriptor.decorators;
      descriptor.enumerable = true;
      descriptor.configurable = true;
      if ("value" in descriptor || descriptor.initializer) descriptor.writable = true;

      if (decorators) {
        for (var f = 0; f < decorators.length; f++) {
          var decorator = decorators[f];

          if (typeof decorator === "function") {
            descriptor = decorator(target, key, descriptor) || descriptor;
          } else {
            throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator);
          }
        }
      }

      if (descriptor.initializer) {
        descriptor.value = descriptor.initializer.call(target);
      }

      Object.defineProperty(target, key, descriptor);
    }

    return target;
  };

  babelHelpers.defineDecoratedPropertyDescriptor = function (target, key, descriptors) {
    var _descriptor = descriptors[key];
    if (!_descriptor) return;
    var descriptor = {};

    for (var _key in _descriptor) descriptor[_key] = _descriptor[_key];

    descriptor.value = descriptor.initializer ? descriptor.initializer.call(target) : undefined;
    Object.defineProperty(target, key, descriptor);
  };

  babelHelpers.taggedTemplateLiteral = function (strings, raw) {
    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  };

  babelHelpers.taggedTemplateLiteralLoose = function (strings, raw) {
    strings.raw = raw;
    return strings;
  };

  babelHelpers.toArray = function (arr) {
    return Array.isArray(arr) ? arr : Array.from(arr);
  };

  babelHelpers.toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  babelHelpers.slicedToArray = (function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  })();

  babelHelpers.slicedToArrayLoose = function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      var _arr = [];

      for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        _arr.push(_step.value);

        if (i && _arr.length === i) break;
      }

      return _arr;
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };

  babelHelpers.objectWithoutProperties = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };

  babelHelpers.hasOwn = Object.prototype.hasOwnProperty;
  babelHelpers.slice = Array.prototype.slice;
  babelHelpers.bind = Function.prototype.bind;

  babelHelpers.defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  babelHelpers.asyncToGenerator = function (fn) {
    return function () {
      var gen = fn.apply(this, arguments);
      return new Promise(function (resolve, reject) {
        var callNext = step.bind(null, "next");
        var callThrow = step.bind(null, "throw");

        function step(key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }

          if (info.done) {
            resolve(value);
          } else {
            Promise.resolve(value).then(callNext, callThrow);
          }
        }

        callNext();
      });
    };
  };

  babelHelpers.interopExportWildcard = function (obj, defaults) {
    var newObj = defaults({}, obj);
    delete newObj["default"];
    return newObj;
  };

  babelHelpers.interopRequireWildcard = function (obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj["default"] = obj;
      return newObj;
    }
  };

  babelHelpers.interopRequireDefault = function (obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  };

  babelHelpers._typeof = function (obj) {
    return obj && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  babelHelpers._extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  babelHelpers.get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  babelHelpers.set = function set(object, property, value, receiver) {
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent !== null) {
        set(parent, property, value, receiver);
      }
    } else if ("value" in desc && desc.writable) {
      desc.value = value;
    } else {
      var setter = desc.set;

      if (setter !== undefined) {
        setter.call(receiver, value);
      }
    }

    return value;
  };

  babelHelpers.newArrowCheck = function (innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  };

  babelHelpers.classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  babelHelpers.objectDestructuringEmpty = function (obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  };

  babelHelpers.temporalUndefined = {};

  babelHelpers.temporalAssertDefined = function (val, name, undef) {
    if (val === undef) {
      throw new ReferenceError(name + " is not defined - temporal dead zone");
    }

    return true;
  };

  babelHelpers.selfGlobal = typeof global === "undefined" ? self : global;
  babelHelpers.typeofReactElement = typeof Symbol === "function" && Symbol["for"] && Symbol["for"]("react.element") || 60103;

  babelHelpers.defaultProps = function (defaultProps, props) {
    if (defaultProps) {
      for (var propName in defaultProps) {
        if (typeof props[propName] === "undefined") {
          props[propName] = defaultProps[propName];
        }
      }
    }

    return props;
  };

  babelHelpers._instanceof = function (left, right) {
    if (right != null && right[Symbol.hasInstance]) {
      return right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  };

  babelHelpers.interopRequire = function (obj) {
    return obj && obj.__esModule ? obj["default"] : obj;
  };
})(typeof global === "undefined" ? self : global);

!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in p||(p[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==v.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=p[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(v.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=p[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return x[e]||(x[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},r.name);t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=p[s],v=x[s];v?l=v.exports:c&&!c.declarative?l=c.esModule:c?(d(c),v=c.module,l=v.exports):l=f(s),v&&v.importers?(v.importers.push(t),t.dependencies.push(v)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=p[e];if(t)t.declarative?c(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=f(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=p[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){if(r===e)return r;var t={};if("object"==typeof r||"function"==typeof r)if(g){var n;for(var o in r)(n=Object.getOwnPropertyDescriptor(r,o))&&h(t,o,n)}else{var a=r&&r.hasOwnProperty;for(var o in r)(!a||r.hasOwnProperty(o))&&(t[o]=r[o])}return t["default"]=r,h(t,"__useDefault",{value:!0}),t}function c(r,t){var n=p[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==v.call(t,u)&&(p[u]?c(u,t):f(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function f(e){if(D[e])return D[e];if("@node/"==e.substr(0,6))return y(e.substr(6));var r=p[e];if(!r)throw"Module "+e+" not present.";return a(e),c(e,[]),p[e]=void 0,r.declarative&&h(r.module.exports,"__esModule",{value:!0}),D[e]=r.declarative?r.module.exports:r.esModule}var p={},v=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},g=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(m){g=!1}var h;!function(){try{Object.defineProperty({},"a",{})&&(h=Object.defineProperty)}catch(e){h=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var x={},y="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,D={"@empty":{}};return function(e,n,o){return function(a){a(function(a){for(var u={_nodeRequire:y,register:r,registerDynamic:t,get:f,set:function(e,r){D[e]=r},newModule:function(e){return e}},d=0;d<n.length;d++)(function(e,r){r&&r.__esModule?D[e]=r:D[e]=s(r)})(n[d],arguments[d]);o(u);var i=f(e[0]);if(e.length>1)for(var d=1;d<e.length;d++)f(e[d]);return i.__useDefault?i["default"]:i})}}}("undefined"!=typeof self?self:global)

(["1"], [], function($__System) {

!function(){var t=$__System;if("undefined"!=typeof window&&"undefined"!=typeof document&&window.location)var s=location.protocol+"//"+location.hostname+(location.port?":"+location.port:"");t.set("@@cjs-helpers",t.newModule({getPathVars:function(t){var n,o=t.lastIndexOf("!");n=-1!=o?t.substr(0,o):t;var e=n.split("/");return e.pop(),e=e.join("/"),"file:///"==n.substr(0,8)?(n=n.substr(7),e=e.substr(7),isWindows&&(n=n.substr(1),e=e.substr(1))):s&&n.substr(0,s.length)===s&&(n=n.substr(s.length),e=e.substr(s.length)),{filename:n,dirname:e}}}))}();
$__System.registerDynamic("2", ["3"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  exports.ActionTypes = undefined;
  exports["default"] = createStore;
  var _isPlainObject = $__require('3');
  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  var ActionTypes = exports.ActionTypes = {INIT: '@@redux/INIT'};
  function createStore(reducer, initialState, enhancer) {
    if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
      enhancer = initialState;
      initialState = undefined;
    }
    if (typeof enhancer !== 'undefined') {
      if (typeof enhancer !== 'function') {
        throw new Error('Expected the enhancer to be a function.');
      }
      return enhancer(createStore)(reducer, initialState);
    }
    if (typeof reducer !== 'function') {
      throw new Error('Expected the reducer to be a function.');
    }
    var currentReducer = reducer;
    var currentState = initialState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;
    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    function getState() {
      return currentState;
    }
    function subscribe(listener) {
      if (typeof listener !== 'function') {
        throw new Error('Expected listener to be a function.');
      }
      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }
        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
      };
    }
    function dispatch(action) {
      if (!(0, _isPlainObject2["default"])(action)) {
        throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
      }
      if (typeof action.type === 'undefined') {
        throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
      }
      if (isDispatching) {
        throw new Error('Reducers may not dispatch actions.');
      }
      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }
      var listeners = currentListeners = nextListeners;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
      return action;
    }
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== 'function') {
        throw new Error('Expected the nextReducer to be a function.');
      }
      currentReducer = nextReducer;
      dispatch({type: ActionTypes.INIT});
    }
    dispatch({type: ActionTypes.INIT});
    return {
      dispatch: dispatch,
      subscribe: subscribe,
      getState: getState,
      replaceReducer: replaceReducer
    };
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var nativeGetPrototype = Object.getPrototypeOf;
  function getPrototype(value) {
    return nativeGetPrototype(Object(value));
  }
  module.exports = getPrototype;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }
    return result;
  }
  module.exports = isHostObject;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  module.exports = isObjectLike;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3", ["4", "5", "6"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getPrototype = $__require('4'),
      isHostObject = $__require('5'),
      isObjectLike = $__require('6');
  var objectTag = '[object Object]';
  var objectProto = Object.prototype;
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return (typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
  }
  module.exports = isPlainObject;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7", ["2", "3", "8", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    exports.__esModule = true;
    exports["default"] = combineReducers;
    var _createStore = $__require('2');
    var _isPlainObject = $__require('3');
    var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
    var _warning = $__require('8');
    var _warning2 = _interopRequireDefault(_warning);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {"default": obj};
    }
    function getUndefinedStateErrorMessage(key, action) {
      var actionType = action && action.type;
      var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
      return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
    }
    function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
      var reducerKeys = Object.keys(reducers);
      var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
      if (reducerKeys.length === 0) {
        return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
      }
      if (!(0, _isPlainObject2["default"])(inputState)) {
        return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
      }
      var unexpectedKeys = Object.keys(inputState).filter(function(key) {
        return !reducers.hasOwnProperty(key);
      });
      if (unexpectedKeys.length > 0) {
        return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
      }
    }
    function assertReducerSanity(reducers) {
      Object.keys(reducers).forEach(function(key) {
        var reducer = reducers[key];
        var initialState = reducer(undefined, {type: _createStore.ActionTypes.INIT});
        if (typeof initialState === 'undefined') {
          throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
        }
        var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
        if (typeof reducer(undefined, {type: type}) === 'undefined') {
          throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
        }
      });
    }
    function combineReducers(reducers) {
      var reducerKeys = Object.keys(reducers);
      var finalReducers = {};
      for (var i = 0; i < reducerKeys.length; i++) {
        var key = reducerKeys[i];
        if (typeof reducers[key] === 'function') {
          finalReducers[key] = reducers[key];
        }
      }
      var finalReducerKeys = Object.keys(finalReducers);
      var sanityError;
      try {
        assertReducerSanity(finalReducers);
      } catch (e) {
        sanityError = e;
      }
      return function combination() {
        var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var action = arguments[1];
        if (sanityError) {
          throw sanityError;
        }
        if (process.env.NODE_ENV !== 'production') {
          var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
          if (warningMessage) {
            (0, _warning2["default"])(warningMessage);
          }
        }
        var hasChanged = false;
        var nextState = {};
        for (var i = 0; i < finalReducerKeys.length; i++) {
          var key = finalReducerKeys[i];
          var reducer = finalReducers[key];
          var previousStateForKey = state[key];
          var nextStateForKey = reducer(previousStateForKey, action);
          if (typeof nextStateForKey === 'undefined') {
            var errorMessage = getUndefinedStateErrorMessage(key, action);
            throw new Error(errorMessage);
          }
          nextState[key] = nextStateForKey;
          hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }
        return hasChanged ? nextState : state;
      };
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  exports["default"] = bindActionCreators;
  function bindActionCreator(actionCreator, dispatch) {
    return function() {
      return dispatch(actionCreator.apply(undefined, arguments));
    };
  }
  function bindActionCreators(actionCreators, dispatch) {
    if (typeof actionCreators === 'function') {
      return bindActionCreator(actionCreators, dispatch);
    }
    if (typeof actionCreators !== 'object' || actionCreators === null) {
      throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
    }
    var keys = Object.keys(actionCreators);
    var boundActionCreators = {};
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var actionCreator = actionCreators[key];
      if (typeof actionCreator === 'function') {
        boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
      }
    }
    return boundActionCreators;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b", ["c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  exports["default"] = applyMiddleware;
  var _compose = $__require('c');
  var _compose2 = _interopRequireDefault(_compose);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {"default": obj};
  }
  function applyMiddleware() {
    for (var _len = arguments.length,
        middlewares = Array(_len),
        _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }
    return function(createStore) {
      return function(reducer, initialState, enhancer) {
        var store = createStore(reducer, initialState, enhancer);
        var _dispatch = store.dispatch;
        var chain = [];
        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch(action) {
            return _dispatch(action);
          }
        };
        chain = middlewares.map(function(middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
        return _extends({}, store, {dispatch: _dispatch});
      };
    };
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  exports["default"] = compose;
  function compose() {
    for (var _len = arguments.length,
        funcs = Array(_len),
        _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }
    return function() {
      if (funcs.length === 0) {
        return arguments.length <= 0 ? undefined : arguments[0];
      }
      var last = funcs[funcs.length - 1];
      var rest = funcs.slice(0, -1);
      return rest.reduceRight(function(composed, f) {
        return f(composed);
      }, last.apply(undefined, arguments));
    };
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.__esModule = true;
  exports["default"] = warning;
  function warning(message) {
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (e) {}
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d", ["2", "7", "a", "b", "c", "8", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    exports.__esModule = true;
    exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
    var _createStore = $__require('2');
    var _createStore2 = _interopRequireDefault(_createStore);
    var _combineReducers = $__require('7');
    var _combineReducers2 = _interopRequireDefault(_combineReducers);
    var _bindActionCreators = $__require('a');
    var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
    var _applyMiddleware = $__require('b');
    var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
    var _compose = $__require('c');
    var _compose2 = _interopRequireDefault(_compose);
    var _warning = $__require('8');
    var _warning2 = _interopRequireDefault(_warning);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {"default": obj};
    }
    function isCrushed() {}
    if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
      (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
    }
    exports.createStore = _createStore2["default"];
    exports.combineReducers = _combineReducers2["default"];
    exports.bindActionCreators = _bindActionCreators2["default"];
    exports.applyMiddleware = _applyMiddleware2["default"];
    exports.compose = _compose2["default"];
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e", ["d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f", ["10"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$defineProperty = $__require('10')["default"];
  exports["default"] = function(obj, key, value) {
    if (key in obj) {
      _Object$defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.register('11', ['12', 'f'], function (_export) {
  var _extends, _defineProperty, defaultRendererState, validStates, rendererState;

  return {
    setters: [function (_) {
      _extends = _['default'];
    }, function (_f) {
      _defineProperty = _f['default'];
    }],
    execute: function () {
      'use strict';

      defaultRendererState = {
        frame: 0,
        width: 800,
        height: 600,
        state: 'run', // 'pause', 'off'
        foreground: [255, 255, 255, 255],
        background: [0, 0, 0, 255],
        clearColour: [0, 0, 0, 0],
        invert: false
      };
      validStates = {
        run: true,
        pause: true,
        off: true
      };

      rendererState = function rendererState(state, action) {
        if (state === undefined) state = defaultRendererState;

        switch (action.type) {
          case '/renderer/STATE':
            //      console.log('**** /renderer/STATE', action);
            return action.payload in validStates ? _extends({}, state, {
              state: action.payload
            }) : state;
          case '/renderer/FRAME_BOUNDS':
            return _extends({}, state, {
              width: action.payload.width,
              height: action.payload.height
            });
          case '/renderer/FRAME_ADVANCE':
            return _extends({}, state, {
              frame: state.frame + 1
            });
          case '/renderer/FOREGROUND':
            return _extends({}, state, {
              foreground: action.payload
            });
          case '/renderer/BACKGROUND':
            return _extends({}, state, {
              background: action.payload
            });
          case '/renderer/CLEAR_COLOUR':
            return _extends({}, state, {
              clearColour: action.payload
            });
          case '/renderer/INVERT':
            return _extends({}, state, {
              invert: action.payload
            });
          case '/renderer/REQUEST':
            return _extends({}, state, _defineProperty({}, 'req_' + action.payload, state.frame));
          default:
            return state;
        }
      };

      _export('default', rendererState);
    }
  };
});
$__System.register('13', ['12', '14'], function (_export) {
  var _extends, listPhotos, defaultPhotoState, photoState;

  return {
    setters: [function (_) {
      _extends = _['default'];
    }, function (_2) {
      listPhotos = _2.listPhotos;
    }],
    execute: function () {
      'use strict';

      defaultPhotoState = {
        filename: 'hail-satan.jpg',
        fillmode: 'cover', // none, fill, contain, cover, (unimpl: scale-down)
        list: []
      };

      photoState = function photoState(state, action) {
        if (state === undefined) state = defaultPhotoState;

        switch (action.type) {
          case '/photo/FILE':
            return _extends({}, state, {
              filename: action.payload || ''
            });
          case '/photo/FILL':
            return _extends({}, state, {
              fillmode: action.payload
            });
          case '/photo/LIST':
            return _extends({}, state, {
              list: listPhotos()
            });
          default:
            return state;
        }
      };

      _export('default', photoState);
    }
  };
});
$__System.register('15', ['12'], function (_export) {
  var _extends, defaultVarsState, spurterState;

  return {
    setters: [function (_) {
      _extends = _['default'];
    }],
    execute: function () {
      // SERVER IMPLEMENTATION! TODO: Share with client-side.

      'use strict';

      defaultVarsState = {
        message: '[beep]',
        fontFamily: 'Rockwell',
        bold: false,
        italic: false,
        zoomScale: 3, // percentage
        halign: 1, // 0: left; 1: center; 2: right
        valign: 1, // 0: top; 1: middle; 2: bottom
        marginVH: 0.1, // Ratio of margin to viewport height.
        lineSpacing: 1.0, // Ratio of emHeight between subsequent lines of text.
        backgroundMode: 1, // 0: none, 1: tape, 2: shadow
        backgroundOffsetRatio: 0.2, // offset = lineSpacing * backgroundOffsetRatio
        debug: false
      };

      spurterState = function spurterState(state, action) {
        if (state === undefined) state = defaultVarsState;

        switch (action.type) {
          case '/spurter/STATE':
          case '/spurter/MERGE':
            return _extends({}, state, action.payload);
          case '/spurter/MESSAGE':
            return _extends({}, state, {
              message: action.payload
            });
          case '/spurter/MASSAGE':
            return _extends({}, state, {
              message: action.payload.replace(/\\n/g, '\n')
            });
          case '/spurter/FONT_FAMILY':
            return _extends({}, state, {
              fontFamily: action.payload
            });
          case '/spurter/BOLD':
            return _extends({}, state, {
              bold: action.payload
            });
          case '/spurter/ITALIC':
            return _extends({}, state, {
              italic: action.payload
            });
          case '/spurter/ZOOM_SCALE':
            return _extends({}, state, {
              zoomScale: action.payload
            });
          case '/spurter/MARGIN_VH':
            return _extends({}, state, {
              marginVH: action.payload
            });
          case '/spurter/LINE_SPACING':
            return _extends({}, state, {
              lineSpacing: action.payload
            });
          case '/spurter/BACKGROUND_MODE':
            return _extends({}, state, {
              backgroundMode: action.payload
            });
          case '/spurter/BACKGROUND_OFFSET_RATIO':
            return _extends({}, state, {
              backgroundOffsetRatio: action.payload
            });
          case '/spurter/HALIGN':
            return _extends({}, state, {
              halign: action.payload
            });
          case '/spurter/VALIGN':
            return _extends({}, state, {
              valign: action.payload
            });
          case '/spurter/DEBUG':
            return _extends({}, state, {
              debug: action.payload
            });
          default:
            return state;
        }
      };

      _export('default', spurterState);
    }
  };
});
$__System.register('16', ['11', '13', '15'], function (_export) {
  'use strict';

  var rendererState, photoState, spurterState;
  return {
    setters: [function (_) {
      rendererState = _['default'];
    }, function (_2) {
      photoState = _2['default'];
    }, function (_3) {
      spurterState = _3['default'];
    }],
    execute: function () {
      _export('default', {
        rendererState: rendererState,
        spurterState: spurterState,
        photoState: photoState
      });
    }
  };
});
$__System.register('17', ['16', 'e'], function (_export) {
  'use strict';

  var reducers, applyMiddleware, combineReducers, createReduxStore, createStore;
  return {
    setters: [function (_) {
      reducers = _['default'];
    }, function (_e) {
      applyMiddleware = _e.applyMiddleware;
      combineReducers = _e.combineReducers;
      createReduxStore = _e.createStore;
    }],
    execute: function () {
      createStore = function createStore() {
        var store = createReduxStore(combineReducers(reducers), applyMiddleware.apply(undefined, arguments));
        var dispatch = function dispatch(type) {
          var payload = arguments.length <= 1 || arguments[1] === undefined ? undefined : arguments[1];
          return store.dispatch({ type: type, payload: payload });
        };
        return {
          store: store,
          dispatch: dispatch
        };
      };

      _export('default', createStore);
    }
  };
});
$__System.register('18', ['12', '19', '1b', '1c', '1d', '1e', '1a'], function (_export) {
  var _extends, createSocket, _get, _inherits, _createClass, _classCallCheck, EventEmitter, arrayBuffer, dataView, Socket;

  function readString(buffer, start) {
    var len = buffer.length;
    var end = start;

    // Seek to the end of the string (which will be terminated by 1-4 NULLs).
    while (end < len && buffer[end] !== 0) {
      end++;
    }

    // NOTE(deanm): At this point we could probably salvage the message and
    // take the string (which was probably truncated due to UDP packet size),
    // but it is probably the best decision to error out on malformed data.
    if (end >= len) {
      throw new Error('Encountered invalid OSC string, missing NULL termination.');
    }

    return buffer.toString('ascii', start, end);
  }

  function readFloat(buffer, pos) {
    dataView.setUint8(0, buffer[pos]);
    dataView.setUint8(1, buffer[pos + 1]);
    dataView.setUint8(2, buffer[pos + 2]);
    dataView.setUint8(3, buffer[pos + 3]);
    return dataView.getFloat32(0, false);
  }

  function readInt(buffer, pos) {
    dataView.setUint8(0, buffer[pos]);
    dataView.setUint8(1, buffer[pos + 1]);
    dataView.setUint8(2, buffer[pos + 2]);
    dataView.setUint8(3, buffer[pos + 3]);
    return dataView.getInt32(0, false);
  }

  function readBlob(buffer, start) {
    var len = readInt(buffer, start);
    return buffer.slice(start + 4, start + 4 + len);
  }

  function processMessageOrBundle(msg, remote, emitter) {
    var pos_ = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

    var pos = pos_;

    var addr = readString(msg, pos);
    pos += addr.length + 4 - (addr.length & 3);

    if (addr === '#bundle') {
      pos += 8; // Skip timetag, treat everything as 'immediately'.
      while (pos < msg.length) {
        var len = readInt(msg, pos);
        pos += 4;
        processMessageOrBundle(msg, remote, emitter, pos);
        pos += len;
      }
      return;
    }

    var typetags = readString(msg, pos);
    pos += typetags.length + 4 - (typetags.length & 3);

    // Advance past leading comma.
    if (typetags[0] !== ',') {
      console.error('Malformed OSC Type Tag String (missing leading comma)', typetags);
      return;
    }
    var tags = typetags.substr(1);

    var args = [];
    for (var i = 0, il = tags.length; i < il; ++i) {
      var tag = tags[i];
      switch (tag) {
        case 'T':
          args.push(true);
          break;
        case 'F':
          args.push(false);
          break;
        case 'N':
          args.push(null);
          break;
        case 'I':
          args.push(undefined);
          break;
        case 'f':
          args.push(readFloat(msg, pos));
          pos += 4;
          break;
        case 'i':
          args.push(readInt(msg, pos));
          pos += 4;
          break;
        case 's':
          {
            var str = readString(msg, pos);
            pos += str.length + 4 - (str.length & 3);
            args.push(str);
            break;
          }
        case 'b':
          {
            var bytes = readBlob(msg, pos);
            pos += 4 + bytes.length + (4 - (bytes.length & 3) & 3);
            args.push(bytes);
            break;
          }
        default:
          console.warn('WARNING: Unhandled OSC type tag', tag);
          break;
      }
    }

    emitter.emit('osc', {
      addr: addr,
      tags: tags,
      args: args,
      remote: remote
    });
  }

  return {
    setters: [function (_) {
      _extends = _['default'];
    }, function (_2) {
      createSocket = _2.createSocket;
    }, function (_b) {
      _get = _b['default'];
    }, function (_c) {
      _inherits = _c['default'];
    }, function (_d) {
      _createClass = _d['default'];
    }, function (_e) {
      _classCallCheck = _e['default'];
    }, function (_a) {
      EventEmitter = _a.EventEmitter;
    }],
    execute: function () {
      /* eslint-disable no-console */
      'use strict';

      arrayBuffer = new ArrayBuffer(4);
      dataView = new DataView(arrayBuffer);

      Socket = (function (_EventEmitter) {
        _inherits(Socket, _EventEmitter);

        function Socket(options) {
          _classCallCheck(this, Socket);

          _get(Object.getPrototypeOf(Socket.prototype), 'constructor', this).call(this);
          this.options_ = _extends({
            port: 6339,
            exclusive: true
          }, options);
          this.socket_ = null;
        }

        _createClass(Socket, [{
          key: 'open',
          value: function open() {
            this.socket_ = createSocket('udp4');
            this.socket_.on('close', this.onclosed.bind(this));
            this.socket_.on('error', this.onerror.bind(this));
            this.socket_.on('message', this.onmessage.bind(this));
            this.socket_.bind(this.options_, this.onopened.bind(this));
          }
        }, {
          key: 'onopened',
          value: function onopened() {
            this.emit('opened');
          }
        }, {
          key: 'onerror',
          value: function onerror(error) {
            console.error('socket error', error);
            this.emit('error', error);
          }
        }, {
          key: 'onclosed',
          value: function onclosed() {
            this.emit('closed');
          }
        }, {
          key: 'onmessage',
          value: function onmessage(msg, remote) {
            try {
              processMessageOrBundle(msg, remote, this);
            } catch (e) {
              console.error('OSC message error', e);
              this.emit('error', e);
            }
          }
        }, {
          key: 'close',
          value: function close() {
            if (this.socket_) {
              this.socket_.close();
              this.socket_ = null;
            }
          }
        }]);

        return Socket;
      })(EventEmitter);

      _export('default', Socket);
    }
  };
});
$__System.registerDynamic("1f", ["20", "21"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('20');
  $__require('21')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("22", ["23", "1f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('23');
  $__require('1f');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("24", ["22"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('22'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b", ["24"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$getOwnPropertyDescriptor = $__require('24')["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c", ["25", "26"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$create = $__require('25')["default"];
  var _Object$setPrototypeOf = $__require('26')["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("27", ["23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('23');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("10", ["27"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('27'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d", ["10"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$defineProperty = $__require('10')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("28", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if ($__System._nodeRequire)
    module.exports = $__System._nodeRequire('dgram');
  else
    throw "Node dgram module not supported in browsers.";
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("19", ["28"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('28');
  global.define = __define;
  return module.exports;
});

$__System.register('29', ['12', '19', '1b', '1c', '1d', '1e', '1a'], function (_export) {
  var _extends, createSocket, _get, _inherits, _createClass, _classCallCheck, EventEmitter, arrayBuffer, dataView, OscSender;

  function appendInt(octets, val) {
    dataView.setInt32(0, val, false);
    for (var i = 0; i < 4; ++i) {
      octets.push(dataView.getUint8(i));
    }
  }

  function appendFloat(octets, val) {
    dataView.setFloat32(0, val, false);
    for (var i = 0; i < 4; ++i) {
      octets.push(dataView.getUint8(i));
    }
  }

  function appendString(octets, str) {
    var len = str.length;
    for (var i = 0; i < len; ++i) {
      octets.push(str.charCodeAt(i) & 0x7f); // Should be 7-bit clean right?
    }
    // We want to add the null byte and pad to 4 byte boundary.
    var nulls = 4 - (len & 3); // Will always be at least 1 for terminator.
    for (var i = 0; i < nulls; ++i) {
      octets.push(0);
    }
  }

  function appendBlob(octets, val) {
    var len = val.length;
    appendInt(octets, len);

    // grow byte array and carve out space for the Blob
    var start = octets.length;
    octets.length += len;
    for (var i = 0; i < len; ++i) {
      octets[start + i] = val[i];
    }

    // We want to pad to 4 byte boundary.
    var nulls = 4 - (len & 3) & 3;
    for (var i = 0; i < nulls; ++i) {
      octets.push(0);
    }
  }

  function makeMessageOctets(path, typetag, params) {
    var octets = [];
    appendString(octets, path);
    appendString(octets, ',' + typetag);
    for (var i = 0, il = typetag.length; i < il; ++i) {
      var tag = typetag[i];
      switch (tag) {
        case 'i':
          appendInt(octets, params[i]);
          break;
        case 'f':
          appendFloat(octets, params[i]);
          break;
        case 's':
          appendString(octets, params[i]);
          break;
        case 'b':
          appendBlob(octets, params[i]);
          break;
        // Types with implicit parameters, just ignore the passed parameter.
        case 'T':case 'F':case 'N':case 'I':
          break;
        default:
          console.error('Unknown OSC type: ' + tag);
          break;
      }
    }
    return octets;
  }

  return {
    setters: [function (_) {
      _extends = _['default'];
    }, function (_2) {
      createSocket = _2.createSocket;
    }, function (_b) {
      _get = _b['default'];
    }, function (_c) {
      _inherits = _c['default'];
    }, function (_d) {
      _createClass = _d['default'];
    }, function (_e) {
      _classCallCheck = _e['default'];
    }, function (_a) {
      EventEmitter = _a.EventEmitter;
    }],
    execute: function () {
      /* eslint-disable no-param-reassign, no-console */
      'use strict';

      arrayBuffer = new ArrayBuffer(4);
      dataView = new DataView(arrayBuffer);

      OscSender = (function (_EventEmitter) {
        _inherits(OscSender, _EventEmitter);

        function OscSender(options) {
          _classCallCheck(this, OscSender);

          _get(Object.getPrototypeOf(OscSender.prototype), 'constructor', this).call(this);
          this.options_ = _extends({
            port: 7000,
            host: '127.0.0.1'
          }, options);
          this.socket_ = null;
        }

        _createClass(OscSender, [{
          key: 'open',
          value: function open() {
            this.socket_ = createSocket('udp4');
            if (this.options_.broadcast) {
              this.socket_.setBroadcast(true);
            }
            this.socket_.on('close', this.onclosed.bind(this));
            this.socket_.on('error', this.onerror.bind(this));
          }
        }, {
          key: 'onerror',
          value: function onerror(error) {
            console.error('socket error', error);
            this.emit('error', error);
          }
        }, {
          key: 'onclosed',
          value: function onclosed() {
            this.emit('closed');
          }
        }, {
          key: 'send',
          value: function send(path, typetag, params) {
            var _options_ = this.options_;
            var host = _options_.host;
            var port = _options_.port;

            var octets = makeMessageOctets(path, typetag, params);
            var msg = new Buffer(octets);
            this.socket_.send(msg, 0, octets.length, port, host);
          }
        }, {
          key: 'sendBundled',
          value: function sendBundled(path, typetag, params) {
            var _options_2 = this.options_;
            var host = _options_2.host;
            var port = _options_2.port;

            var message = makeMessageOctets(path, typetag, params);
            var octets = [];
            appendString(octets, '#bundle');
            appendInt(octets, 0);
            appendInt(octets, 1); // timetag now.
            appendInt(octets, message.length);
            octets = octets.concat(message);
            var msg = new Buffer(octets);
            this.socket_.send(msg, 0, octets.length, port, host);
          }
        }, {
          key: 'close',
          value: function close() {
            if (this.socket_) {
              this.socket_.close();
              this.socket_ = null;
            }
          }
        }]);

        return OscSender;
      })(EventEmitter);

      _export('default', OscSender);
    }
  };
});
$__System.registerDynamic("2a", ["2b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Array$from = $__require('2b')["default"];
  exports["default"] = function(arr) {
    return Array.isArray(arr) ? arr : _Array$from(arr);
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.register('2c', ['2a', '2f', '2d', '2e'], function (_export) {
  var _toArray, _regeneratorRuntime, chalk, effects, isCancelError, marked0$0, util, /* call, */cancel, fork, /* put, */race, take, conlog, conwarn, conerr, extSaga;

  function bounce(sender, action) {
    var msg, _msg$payload, path, tags, params;

    return _regeneratorRuntime.wrap(function bounce$(context$1$0) {
      while (1) switch (context$1$0.prev = context$1$0.next) {
        case 0:
          context$1$0.prev = 0;

          conlog('* EXT bounce');

          context$1$0.next = 4;
          return take(action);

        case 4:
          msg = context$1$0.sent;

        case 5:
          if (!msg) {
            context$1$0.next = 14;
            break;
          }

          conlog('* EXT');
          conlog(util.inspect(msg));
          if (msg.payload && msg.payload.length) {
            _msg$payload = _toArray(msg.payload);
            path = _msg$payload[0];
            tags = _msg$payload[1];
            params = _msg$payload.slice(2);

            sender.send(path, tags || '', params || []);
            conwarn('* EXT ' + action + ' send: ' + path + ' "' + tags + '" ' + params);
          }

          context$1$0.next = 11;
          return take(action);

        case 11:
          msg = context$1$0.sent;
          context$1$0.next = 5;
          break;

        case 14:
          context$1$0.next = 21;
          break;

        case 16:
          context$1$0.prev = 16;
          context$1$0.t0 = context$1$0['catch'](0);

          if (isCancelError(context$1$0.t0)) {
            context$1$0.next = 21;
            break;
          }

          conerr('* EXT ' + action + ' error', context$1$0.t0);
          throw context$1$0.t0;

        case 21:
        case 'end':
          return context$1$0.stop();
      }
    }, marked0$0[0], this, [[0, 16]]);
  }

  return {
    setters: [function (_a) {
      _toArray = _a['default'];
    }, function (_f) {
      _regeneratorRuntime = _f['default'];
    }, function (_d) {
      chalk = _d['default'];
    }, function (_e) {
      effects = _e.effects;
      isCancelError = _e.isCancelError;
    }],
    execute: function () {
      /* eslint-disable no-console */
      /* eslint no-param-reassign: [2, {"props": false }] */
      'use strict';

      marked0$0 = [bounce].map(_regeneratorRuntime.mark);
      util = require('util');
      cancel = effects.cancel;
      fork = effects.fork;
      race = effects.race;
      take = effects.take;

      conlog = function conlog() {
        var _chalk$blue;

        return console.log((_chalk$blue = chalk.blue).bold.apply(_chalk$blue, arguments));
      };

      conwarn = function conwarn() {
        var _chalk$magenta;

        return console.warn((_chalk$magenta = chalk.magenta).bold.apply(_chalk$magenta, arguments));
      };

      conerr = function conerr() {
        var _chalk$blue$inverse$white;

        return console.error((_chalk$blue$inverse$white = chalk.blue.inverse.white).bold.apply(_chalk$blue$inverse$white, arguments));
      };

      extSaga = function extSaga(sender, action) {
        return _regeneratorRuntime.mark(function ext() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var SOCKET_OPEN, awaitOpen, active, bounceTask, winner;
          return _regeneratorRuntime.wrap(function ext$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                conlog('* extSaga ' + action + ' ' + util.inspect(args));

                context$2$0.next = 3;
                return take('/plask/INIT');

              case 3:
                conlog('* extSaga/INIT');

                // Open socket.
                sender.open();

                SOCKET_OPEN = action + '/OPEN';
                awaitOpen = false;
                active = true;

              case 8:
                if (!active) {
                  context$2$0.next = 27;
                  break;
                }

                if (!awaitOpen) {
                  context$2$0.next = 13;
                  break;
                }

                context$2$0.next = 12;
                return take(SOCKET_OPEN);

              case 12:
                conlog(SOCKET_OPEN);

              case 13:
                context$2$0.next = 15;
                return fork(bounce, sender, action);

              case 15:
                bounceTask = context$2$0.sent;
                context$2$0.next = 18;
                return race({
                  //      didClose: take(SOCKET_CLOSED),
                  //      erred: take(SOCKET_ERROR),
                  close: take(action + '/CLOSE'),
                  open: take(SOCKET_OPEN)
                });

              case 18:
                winner = context$2$0.sent;

                conwarn('***** extSaga ' + action + ' race!', winner, bounceTask.isRunning());

                // Cancel bounce.
                conwarn('cancelling bounce fetch');
                context$2$0.next = 23;
                return cancel(bounceTask);

              case 23:

                sender.close();

                // If socket closed or errored then await new open request, i.e. from direct user intervention.
                awaitOpen = !winner.open;
                context$2$0.next = 8;
                break;

              case 27:
              case 'end':
                return context$2$0.stop();
            }
          }, ext, this);
        });
      };

      _export('default', extSaga);
    }
  };
});
// Await user-initiated open socket request.

// Fork OSC message bounce.

// Race: didClose, close, error, open.
$__System.registerDynamic("30", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var kCSSColorTable = {
    "transparent": [0, 0, 0, 0],
    "aliceblue": [240, 248, 255, 255],
    "antiquewhite": [250, 235, 215, 255],
    "aqua": [0, 255, 255, 255],
    "aquamarine": [127, 255, 212, 255],
    "azure": [240, 255, 255, 255],
    "beige": [245, 245, 220, 255],
    "bisque": [255, 228, 196, 255],
    "black": [0, 0, 0, 255],
    "blanchedalmond": [255, 235, 205, 255],
    "blue": [0, 0, 255, 255],
    "blueviolet": [138, 43, 226, 255],
    "brown": [165, 42, 42, 255],
    "burlywood": [222, 184, 135, 255],
    "cadetblue": [95, 158, 160, 255],
    "chartreuse": [127, 255, 0, 255],
    "chocolate": [210, 105, 30, 255],
    "coral": [255, 127, 80, 255],
    "cornflowerblue": [100, 149, 237, 255],
    "cornsilk": [255, 248, 220, 255],
    "crimson": [220, 20, 60, 255],
    "cyan": [0, 255, 255, 255],
    "darkblue": [0, 0, 139, 255],
    "darkcyan": [0, 139, 139, 255],
    "darkgoldenrod": [184, 134, 11, 255],
    "darkgray": [169, 169, 169, 255],
    "darkgreen": [0, 100, 0, 255],
    "darkgrey": [169, 169, 169, 255],
    "darkkhaki": [189, 183, 107, 255],
    "darkmagenta": [139, 0, 139, 255],
    "darkolivegreen": [85, 107, 47, 255],
    "darkorange": [255, 140, 0, 255],
    "darkorchid": [153, 50, 204, 255],
    "darkred": [139, 0, 0, 255],
    "darksalmon": [233, 150, 122, 255],
    "darkseagreen": [143, 188, 143, 255],
    "darkslateblue": [72, 61, 139, 255],
    "darkslategray": [47, 79, 79, 255],
    "darkslategrey": [47, 79, 79, 255],
    "darkturquoise": [0, 206, 209, 255],
    "darkviolet": [148, 0, 211, 255],
    "deeppink": [255, 20, 147, 255],
    "deepskyblue": [0, 191, 255, 255],
    "dimgray": [105, 105, 105, 255],
    "dimgrey": [105, 105, 105, 255],
    "dodgerblue": [30, 144, 255, 255],
    "firebrick": [178, 34, 34, 255],
    "floralwhite": [255, 250, 240, 255],
    "forestgreen": [34, 139, 34, 255],
    "fuchsia": [255, 0, 255, 255],
    "gainsboro": [220, 220, 220, 255],
    "ghostwhite": [248, 248, 255, 255],
    "gold": [255, 215, 0, 255],
    "goldenrod": [218, 165, 32, 255],
    "gray": [128, 128, 128, 255],
    "green": [0, 128, 0, 255],
    "greenyellow": [173, 255, 47, 255],
    "grey": [128, 128, 128, 255],
    "honeydew": [240, 255, 240, 255],
    "hotpink": [255, 105, 180, 255],
    "indianred": [205, 92, 92, 255],
    "indigo": [75, 0, 130, 255],
    "ivory": [255, 255, 240, 255],
    "khaki": [240, 230, 140, 255],
    "lavender": [230, 230, 250, 255],
    "lavenderblush": [255, 240, 245, 255],
    "lawngreen": [124, 252, 0, 255],
    "lemonchiffon": [255, 250, 205, 255],
    "lightblue": [173, 216, 230, 255],
    "lightcoral": [240, 128, 128, 255],
    "lightcyan": [224, 255, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210, 255],
    "lightgray": [211, 211, 211, 255],
    "lightgreen": [144, 238, 144, 255],
    "lightgrey": [211, 211, 211, 255],
    "lightpink": [255, 182, 193, 255],
    "lightsalmon": [255, 160, 122, 255],
    "lightseagreen": [32, 178, 170, 255],
    "lightskyblue": [135, 206, 250, 255],
    "lightslategray": [119, 136, 153, 255],
    "lightslategrey": [119, 136, 153, 255],
    "lightsteelblue": [176, 196, 222, 255],
    "lightyellow": [255, 255, 224, 255],
    "lime": [0, 255, 0, 255],
    "limegreen": [50, 205, 50, 255],
    "linen": [250, 240, 230, 255],
    "magenta": [255, 0, 255, 255],
    "maroon": [128, 0, 0, 255],
    "mediumaquamarine": [102, 205, 170, 255],
    "mediumblue": [0, 0, 205, 255],
    "mediumorchid": [186, 85, 211, 255],
    "mediumpurple": [147, 112, 219, 255],
    "mediumseagreen": [60, 179, 113, 255],
    "mediumslateblue": [123, 104, 238, 255],
    "mediumspringgreen": [0, 250, 154, 255],
    "mediumturquoise": [72, 209, 204, 255],
    "mediumvioletred": [199, 21, 133, 255],
    "midnightblue": [25, 25, 112, 255],
    "mintcream": [245, 255, 250, 255],
    "mistyrose": [255, 228, 225, 255],
    "moccasin": [255, 228, 181, 255],
    "navajowhite": [255, 222, 173, 255],
    "navy": [0, 0, 128, 255],
    "oldlace": [253, 245, 230, 255],
    "olive": [128, 128, 0, 255],
    "olivedrab": [107, 142, 35, 255],
    "orange": [255, 165, 0, 255],
    "orangered": [255, 69, 0, 255],
    "orchid": [218, 112, 214, 255],
    "palegoldenrod": [238, 232, 170, 255],
    "palegreen": [152, 251, 152, 255],
    "paleturquoise": [175, 238, 238, 255],
    "palevioletred": [219, 112, 147, 255],
    "papayawhip": [255, 239, 213, 255],
    "peachpuff": [255, 218, 185, 255],
    "peru": [205, 133, 63, 255],
    "pink": [255, 192, 203, 255],
    "plum": [221, 160, 221, 255],
    "powderblue": [176, 224, 230, 255],
    "purple": [128, 0, 128, 255],
    "red": [255, 0, 0, 255],
    "rosybrown": [188, 143, 143, 255],
    "royalblue": [65, 105, 225, 255],
    "saddlebrown": [139, 69, 19, 255],
    "salmon": [250, 128, 114, 255],
    "sandybrown": [244, 164, 96, 255],
    "seagreen": [46, 139, 87, 255],
    "seashell": [255, 245, 238, 255],
    "sienna": [160, 82, 45, 255],
    "silver": [192, 192, 192, 255],
    "skyblue": [135, 206, 235, 255],
    "slateblue": [106, 90, 205, 255],
    "slategray": [112, 128, 144, 255],
    "slategrey": [112, 128, 144, 255],
    "snow": [255, 250, 250, 255],
    "springgreen": [0, 255, 127, 255],
    "steelblue": [70, 130, 180, 255],
    "tan": [210, 180, 140, 255],
    "teal": [0, 128, 128, 255],
    "thistle": [216, 191, 216, 255],
    "tomato": [255, 99, 71, 255],
    "turquoise": [64, 224, 208, 255],
    "violet": [238, 130, 238, 255],
    "wheat": [245, 222, 179, 255],
    "white": [255, 255, 255, 255],
    "whitesmoke": [245, 245, 245, 255],
    "yellow": [255, 255, 0, 255],
    "yellowgreen": [154, 205, 50, 255]
  };
  function clamp_css_byte(i) {
    i = Math.round(i);
    return i < 0 ? 0 : i > 255 ? 255 : i;
  }
  function clamp_css_float(f) {
    return f < 0 ? 0 : f > 1 ? 1 : f;
  }
  function parse_css_int(str) {
    if (str[str.length - 1] === '%')
      return clamp_css_byte(parseFloat(str) / 100 * 255);
    return clamp_css_byte(parseInt(str));
  }
  function parse_css_float(str) {
    if (str[str.length - 1] === '%')
      return clamp_css_float(parseFloat(str) / 100);
    return clamp_css_float(parseFloat(str));
  }
  function css_hue_to_rgb(m1, m2, h) {
    if (h < 0)
      h += 1;
    else if (h > 1)
      h -= 1;
    if (h * 6 < 1)
      return m1 + (m2 - m1) * h * 6;
    if (h * 2 < 1)
      return m2;
    if (h * 3 < 2)
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    return m1;
  }
  function parseCSSColor(css_str) {
    if (css_str instanceof Array && (css_str.length >= 3) && (css_str.length <= 4)) {
      return [parseInt(css_str[0], 10), parseInt(css_str[1], 10), parseInt(css_str[2], 10), isFinite(css_str[3]) ? parseInt(css_str[3], 10) : 255];
    }
    var str = css_str.replace(/ /g, '').toLowerCase();
    if (str in kCSSColorTable)
      return kCSSColorTable[str].slice();
    if (str[0] === '#') {
      if (str.length === 4) {
        var iv = parseInt(str.substr(1), 16);
        if (!(iv >= 0 && iv <= 0xfff))
          return null;
        return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8), (iv & 0xf0) | ((iv & 0xf0) >> 4), (iv & 0xf) | ((iv & 0xf) << 4), 255];
      } else if (str.length === 7) {
        var iv = parseInt(str.substr(1), 16);
        if (!(iv >= 0 && iv <= 0xffffff))
          return null;
        return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 255];
      }
      return null;
    }
    var op = str.indexOf('('),
        ep = str.indexOf(')');
    if (op !== -1 && ep + 1 === str.length) {
      var fname = str.substr(0, op);
      var params = str.substr(op + 1, ep - (op + 1)).split(',');
      var alpha = 255;
      switch (fname) {
        case 'rgba':
          if (params.length !== 4)
            return null;
          alpha = (parse_css_float(params.pop()) * 255) | 0;
        case 'rgb':
          if (params.length !== 3)
            return null;
          return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];
        case 'hsla':
          if (params.length !== 4)
            return null;
          alpha = (parse_css_float(params.pop()) * 255) | 0;
        case 'hsl':
          if (params.length !== 3)
            return null;
          var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;
          var s = parse_css_float(params[1]);
          var l = parse_css_float(params[2]);
          var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          var m1 = l * 2 - m2;
          return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];
        default:
          return null;
      }
    }
    return null;
  }
  module.exports = parseCSSColor;
  global.define = __define;
  return module.exports;
});

$__System.register('31', ['30'], function (_export) {
  /* eslint-disable no-console */
  // Mapping of OSC addresses to Redux actions with transformed payload.
  // Return a falsey value to inhibit dispatch.
  'use strict';

  var parseCSSColor, parseColourMsg, oscHandlers;
  return {
    setters: [function (_) {
      parseCSSColor = _['default'];
    }],
    execute: function () {
      parseColourMsg = function parseColourMsg(name) {
        return function (msg) {
          var action = { type: '/renderer/' + name, payload: [0, 0, 0, 0] };
          var input = msg.args.length === 1 ? msg.args[0] : msg.args;
          console.log(name + ' input: ' + input);
          var colour = parseCSSColor(input);
          if (colour) {
            action.payload = colour;
            console.log(name + ' output:', colour);
          }
          return action;
        };
      };

      // TODO: Whitelist accepted OSC messages. Coerce/validate args.
      oscHandlers = {
        '/renderer/FOREGROUND': parseColourMsg('FOREGROUND'),
        '/renderer/BACKGROUND': parseColourMsg('BACKGROUND'),
        '/renderer/CLEAR_COLOUR': parseColourMsg('CLEAR_COLOUR')
      };

      _export('default', oscHandlers);
    }
  };
});
$__System.register('32', ['12', '31', '33', '34', '2f', '2d', '2e'], function (_export) {
  var _extends, oscHandlers, cancellablePromise, _Promise, _regeneratorRuntime, chalk, effects, isCancelError, marked0$0, util, call, cancel, fork, put, race, take, OSC_RECV, SOCKET_OPENED, SOCKET_CLOSED, SOCKET_ERROR, SOCKET_OPEN, SOCKET_CLOSE, conlog, conwarn, conerr, oscSource, defaultOscHandler;

  function fetchSocket(source) {
    var msg, action;
    return _regeneratorRuntime.wrap(function fetchSocket$(context$1$0) {
      while (1) switch (context$1$0.prev = context$1$0.next) {
        case 0:
          context$1$0.prev = 0;

          conlog('* OSC fetchSocket');

          context$1$0.next = 4;
          return call(source.nextMessage);

        case 4:
          msg = context$1$0.sent;

        case 5:
          if (!msg) {
            context$1$0.next = 33;
            break;
          }

          if (!(msg.type && msg.type === OSC_RECV)) {
            context$1$0.next = 15;
            break;
          }

          action = null;

          if (oscHandlers.hasOwnProperty(msg.addr)) {
            action = oscHandlers[msg.addr](msg);
            conlog('using OSC/RECV handler for msg:', util.inspect(msg), '=>', action);
          } else {
            conwarn('using default OSC/RECV handler for msg:', util.inspect(msg));
            action = defaultOscHandler(msg);
          }

          if (!action) {
            context$1$0.next = 13;
            break;
          }

          conlog('> OSC put', util.inspect(action));
          context$1$0.next = 13;
          return put(action);

        case 13:
          context$1$0.next = 28;
          break;

        case 15:
          if (!(msg === 'opened')) {
            context$1$0.next = 20;
            break;
          }

          context$1$0.next = 18;
          return put({ type: SOCKET_OPENED });

        case 18:
          context$1$0.next = 28;
          break;

        case 20:
          if (!(msg === 'closed')) {
            context$1$0.next = 25;
            break;
          }

          context$1$0.next = 23;
          return put({ type: SOCKET_CLOSED });

        case 23:
          context$1$0.next = 28;
          break;

        case 25:
          conwarn('unknown message type on OSC socket', msg);
          context$1$0.next = 28;
          return put({ type: SOCKET_ERROR, error: msg });

        case 28:
          context$1$0.next = 30;
          return call(source.nextMessage);

        case 30:
          msg = context$1$0.sent;
          context$1$0.next = 5;
          break;

        case 33:
          context$1$0.next = 38;
          break;

        case 35:
          context$1$0.prev = 35;
          context$1$0.t0 = context$1$0['catch'](0);

          if (!isCancelError(context$1$0.t0)) {
            conerr('* OSC fetchSocket error', context$1$0.t0);
          }

        case 38:
        case 'end':
          return context$1$0.stop();
      }
    }, marked0$0[0], this, [[0, 35]]);
  }

  function oscSaga() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var socket, source, awaitOpen, active, fetchTask, winner;
    return _regeneratorRuntime.wrap(function oscSaga$(context$1$0) {
      while (1) switch (context$1$0.prev = context$1$0.next) {
        case 0:
          if (!(args.length < 2)) {
            context$1$0.next = 2;
            break;
          }

          throw new Error('*oscSaga requires second parameter to be a Socket instance');

        case 2:
          conlog('* oscSaga');

          context$1$0.next = 5;
          return take('/plask/INIT');

        case 5:
          conlog('* oscSaga/INIT');

          socket = args[1];
          source = oscSource(socket);
          awaitOpen = false;
          active = true;

        case 10:
          if (!active) {
            context$1$0.next = 30;
            break;
          }

          if (!awaitOpen) {
            context$1$0.next = 15;
            break;
          }

          context$1$0.next = 14;
          return take(SOCKET_OPEN);

        case 14:
          conlog(SOCKET_OPEN);

        case 15:
          context$1$0.next = 17;
          return fork(fetchSocket, source);

        case 17:
          fetchTask = context$1$0.sent;

          // Open socket.
          socket.open();

          // TODO: Fork socket sending.

          // Race: didClose, close, error, open.
          context$1$0.next = 21;
          return race({
            didClose: take(SOCKET_CLOSED),
            erred: take(SOCKET_ERROR),
            close: take(SOCKET_CLOSE),
            open: take(SOCKET_OPEN)
          });

        case 21:
          winner = context$1$0.sent;

          conwarn('***** oscSaga race!', winner, fetchTask.isRunning());

          // Cancel fetch & send.
          conwarn('cancelling socket fetch');
          context$1$0.next = 26;
          return cancel(fetchTask);

        case 26:

          // TODO: Dispatch socket status: winner.

          // Close if didClose didn't win race.
          if (!winner.didClose) {
            socket.close();
          }

          // If socket closed or errored then await new open request, i.e. from direct user intervention.
          awaitOpen = !winner.open;
          context$1$0.next = 10;
          break;

        case 30:
        case 'end':
          return context$1$0.stop();
      }
    }, marked0$0[1], this);
  }
  return {
    setters: [function (_) {
      _extends = _['default'];
    }, function (_4) {
      oscHandlers = _4['default'];
    }, function (_3) {
      cancellablePromise = _3.cancellablePromise;
    }, function (_2) {
      _Promise = _2['default'];
    }, function (_f) {
      _regeneratorRuntime = _f['default'];
    }, function (_d) {
      chalk = _d['default'];
    }, function (_e) {
      effects = _e.effects;
      isCancelError = _e.isCancelError;
    }],
    execute: function () {
      /* eslint-disable no-console */
      /* eslint no-param-reassign: [2, {"props": false }] */

      // Socket notifications.
      'use strict';

      marked0$0 = [fetchSocket, oscSaga].map(_regeneratorRuntime.mark);
      util = require('util');
      call = effects.call;
      cancel = effects.cancel;
      fork = effects.fork;
      put = effects.put;
      race = effects.race;
      take = effects.take;
      OSC_RECV = '/osc/RECV';
      SOCKET_OPENED = '/socket/OPENED';
      SOCKET_CLOSED = '/socket/CLOSED';
      SOCKET_ERROR = '/socket/ERROR';

      // Socket manipulation requests.
      SOCKET_OPEN = '/socket/OPEN';
      SOCKET_CLOSE = '/socket/CLOSE';

      conlog = function conlog() {
        var _chalk$blue;

        return console.log((_chalk$blue = chalk.blue).bold.apply(_chalk$blue, arguments));
      };

      conwarn = function conwarn() {
        var _chalk$magenta;

        return console.warn((_chalk$magenta = chalk.magenta).bold.apply(_chalk$magenta, arguments));
      };

      conerr = function conerr() {
        var _chalk$blue$inverse$white;

        return console.error((_chalk$blue$inverse$white = chalk.blue.inverse.white).bold.apply(_chalk$blue$inverse$white, arguments));
      };

      oscSource = function oscSource(socket) {
        var messageQueue = [];
        var resolveQueue = [];
        var resolve = function resolve(msg) {
          if (resolveQueue.length) {
            var nextResolve = resolveQueue.shift();
            nextResolve(msg);
          } else {
            messageQueue.push(msg);
          }
        };
        socket.on('opened', function () {
          conlog('OSC socket/opened');
          resolve('opened');
        });
        socket.on('error', function (err) {
          conerr('OSC socket/error', err);
          resolve(err);
        });
        socket.on('closed', function () {
          conwarn('OSC socket/closed');
          resolve('closed');
        });
        socket.on('osc', function (event) {
          var res = _extends({
            type: OSC_RECV
          }, event);
          conlog('OSC socket/receive', util.inspect(res));
          resolve(res);
        });
        return {
          nextMessage: function nextMessage() {
            return messageQueue.length ? cancellablePromise(_Promise.resolve(messageQueue.shift())) : cancellablePromise(new _Promise(function (resolver) {
              return resolveQueue.push(resolver);
            }));
          }
        };
      };

      // FIXME: Replace with explicit whitelisting of all accepted OSC verbs in oscHandlers.js.

      defaultOscHandler = function defaultOscHandler(msg) {
        return {
          type: msg.addr,
          payload: msg.args.length === 1 ? msg.args[0] : msg.args
        };
      };

      _export('default', oscSaga);
    }
  };
});
// Await user-initiated open socket request.

// Fork socket fetching.
$__System.registerDynamic("35", ["23", "20"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('23'),
      toIObject = $__require('20');
  module.exports = function(object, el) {
    var O = toIObject(object),
        keys = $.getKeys(O),
        length = keys.length,
        index = 0,
        key;
    while (length > index)
      if (O[key = keys[index++]] === el)
        return key;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("36", ["20", "23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('20'),
      getNames = $__require('23').getNames,
      toString = {}.toString;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames(toIObject(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("37", ["23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('23');
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          keys.push(key);
    }
    return keys;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("38", ["39"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('39');
  module.exports = Array.isArray || function(arg) {
    return cof(arg) == 'Array';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3a", ["23", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "35", "36", "37", "38", "45", "20", "46", "47"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('23'),
      global = $__require('3b'),
      has = $__require('3c'),
      DESCRIPTORS = $__require('3d'),
      $export = $__require('3e'),
      redefine = $__require('3f'),
      $fails = $__require('40'),
      shared = $__require('41'),
      setToStringTag = $__require('42'),
      uid = $__require('43'),
      wks = $__require('44'),
      keyOf = $__require('35'),
      $names = $__require('36'),
      enumKeys = $__require('37'),
      isArray = $__require('38'),
      anObject = $__require('45'),
      toIObject = $__require('20'),
      createDesc = $__require('46'),
      getDesc = $.getDesc,
      setDesc = $.setDesc,
      _create = $.create,
      getNames = $names.get,
      $Symbol = global.Symbol,
      $JSON = global.JSON,
      _stringify = $JSON && $JSON.stringify,
      setter = false,
      HIDDEN = wks('_hidden'),
      isEnum = $.isEnum,
      SymbolRegistry = shared('symbol-registry'),
      AllSymbols = shared('symbols'),
      useNative = typeof $Symbol == 'function',
      ObjectProto = Object.prototype;
  var setSymbolDesc = DESCRIPTORS && $fails(function() {
    return _create(setDesc({}, 'a', {get: function() {
        return setDesc(this, 'a', {value: 7}).a;
      }})).a != 7;
  }) ? function(it, key, D) {
    var protoDesc = getDesc(ObjectProto, key);
    if (protoDesc)
      delete ObjectProto[key];
    setDesc(it, key, D);
    if (protoDesc && it !== ObjectProto)
      setDesc(ObjectProto, key, protoDesc);
  } : setDesc;
  var wrap = function(tag) {
    var sym = AllSymbols[tag] = _create($Symbol.prototype);
    sym._k = tag;
    DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: function(value) {
        if (has(this, HIDDEN) && has(this[HIDDEN], tag))
          this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      }
    });
    return sym;
  };
  var isSymbol = function(it) {
    return typeof it == 'symbol';
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (D && has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN))
          setDesc(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key])
          it[HIDDEN][key] = false;
        D = _create(D, {enumerable: createDesc(0, false)});
      }
      return setSymbolDesc(it, key, D);
    }
    return setDesc(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P)),
        i = 0,
        l = keys.length,
        key;
    while (l > i)
      $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key);
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    var D = getDesc(it = toIObject(it), key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
      D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (!has(AllSymbols, key = names[i++]) && key != HIDDEN)
        result.push(key);
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (has(AllSymbols, key = names[i++]))
        result.push(AllSymbols[key]);
    return result;
  };
  var $stringify = function stringify(it) {
    if (it === undefined || isSymbol(it))
      return;
    var args = [it],
        i = 1,
        $$ = arguments,
        replacer,
        $replacer;
    while ($$.length > i)
      args.push($$[i++]);
    replacer = args[1];
    if (typeof replacer == 'function')
      $replacer = replacer;
    if ($replacer || !isArray(replacer))
      replacer = function(key, value) {
        if ($replacer)
          value = $replacer.call(this, key, value);
        if (!isSymbol(value))
          return value;
      };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  };
  var buggyJSON = $fails(function() {
    var S = $Symbol();
    return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
  });
  if (!useNative) {
    $Symbol = function Symbol() {
      if (isSymbol(this))
        throw TypeError('Symbol is not a constructor');
      return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
    };
    redefine($Symbol.prototype, 'toString', function toString() {
      return this._k;
    });
    isSymbol = function(it) {
      return it instanceof $Symbol;
    };
    $.create = $create;
    $.isEnum = $propertyIsEnumerable;
    $.getDesc = $getOwnPropertyDescriptor;
    $.setDesc = $defineProperty;
    $.setDescs = $defineProperties;
    $.getNames = $names.get = $getOwnPropertyNames;
    $.getSymbols = $getOwnPropertySymbols;
    if (DESCRIPTORS && !$__require('47')) {
      redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
  }
  var symbolStatics = {
    'for': function(key) {
      return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(key) {
      return keyOf(SymbolRegistry, key);
    },
    useSetter: function() {
      setter = true;
    },
    useSimple: function() {
      setter = false;
    }
  };
  $.each.call(('hasInstance,isConcatSpreadable,iterator,match,replace,search,' + 'species,split,toPrimitive,toStringTag,unscopables').split(','), function(it) {
    var sym = wks(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  });
  setter = true;
  $export($export.G + $export.W, {Symbol: $Symbol});
  $export($export.S, 'Symbol', symbolStatics);
  $export($export.S + $export.F * !useNative, 'Object', {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
  setToStringTag($Symbol, 'Symbol');
  setToStringTag(Math, 'Math', true);
  setToStringTag(global.JSON, 'JSON', true);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("48", ["3a", "49", "4a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('3a');
  $__require('49');
  module.exports = $__require('4a').Symbol;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4b", ["48"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('48');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4c", ["4b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('4b'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4d", ["23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('23');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("25", ["4d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('4d'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4e", ["3e", "4f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('3e');
  $export($export.S, 'Object', {setPrototypeOf: $__require('4f').set});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("50", ["4e", "4a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('4e');
  module.exports = $__require('4a').Object.setPrototypeOf;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("26", ["50"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('50'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("51", ["4c", "25", "26", "34", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var _Symbol = $__require('4c')["default"];
    var _Object$create = $__require('25')["default"];
    var _Object$setPrototypeOf = $__require('26')["default"];
    var _Promise = $__require('34')["default"];
    !(function(global) {
      "use strict";
      var hasOwn = Object.prototype.hasOwnProperty;
      var undefined;
      var $Symbol = typeof _Symbol === "function" ? _Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      var inModule = typeof module === "object";
      var runtime = global.regeneratorRuntime;
      if (runtime) {
        if (inModule) {
          module.exports = runtime;
        }
        return;
      }
      runtime = global.regeneratorRuntime = inModule ? module.exports : {};
      function wrap(innerFn, outerFn, self, tryLocsList) {
        var generator = _Object$create((outerFn || Generator).prototype);
        var context = new Context(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }
      runtime.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          prototype[method] = function(arg) {
            return this._invoke(method, arg);
          };
        });
      }
      runtime.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      runtime.mark = function(genFun) {
        if (_Object$setPrototypeOf) {
          _Object$setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          if (!(toStringTagSymbol in genFun)) {
            genFun[toStringTagSymbol] = "GeneratorFunction";
          }
        }
        genFun.prototype = _Object$create(Gp);
        return genFun;
      };
      runtime.awrap = function(arg) {
        return new AwaitArgument(arg);
      };
      function AwaitArgument(arg) {
        this.arg = arg;
      }
      function AsyncIterator(generator) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value instanceof AwaitArgument) {
              return _Promise.resolve(value.arg).then(function(value) {
                invoke("next", value, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return _Promise.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, reject);
          }
        }
        if (typeof process === "object" && process.domain) {
          invoke = process.domain.bind(invoke);
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new _Promise(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      runtime.async = function(innerFn, outerFn, self, tryLocsList) {
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
        return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
                context.delegate = null;
                var returnMethod = delegate.iterator["return"];
                if (returnMethod) {
                  var record = tryCatch(returnMethod, delegate.iterator, arg);
                  if (record.type === "throw") {
                    method = "throw";
                    arg = record.arg;
                    continue;
                  }
                }
                if (method === "return") {
                  continue;
                }
              }
              var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);
              if (record.type === "throw") {
                context.delegate = null;
                method = "throw";
                arg = record.arg;
                continue;
              }
              method = "next";
              arg = undefined;
              var info = record.arg;
              if (info.done) {
                context[delegate.resultName] = info.value;
                context.next = delegate.nextLoc;
              } else {
                state = GenStateSuspendedYield;
                return info;
              }
              context.delegate = null;
            }
            if (method === "next") {
              if (state === GenStateSuspendedYield) {
                context.sent = arg;
              } else {
                context.sent = undefined;
              }
            } else if (method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw arg;
              }
              if (context.dispatchException(arg)) {
                method = "next";
                arg = undefined;
              }
            } else if (method === "return") {
              context.abrupt("return", arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              var info = {
                value: record.arg,
                done: context.done
              };
              if (record.arg === ContinueSentinel) {
                if (context.delegate && method === "next") {
                  arg = undefined;
                }
              } else {
                return info;
              }
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              method = "throw";
              arg = record.arg;
            }
          }
        };
      }
      defineIteratorMethods(Gp);
      Gp[iteratorSymbol] = function() {
        return this;
      };
      Gp[toStringTagSymbol] = "Generator";
      Gp.toString = function() {
        return "[object Generator]";
      };
      function pushTryEntry(locs) {
        var entry = {tryLoc: locs[0]};
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{tryLoc: "root"}];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      runtime.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key = keys.pop();
            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i];
                      next.done = false;
                      return next;
                    }
                  }
                  next.value = undefined;
                  next.done = true;
                  return next;
                };
            return next.next = next;
          }
        }
        return {next: doneResult};
      }
      runtime.values = values;
      function doneResult() {
        return {
          value: undefined,
          done: true
        };
      }
      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = undefined;
          this.done = false;
          this.delegate = null;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.next = finallyEntry.finallyLoc;
          } else {
            this.complete(record);
          }
          return ContinueSentinel;
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = record.arg;
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };
          return ContinueSentinel;
        }
      };
    })(typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("52", ["51"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var g = typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : this;
  var hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
  var oldRuntime = hadRuntime && g.regeneratorRuntime;
  g.regeneratorRuntime = undefined;
  module.exports = $__require('51');
  if (hadRuntime) {
    g.regeneratorRuntime = oldRuntime;
  } else {
    try {
      delete g.regeneratorRuntime;
    } catch (e) {
      g.regeneratorRuntime = undefined;
    }
  }
  module.exports = {
    "default": module.exports,
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2f", ["52"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('52');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("21", ["3e", "4a", "40"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('3e'),
      core = $__require('4a'),
      fails = $__require('40');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("53", ["54", "21"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('54');
  $__require('21')('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("55", ["53", "4a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('53');
  module.exports = $__require('4a').Object.keys;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("56", ["55"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('55'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("57", ["58", "59", "5a", "5b", "5c", "5d", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var Stream = $__require('58').Stream;
    var util = $__require('59');
    var assert = $__require('5a');
    var bunyan = $__require('5b');
    var LRU = $__require('5c');
    var uuid = $__require('5d');
    var sprintf = util.format;
    var DEFAULT_REQ_ID = uuid.v4();
    var STR_FMT = '[object %s<level=%d, limit=%d, maxRequestIds=%d>]';
    function appendStream(streams, s) {
      assert.arrayOfObject(streams, 'streams');
      assert.object(s, 'stream');
      if (s instanceof Stream) {
        streams.push({
          raw: false,
          stream: s
        });
      } else {
        assert.optionalBool(s.raw, 'stream.raw');
        assert.object(s.stream, 'stream.stream');
        streams.push(s);
      }
    }
    function RequestCaptureStream(opts) {
      assert.object(opts, 'options');
      assert.optionalObject(opts.stream, 'options.stream');
      assert.optionalArrayOfObject(opts.streams, 'options.streams');
      assert.optionalNumber(opts.level, 'options.level');
      assert.optionalNumber(opts.maxRecords, 'options.maxRecords');
      assert.optionalNumber(opts.maxRequestIds, 'options.maxRequestIds');
      assert.optionalBool(opts.dumpDefault, 'options.dumpDefault');
      var self = this;
      Stream.call(this);
      this.level = opts.level ? bunyan.resolveLevel(opts.level) : bunyan.WARN;
      this.limit = opts.maxRecords || 100;
      this.maxRequestIds = opts.maxRequestIds || 1000;
      this.requestMap = LRU({max: self.maxRequestIds});
      this.dumpDefault = opts.dumpDefault;
      this._offset = -1;
      this._rings = [];
      this.streams = [];
      if (opts.stream) {
        appendStream(this.streams, opts.stream);
      }
      if (opts.streams) {
        opts.streams.forEach(appendStream.bind(null, this.streams));
      }
      this.haveNonRawStreams = false;
      for (var i = 0; i < this.streams.length; i++) {
        if (!this.streams[i].raw) {
          this.haveNonRawStreams = true;
          break;
        }
      }
    }
    util.inherits(RequestCaptureStream, Stream);
    RequestCaptureStream.prototype.write = function write(record) {
      var req_id = record.req_id || DEFAULT_REQ_ID;
      var ring;
      var self = this;
      if (!(ring = this.requestMap.get(req_id))) {
        if (++this._offset > this.maxRequestIds) {
          this._offset = 0;
        }
        if (this._rings.length <= this._offset) {
          this._rings.push(new bunyan.RingBuffer({limit: self.limit}));
        }
        ring = this._rings[this._offset];
        ring.records.length = 0;
        this.requestMap.set(req_id, ring);
      }
      assert.ok(ring, 'no ring found');
      if (record.level >= this.level) {
        var i,
            r,
            ser;
        for (i = 0; i < ring.records.length; i++) {
          r = ring.records[i];
          if (this.haveNonRawStreams) {
            ser = JSON.stringify(r, bunyan.safeCycles()) + '\n';
          }
          self.streams.forEach(function(s) {
            s.stream.write(s.raw ? r : ser);
          });
        }
        ring.records.length = 0;
        if (this.dumpDefault) {
          var defaultRing = self.requestMap.get(DEFAULT_REQ_ID);
          for (i = 0; i < defaultRing.records.length; i++) {
            r = defaultRing.records[i];
            if (this.haveNonRawStreams) {
              ser = JSON.stringify(r, bunyan.safeCycles()) + '\n';
            }
            self.streams.forEach(function(s) {
              s.stream.write(s.raw ? r : ser);
            });
          }
          defaultRing.records.length = 0;
        }
      } else {
        ring.write(record);
      }
    };
    RequestCaptureStream.prototype.toString = function toString() {
      return (sprintf(STR_FMT, this.constructor.name, this.level, this.limit, this.maxRequestIds));
    };
    var SERIALIZERS = {
      err: bunyan.stdSerializers.err,
      req: bunyan.stdSerializers.req,
      res: bunyan.stdSerializers.res,
      client_req: clientReq,
      client_res: clientRes
    };
    function clientReq(req) {
      if (!req) {
        return (req);
      }
      var host;
      try {
        host = req.host.split(':')[0];
      } catch (e) {
        host = false;
      }
      return ({
        method: req ? req.method : false,
        url: req ? req.path : false,
        address: host,
        port: req ? req.port : false,
        headers: req ? req.headers : false
      });
    }
    function clientRes(res) {
      if (!res || !res.statusCode) {
        return (res);
      }
      return ({
        statusCode: res.statusCode,
        headers: res.headers
      });
    }
    function createLogger(name) {
      return (bunyan.createLogger({
        name: name,
        serializers: SERIALIZERS,
        streams: [{
          level: 'warn',
          stream: process.stderr
        }, {
          level: 'debug',
          type: 'raw',
          stream: new RequestCaptureStream({stream: process.stderr})
        }]
      }));
    }
    module.exports = {
      RequestCaptureStream: RequestCaptureStream,
      serializers: SERIALIZERS,
      createLogger: createLogger
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5e", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = PseudoMap;
  function PseudoMap(set) {
    if (!(this instanceof PseudoMap))
      throw new TypeError("Constructor PseudoMap requires 'new'");
    this.clear();
    if (set) {
      if ((set instanceof PseudoMap) || (typeof Map === 'function' && set instanceof Map))
        set.forEach(function(value, key) {
          this.set(key, value);
        }, this);
      else if (Array.isArray(set))
        set.forEach(function(kv) {
          this.set(kv[0], kv[1]);
        }, this);
      else
        throw new TypeError('invalid argument');
    }
  }
  PseudoMap.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    Object.keys(this._data).forEach(function(k) {
      if (k !== 'size')
        fn.call(thisp, this._data[k].value, this._data[k].key);
    }, this);
  };
  PseudoMap.prototype.has = function(k) {
    return !!find(this._data, k);
  };
  PseudoMap.prototype.get = function(k) {
    var res = find(this._data, k);
    return res && res.value;
  };
  PseudoMap.prototype.set = function(k, v) {
    set(this._data, k, v);
  };
  PseudoMap.prototype.delete = function(k) {
    var res = find(this._data, k);
    if (res) {
      delete this._data[res._index];
      this._data.size--;
    }
  };
  PseudoMap.prototype.clear = function() {
    var data = Object.create(null);
    data.size = 0;
    Object.defineProperty(this, '_data', {
      value: data,
      enumerable: false,
      configurable: true,
      writable: false
    });
  };
  Object.defineProperty(PseudoMap.prototype, 'size', {
    get: function() {
      return this._data.size;
    },
    set: function(n) {},
    enumerable: true,
    configurable: true
  });
  PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {
    throw new Error('iterators are not implemented in this version');
  };
  function same(a, b) {
    return a === b || a !== a && b !== b;
  }
  function Entry(k, v, i) {
    this.key = k;
    this.value = v;
    this._index = i;
  }
  function find(data, k) {
    for (var i = 0,
        s = '_' + k,
        key = s; hasOwnProperty.call(data, key); key = s + i++) {
      if (same(data[key].key, k))
        return data[key];
    }
  }
  function set(data, k, v) {
    for (var i = 0,
        s = '_' + k,
        key = s; hasOwnProperty.call(data, key); key = s + i++) {
      if (same(data[key].key, k)) {
        data[key].value = v;
        return;
      }
    }
    data.size++;
    data[key] = new Entry(k, v, key);
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5f", ["5e", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    if (process.env.npm_package_name === 'pseudomap' && process.env.npm_lifecycle_script === 'test')
      process.env.TEST_PSEUDOMAP = 'true';
    if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
      module.exports = Map;
    } else {
      module.exports = $__require('5e');
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("60", ["5f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('5f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("61", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) {
      self = new Yallist();
    }
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === 'function') {
      list.forEach(function(item) {
        self.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0,
          l = arguments.length; i < l; i++) {
        self.push(arguments[i]);
      }
    }
    return self;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error('removing node which does not belong to this list');
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0,
        l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0,
        l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail)
      return undefined;
    var res = this.tail.value;
    this.tail = this.tail.prev;
    this.tail.next = null;
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head)
      return undefined;
    var res = this.head.value;
    this.head = this.head.next;
    this.head.prev = null;
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head,
        i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail,
        i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0,
        walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0,
        walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.head; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value');
    }
    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value');
    }
    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0,
        walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0,
        walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0,
        walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length,
        walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);
    if (!self.head) {
      self.head = self.tail;
    }
    self.length++;
  }
  function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);
    if (!self.tail) {
      self.tail = self.head;
    }
    self.length++;
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("62", ["61"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('61');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("63", ["60", "59", "62"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = LRUCache;
  var Map = $__require('60');
  var util = $__require('59');
  var Yallist = $__require('62');
  var symbols = {};
  var hasSymbol = typeof Symbol === 'function';
  var makeSymbol;
  if (hasSymbol) {
    makeSymbol = function(key) {
      return Symbol.for(key);
    };
  } else {
    makeSymbol = function(key) {
      return '_' + key;
    };
  }
  function priv(obj, key, val) {
    var sym;
    if (symbols[key]) {
      sym = symbols[key];
    } else {
      sym = makeSymbol(key);
      symbols[key] = sym;
    }
    if (arguments.length === 2) {
      return obj[sym];
    } else {
      obj[sym] = val;
      return val;
    }
  }
  function naiveLength() {
    return 1;
  }
  function LRUCache(options) {
    if (!(this instanceof LRUCache)) {
      return new LRUCache(options);
    }
    if (typeof options === 'number') {
      options = {max: options};
    }
    if (!options) {
      options = {};
    }
    var max = priv(this, 'max', options.max);
    if (!max || !(typeof max === 'number') || max <= 0) {
      priv(this, 'max', Infinity);
    }
    var lc = options.length || naiveLength;
    if (typeof lc !== 'function') {
      lc = naiveLength;
    }
    priv(this, 'lengthCalculator', lc);
    priv(this, 'allowStale', options.stale || false);
    priv(this, 'maxAge', options.maxAge || 0);
    priv(this, 'dispose', options.dispose);
    this.reset();
  }
  Object.defineProperty(LRUCache.prototype, 'max', {
    set: function(mL) {
      if (!mL || !(typeof mL === 'number') || mL <= 0) {
        mL = Infinity;
      }
      priv(this, 'max', mL);
      trim(this);
    },
    get: function() {
      return priv(this, 'max');
    },
    enumerable: true
  });
  Object.defineProperty(LRUCache.prototype, 'allowStale', {
    set: function(allowStale) {
      priv(this, 'allowStale', !!allowStale);
    },
    get: function() {
      return priv(this, 'allowStale');
    },
    enumerable: true
  });
  Object.defineProperty(LRUCache.prototype, 'maxAge', {
    set: function(mA) {
      if (!mA || !(typeof mA === 'number') || mA < 0) {
        mA = 0;
      }
      priv(this, 'maxAge', mA);
      trim(this);
    },
    get: function() {
      return priv(this, 'maxAge');
    },
    enumerable: true
  });
  Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
    set: function(lC) {
      if (typeof lC !== 'function') {
        lC = naiveLength;
      }
      if (lC !== priv(this, 'lengthCalculator')) {
        priv(this, 'lengthCalculator', lC);
        priv(this, 'length', 0);
        priv(this, 'lruList').forEach(function(hit) {
          hit.length = priv(this, 'lengthCalculator').call(this, hit.value, hit.key);
          priv(this, 'length', priv(this, 'length') + hit.length);
        }, this);
      }
      trim(this);
    },
    get: function() {
      return priv(this, 'lengthCalculator');
    },
    enumerable: true
  });
  Object.defineProperty(LRUCache.prototype, 'length', {
    get: function() {
      return priv(this, 'length');
    },
    enumerable: true
  });
  Object.defineProperty(LRUCache.prototype, 'itemCount', {
    get: function() {
      return priv(this, 'lruList').length;
    },
    enumerable: true
  });
  LRUCache.prototype.rforEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = priv(this, 'lruList').tail; walker !== null; ) {
      var prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  };
  function forEachStep(self, fn, node, thisp) {
    var hit = node.value;
    if (isStale(self, hit)) {
      del(self, node);
      if (!priv(self, 'allowStale')) {
        hit = undefined;
      }
    }
    if (hit) {
      fn.call(thisp, hit.value, hit.key, self);
    }
  }
  LRUCache.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = priv(this, 'lruList').head; walker !== null; ) {
      var next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  };
  LRUCache.prototype.keys = function() {
    return priv(this, 'lruList').toArray().map(function(k) {
      return k.key;
    }, this);
  };
  LRUCache.prototype.values = function() {
    return priv(this, 'lruList').toArray().map(function(k) {
      return k.value;
    }, this);
  };
  LRUCache.prototype.reset = function() {
    if (priv(this, 'dispose') && priv(this, 'lruList') && priv(this, 'lruList').length) {
      priv(this, 'lruList').forEach(function(hit) {
        priv(this, 'dispose').call(this, hit.key, hit.value);
      }, this);
    }
    priv(this, 'cache', new Map());
    priv(this, 'lruList', new Yallist());
    priv(this, 'length', 0);
  };
  LRUCache.prototype.dump = function() {
    return priv(this, 'lruList').map(function(hit) {
      if (!isStale(this, hit)) {
        return {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }
    }, this).toArray().filter(function(h) {
      return h;
    });
  };
  LRUCache.prototype.dumpLru = function() {
    return priv(this, 'lruList');
  };
  LRUCache.prototype.inspect = function(n, opts) {
    var str = 'LRUCache {';
    var extras = false;
    var as = priv(this, 'allowStale');
    if (as) {
      str += '\n  allowStale: true';
      extras = true;
    }
    var max = priv(this, 'max');
    if (max && max !== Infinity) {
      if (extras) {
        str += ',';
      }
      str += '\n  max: ' + util.inspect(max, opts);
      extras = true;
    }
    var maxAge = priv(this, 'maxAge');
    if (maxAge) {
      if (extras) {
        str += ',';
      }
      str += '\n  maxAge: ' + util.inspect(maxAge, opts);
      extras = true;
    }
    var lc = priv(this, 'lengthCalculator');
    if (lc && lc !== naiveLength) {
      if (extras) {
        str += ',';
      }
      str += '\n  length: ' + util.inspect(priv(this, 'length'), opts);
      extras = true;
    }
    var didFirst = false;
    priv(this, 'lruList').forEach(function(item) {
      if (didFirst) {
        str += ',\n  ';
      } else {
        if (extras) {
          str += ',\n';
        }
        didFirst = true;
        str += '\n  ';
      }
      var key = util.inspect(item.key).split('\n').join('\n  ');
      var val = {value: item.value};
      if (item.maxAge !== maxAge) {
        val.maxAge = item.maxAge;
      }
      if (lc !== naiveLength) {
        val.length = item.length;
      }
      if (isStale(this, item)) {
        val.stale = true;
      }
      val = util.inspect(val, opts).split('\n').join('\n  ');
      str += key + ' => ' + val;
    });
    if (didFirst || extras) {
      str += '\n';
    }
    str += '}';
    return str;
  };
  LRUCache.prototype.set = function(key, value, maxAge) {
    maxAge = maxAge || priv(this, 'maxAge');
    var now = maxAge ? Date.now() : 0;
    var len = priv(this, 'lengthCalculator').call(this, value, key);
    if (priv(this, 'cache').has(key)) {
      if (len > priv(this, 'max')) {
        del(this, priv(this, 'cache').get(key));
        return false;
      }
      var node = priv(this, 'cache').get(key);
      var item = node.value;
      if (priv(this, 'dispose')) {
        priv(this, 'dispose').call(this, key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      priv(this, 'length', priv(this, 'length') + (len - item.length));
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    var hit = new Entry(key, value, len, now, maxAge);
    if (hit.length > priv(this, 'max')) {
      if (priv(this, 'dispose')) {
        priv(this, 'dispose').call(this, key, value);
      }
      return false;
    }
    priv(this, 'length', priv(this, 'length') + hit.length);
    priv(this, 'lruList').unshift(hit);
    priv(this, 'cache').set(key, priv(this, 'lruList').head);
    trim(this);
    return true;
  };
  LRUCache.prototype.has = function(key) {
    if (!priv(this, 'cache').has(key))
      return false;
    var hit = priv(this, 'cache').get(key).value;
    if (isStale(this, hit)) {
      return false;
    }
    return true;
  };
  LRUCache.prototype.get = function(key) {
    return get(this, key, true);
  };
  LRUCache.prototype.peek = function(key) {
    return get(this, key, false);
  };
  LRUCache.prototype.pop = function() {
    var node = priv(this, 'lruList').tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  };
  LRUCache.prototype.del = function(key) {
    del(this, priv(this, 'cache').get(key));
  };
  LRUCache.prototype.load = function(arr) {
    this.reset();
    var now = Date.now();
    for (var l = arr.length - 1; l >= 0; l--) {
      var hit = arr[l];
      var expiresAt = hit.e || 0;
      if (expiresAt === 0) {
        this.set(hit.k, hit.v);
      } else {
        var maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  };
  LRUCache.prototype.prune = function() {
    var self = this;
    priv(this, 'cache').forEach(function(value, key) {
      get(self, key, false);
    });
  };
  function get(self, key, doUse) {
    var node = priv(self, 'cache').get(key);
    if (node) {
      var hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!priv(self, 'allowStale'))
          hit = undefined;
      } else {
        if (doUse) {
          priv(self, 'lruList').unshiftNode(node);
        }
      }
      if (hit)
        hit = hit.value;
    }
    return hit;
  }
  function isStale(self, hit) {
    if (!hit || (!hit.maxAge && !priv(self, 'maxAge'))) {
      return false;
    }
    var stale = false;
    var diff = Date.now() - hit.now;
    if (hit.maxAge) {
      stale = diff > hit.maxAge;
    } else {
      stale = priv(self, 'maxAge') && (diff > priv(self, 'maxAge'));
    }
    return stale;
  }
  function trim(self) {
    if (priv(self, 'length') > priv(self, 'max')) {
      for (var walker = priv(self, 'lruList').tail; priv(self, 'length') > priv(self, 'max') && walker !== null; ) {
        var prev = walker.prev;
        del(self, walker);
        walker = prev;
      }
    }
  }
  function del(self, node) {
    if (node) {
      var hit = node.value;
      if (priv(self, 'dispose')) {
        priv(self, 'dispose').call(this, hit.key, hit.value);
      }
      priv(self, 'length', priv(self, 'length') - hit.length);
      priv(self, 'cache').delete(hit.key);
      priv(self, 'lruList').removeNode(node);
    }
  }
  function Entry(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5c", ["63"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('63');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("64", ["1a", "68", "59", "69", "5a", "5c", "67", "6a", "65", "66"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var EventEmitter = $__require('1a').EventEmitter;
  var url = $__require('68');
  var util = $__require('59');
  var errors = $__require('69');
  var assert = $__require('5a');
  var LRU = $__require('5c');
  var Negotiator = $__require('67');
  var semver = $__require('6a');
  var cors = $__require('65');
  var utils = $__require('66');
  var DEF_CT = 'application/octet-stream';
  var BadRequestError = errors.BadRequestError;
  var InternalError = errors.InternalError;
  var InvalidArgumentError = errors.InvalidArgumentError;
  var InvalidVersionError = errors.InvalidVersionError;
  var MethodNotAllowedError = errors.MethodNotAllowedError;
  var ResourceNotFoundError = errors.ResourceNotFoundError;
  var UnsupportedMediaTypeError = errors.UnsupportedMediaTypeError;
  var shallowCopy = utils.shallowCopy;
  function matchURL(re, req) {
    var i = 0;
    var result = re.exec(req.path());
    var params = {};
    if (!result) {
      return (false);
    }
    if (!re.restifyParams) {
      for (i = 1; i < result.length; i++) {
        params[(i - 1)] = result[i];
      }
      return (params);
    }
    if (re.restifyParams.length === 0) {
      return (params);
    }
    re.restifyParams.forEach(function(p) {
      if (++i < result.length) {
        params[p] = decodeURIComponent(result[i]);
      }
    });
    return (params);
  }
  function compileURL(options) {
    if (options.url instanceof RegExp) {
      return (options.url);
    }
    assert.string(options.url, 'url');
    var params = [];
    var pattern = '^';
    var re;
    var _url = url.parse(options.url).pathname;
    _url.split('/').forEach(function(frag) {
      if (frag.length <= 0) {
        return (false);
      }
      pattern += '\\/+';
      if (frag.charAt(0) === ':') {
        var label = frag;
        var index = frag.indexOf('(');
        var subexp;
        if (index === -1) {
          if (options.urlParamPattern) {
            subexp = options.urlParamPattern;
          } else {
            subexp = '[^/]*';
          }
        } else {
          label = frag.substring(0, index);
          subexp = frag.substring(index + 1, frag.length - 1);
        }
        pattern += '(' + subexp + ')';
        params.push(label.slice(1));
      } else {
        pattern += frag;
      }
      return (true);
    });
    if (pattern === '^') {
      pattern += '\\/';
    }
    pattern += '$';
    re = new RegExp(pattern, options.flags);
    re.restifyParams = params;
    return (re);
  }
  function Router(options) {
    assert.object(options, 'options');
    assert.object(options.log, 'options.log');
    EventEmitter.call(this);
    this.cache = LRU({max: 100});
    this.contentType = options.contentType || [];
    if (!Array.isArray(this.contentType)) {
      this.contentType = [this.contentType];
    }
    assert.arrayOfString(this.contentType, 'options.contentType');
    this.log = options.log;
    this.mounts = {};
    this.name = 'RestifyRouter';
    this.routes = {
      DELETE: [],
      GET: [],
      HEAD: [],
      OPTIONS: [],
      PATCH: [],
      POST: [],
      PUT: []
    };
    this.reverse = {};
    this.versions = options.versions || options.version || [];
    if (!Array.isArray(this.versions)) {
      this.versions = [this.versions];
    }
    assert.arrayOfString(this.versions, 'options.versions');
    this.versions.forEach(function(v) {
      if (semver.valid(v)) {
        return (true);
      }
      throw new InvalidArgumentError('%s is not a valid semver', v);
    });
    this.versions.sort();
  }
  util.inherits(Router, EventEmitter);
  module.exports = Router;
  Router.prototype.render = function render(routeName, params, query) {
    function pathItem(match, key) {
      if (params.hasOwnProperty(key) === false) {
        throw new Error('Route <' + routeName + '> is missing parameter <' + key + '>');
      }
      return ('/' + encodeURIComponent(params[key]));
    }
    function queryItem(key) {
      return (encodeURIComponent(key) + '=' + encodeURIComponent(query[key]));
    }
    var route = this.mounts[routeName];
    if (!route) {
      return (null);
    }
    var _path = route.spec.path;
    var _url = _path.replace(/\/:([A-Za-z0-9_]+)(\([^\\]+?\))?/g, pathItem);
    var items = Object.keys(query || {}).map(queryItem);
    var queryString = items.length > 0 ? ('?' + items.join('&')) : '';
    return (_url + queryString);
  };
  Router.prototype.mount = function mount(options) {
    assert.object(options, 'options');
    assert.string(options.method, 'options.method');
    assert.string(options.name, 'options.name');
    var exists;
    var name = options.name;
    var route;
    var routes = this.routes[options.method];
    var self = this;
    var type = options.contentType || self.contentType;
    var versions = options.versions || options.version || self.versions;
    if (type) {
      if (!Array.isArray(type)) {
        type = [type];
      }
      type.filter(function(t) {
        return (t);
      }).sort().join();
    }
    if (versions) {
      if (!Array.isArray(versions)) {
        versions = [versions];
      }
      versions.sort();
    }
    exists = routes.some(function(r) {
      return (r.name === name);
    });
    if (exists) {
      return (false);
    }
    route = {
      name: name,
      method: options.method,
      path: compileURL({
        url: options.path || options.url,
        flags: options.flags,
        urlParamPattern: options.urlParamPattern
      }),
      spec: options,
      types: type,
      versions: versions
    };
    routes.push(route);
    if (!this.reverse[route.path.source]) {
      this.reverse[route.path.source] = [];
    }
    if (this.reverse[route.path.source].indexOf(route.method) === -1) {
      this.reverse[route.path.source].push(route.method);
    }
    this.mounts[route.name] = route;
    this.emit('mount', route.method, route.path, route.types, route.versions);
    return (route.name);
  };
  Router.prototype.unmount = function unmount(name) {
    var route = this.mounts[name];
    if (!route) {
      this.log.warn('router.unmount(%s): route does not exist', name);
      return (false);
    }
    var reverse = this.reverse[route.path.source];
    var routes = this.routes[route.method];
    this.routes[route.method] = routes.filter(function(r) {
      return (r.name !== route.name);
    });
    this.reverse[route.path.source] = reverse.filter(function(r) {
      return (r !== route.method);
    });
    if (this.reverse[route.path.source].length === 0) {
      delete this.reverse[route.path.source];
    }
    delete this.mounts[name];
    return (name);
  };
  Router.prototype.get = function get(name, req, cb) {
    var params;
    var route = false;
    var routes = this.routes[req.method] || [];
    for (var i = 0; i < routes.length; i++) {
      if (routes[i].name === name) {
        route = routes[i];
        try {
          params = matchURL(route.path, req);
        } catch (e) {
          console.log(e);
        }
        break;
      }
    }
    if (route) {
      cb(null, route, params || {});
    } else {
      cb(new InternalError());
    }
  };
  Router.prototype.find = function find(req, res, callback) {
    var candidates = [];
    var ct = req.headers['content-type'] || DEF_CT;
    var cacheKey = req.method + req.url + req.version() + ct;
    var cacheVal;
    var neg;
    var params;
    var r;
    var reverse;
    var routes = this.routes[req.method] || [];
    var typed;
    var versioned;
    var maxV;
    if ((cacheVal = this.cache.get(cacheKey))) {
      res.methods = cacheVal.methods.slice();
      req._matchedVersion = cacheVal.matchedVersion;
      callback(null, cacheVal, shallowCopy(cacheVal.params));
      return;
    }
    for (var i = 0; i < routes.length; i++) {
      try {
        params = matchURL(routes[i].path, req);
      } catch (e) {
        this.log.trace({err: e}, 'error parsing URL');
        callback(new BadRequestError(e.message));
        return;
      }
      if (params === false) {
        continue;
      }
      reverse = this.reverse[routes[i].path.source];
      if (routes[i].types.length && req.isUpload()) {
        candidates.push({
          p: params,
          r: routes[i]
        });
        typed = true;
        continue;
      }
      if (routes[i].versions.length === 0 && req.version() === '*') {
        r = routes[i];
        break;
      }
      if (routes[i].versions.length > 0) {
        candidates.push({
          p: params,
          r: routes[i]
        });
        versioned = true;
      }
    }
    if (!r) {
      if (typed) {
        var _t = ct.split(/\s*,\s*/);
        candidates = candidates.filter(function(c) {
          neg = new Negotiator({headers: {accept: c.r.types.join(', ')}});
          var tmp = neg.preferredMediaType(_t);
          return (tmp && tmp.length);
        });
        if (candidates.length) {
          r = candidates[0].r;
          params = candidates[0].p;
        }
      }
      if (versioned) {
        candidates.forEach(function(c) {
          var k = c.r.versions;
          var v = semver.maxSatisfying(k, req.version());
          if (v) {
            if (!r || semver.gt(v, maxV)) {
              r = c.r;
              params = c.p;
              maxV = v;
            }
          }
        });
      }
    }
    if (params && r) {
      cacheVal = {
        methods: reverse,
        name: r.name,
        params: params,
        spec: r.spec
      };
      if (versioned) {
        req._matchedVersion = maxV;
        cacheVal.matchedVersion = maxV;
      }
      this.cache.set(cacheKey, cacheVal);
      res.methods = reverse.slice();
      callback(null, cacheVal, shallowCopy(params));
      return;
    }
    if (typed) {
      callback(new UnsupportedMediaTypeError(ct));
      return;
    }
    if (versioned) {
      callback(new InvalidVersionError('%s is not supported by %s %s', req.version() || '?', req.method, req.path()));
      return;
    }
    function inAllowedHeaders(header) {
      header = header.toLowerCase();
      return (cors.ALLOW_HEADERS.indexOf(header) !== -1);
    }
    function preflight(methods) {
      var headers = req.headers['access-control-request-headers'];
      var method = req.headers['access-control-request-method'];
      var origin = req.headers.origin;
      if (req.method !== 'OPTIONS' || !origin || !method || methods.indexOf(method) === -1) {
        return (false);
      }
      var ok = !headers || headers.split(/\s*,\s*/).every(inAllowedHeaders);
      if (!ok) {
        return (false);
      }
      if (cors.matchOrigin(req, cors.origins)) {
        res.setHeader('Access-Control-Allow-Origin', origin);
        if (cors.credentials) {
          res.setHeader('Access-Control-Allow-Credentials', 'true');
        }
      } else {
        res.setHeader('Access-Control-Allow-Origin', '*');
      }
      res.setHeader('Access-Control-Allow-Methods', methods.join(', '));
      res.setHeader('Access-Control-Allow-Headers', cors.ALLOW_HEADERS.join(', '));
      res.setHeader('Access-Control-Max-Age', 3600);
      return (true);
    }
    var j;
    var urls = Object.keys(this.reverse);
    for (j = 0; j < urls.length; j++) {
      if (matchURL(new RegExp(urls[j]), req)) {
        res.methods = this.reverse[urls[j]].slice();
        res.setHeader('Allow', res.methods.join(', '));
        if (preflight(res.methods)) {
          callback(null, {name: 'preflight'});
          return;
        }
        var err = new MethodNotAllowedError('%s is not allowed', req.method);
        callback(err);
        return;
      }
    }
    callback(new ResourceNotFoundError('%s does not exist', req.url));
  };
  Router.prototype.toString = function toString() {
    var self = this;
    var str = this.name + ':\n';
    Object.keys(this.routes).forEach(function(k) {
      var routes = self.routes[k].map(function(r) {
        return (r.name);
      });
      str += '\t\t' + k + ': [' + routes.join(', ') + ']\n';
    });
    return (str);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6b", ["1a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = (function() {
    var events = $__require('1a');
    var domain = {};
    domain.createDomain = domain.create = function() {
      var d = new events.EventEmitter();
      function emitError(e) {
        d.emit('error', e);
      }
      d.add = function(emitter) {
        emitter.on('error', emitError);
      };
      d.remove = function(emitter) {
        emitter.removeListener('error', emitError);
      };
      d.bind = function(fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          try {
            fn.apply(null, args);
          } catch (err) {
            emitError(err);
          }
        };
      };
      d.intercept = function(fn) {
        return function(err) {
          if (err) {
            emitError(err);
          } else {
            var args = Array.prototype.slice.call(arguments, 1);
            try {
              fn.apply(null, args);
            } catch (err) {
              emitError(err);
            }
          }
        };
      };
      d.run = function(fn) {
        try {
          fn();
        } catch (err) {
          emitError(err);
        }
        return this;
      };
      d.dispose = function() {
        this.removeAllListeners();
        return this;
      };
      d.enter = d.exit = function() {
        return this;
      };
      return d;
    };
    return domain;
  }).call(this);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6c", ["6b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('6b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6d", ["6c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('domain') : $__require('6c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6e", ["6d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('6d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6f", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function Queue() {
    this.head = new Item('head', null);
  }
  module.exports = Queue;
  Queue.prototype.append = function append(kind, value) {
    var item = new Item(kind, value);
    this.head.prepend(item);
    return item;
  };
  Queue.prototype.isEmpty = function isEmpty() {
    return this.head.prev === this.head;
  };
  Queue.prototype.first = function first() {
    return this.head.next;
  };
  function Item(kind, value) {
    this.prev = this;
    this.next = this;
    this.kind = kind;
    this.value = value;
  }
  Item.prototype.prepend = function prepend(other) {
    other.prev = this.prev;
    other.next = this;
    other.prev.next = other;
    other.next.prev = other;
  };
  Item.prototype.dequeue = function dequeue() {
    var prev = this.prev;
    var next = this.next;
    prev.next = next;
    next.prev = prev;
    this.prev = this;
    this.next = this;
    return this.value;
  };
  Item.prototype.isEmpty = function isEmpty() {
    return this.prev === this;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("70", ["71", "59", "1a", "72", "6f", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var assert = $__require('71');
    var util = $__require('59');
    var EventEmitter = $__require('1a').EventEmitter;
    var Buffer = $__require('72').Buffer;
    var Queue = $__require('6f');
    var mode = /^v0\.8\./.test(process.version) ? 'rusty' : /^v0\.(9|10)\./.test(process.version) ? 'old' : 'modern';
    function Handle(stream, options) {
      EventEmitter.call(this);
      this._stream = stream;
      this._flowing = false;
      this._reading = false;
      this._options = options || {};
      this.onread = null;
      this.pending = new Queue();
      if (mode === 'rusty') {
        var self = this;
        Object.defineProperty(this, 'onread', {set: function(value) {
            Object.defineProperty(self, 'onread', {value: value});
            process.nextTick(function() {
              self.readStart();
            });
          }});
      }
      if (mode === 'rusty')
        this.writeQueueSize = 0;
      else if (mode !== 'modern')
        this.writeQueueSize = 1;
      if (mode === 'rusty') {
        if (this._stream)
          this._rustyInit();
        else
          this.once('stream', this._rustyInit);
      }
    }
    util.inherits(Handle, EventEmitter);
    module.exports = Handle;
    Handle.mode = mode;
    Handle.create = function create(stream, options) {
      return new Handle(stream, options);
    };
    Handle.prototype._queueReq = function _queueReq(type, req) {
      return this.pending.append(type, req);
    };
    Handle.prototype._pendingList = function _pendingList() {
      var list = [];
      while (!this.pending.isEmpty())
        list.push(this.pending.first().dequeue());
      return list;
    };
    Handle.prototype.setStream = function setStream(stream) {
      assert(this._stream === null, 'Can\'t set stream two times');
      this._stream = stream;
      this.emit('stream', stream);
    };
    Handle.prototype.readStart = function readStart() {
      this._reading = true;
      if (!this._stream) {
        this.once('stream', this.readStart);
        return 0;
      }
      if (!this._flowing) {
        this._flowing = true;
        this._flow();
      }
      this._stream.resume();
      return 0;
    };
    Handle.prototype.readStop = function readStop() {
      this._reading = false;
      if (!this._stream) {
        this.once('stream', this.readStop);
        return 0;
      }
      this._stream.pause();
      return 0;
    };
    if (mode === 'modern') {
      var uv = process.binding('uv');
      Handle.prototype._flow = function flow() {
        var self = this;
        this._stream.on('data', function(chunk) {
          self.onread(chunk.length, chunk);
        });
        this._stream.on('end', function() {
          self.onread(uv.UV_EOF, new Buffer(0));
        });
        this._stream.on('close', function() {
          setImmediate(function() {
            if (self._reading)
              self.onread(uv.UV_ECONNRESET, new Buffer(0));
          });
        });
      };
      Handle.prototype._close = function _close() {
        var list = this._pendingList();
        var self = this;
        setImmediate(function() {
          for (var i = 0; i < list.length; i++) {
            var req = list[i];
            req.oncomplete(uv.UV_ECANCELED, self, req);
          }
        });
        this.readStop();
      };
    } else if (mode === 'old') {
      Handle.prototype._flow = function flow() {
        var self = this;
        this._stream.on('data', function(chunk) {
          self.onread(chunk, 0, chunk.length);
        });
        this._stream.on('end', function() {
          var errno = process._errno;
          process._errno = 'EOF';
          self.onread(null, 0, 0);
          if (process._errno === 'EOF')
            process._errno = errno;
        });
        this._stream.on('close', function() {
          setImmediate(function() {
            if (!self._reading)
              return;
            var errno = process._errno;
            process._errno = 'ECONNRESET';
            self.onread(null, 0, 0);
            if (process._errno === 'ECONNRESET')
              process._errno = errno;
          });
        });
      };
      Handle.prototype._close = function _close() {
        var list = this._pendingList();
        var self = this;
        setImmediate(function() {
          for (var i = 0; i < list.length; i++) {
            process._errno = 'CANCELED';
            var req = list[i];
            req.oncomplete(-1, self, req);
          }
        });
        this.readStop();
      };
    } else {
      Handle.prototype._rustyInit = function _rustyInit() {
        var self = this;
        this._stream.on('close', function() {
          process.nextTick(function() {
            if (!self._reading)
              return;
            var errno = global.errno;
            global.errno = 'ECONNRESET';
            self.onread(null, 0, 0);
            if (global.errno === 'ECONNRESET')
              global.errno = errno;
          });
        });
      };
      Handle.prototype._flow = function flow() {
        var self = this;
        this._stream.on('data', function(chunk) {
          self.onread(chunk, 0, chunk.length);
        });
        this._stream.on('end', function() {
          var errno = global.errno;
          global.errno = 'EOF';
          self.onread(null, 0, 0);
          if (global.errno === 'EOF')
            global.errno = errno;
        });
      };
      Handle.prototype._close = function _close() {
        var list = this._pendingList();
        var self = this;
        process.nextTick(function() {
          for (var i = 0; i < list.length; i++) {
            var req = list[i];
            global.errno = 'CANCELED';
            req.oncomplete(-1, self, req);
          }
        });
        this.readStop();
      };
    }
    if (mode === 'modern') {
      Handle.prototype.shutdown = function shutdown(req) {
        var wrap = this._queueReq('shutdown', req);
        if (!this._stream) {
          this.once('stream', function() {
            this._shutdown(wrap);
          });
          return 0;
        }
        return this._shutdown(wrap);
      };
      Handle.prototype._shutdown = function _shutdown(wrap) {
        var self = this;
        this._stream.end(function() {
          var req = wrap.dequeue();
          if (!req)
            return;
          req.oncomplete(0, self, req);
        });
        return 0;
      };
    } else {
      Handle.prototype.shutdown = function shutdown(req) {
        if (!req)
          req = {};
        var wrap = this._queueReq('shutdown', req);
        if (!this._stream) {
          this.once('stream', function() {
            this._shutdown(wrap);
          });
          return req;
        }
        this._shutdown(wrap);
        return req;
      };
      Handle.prototype._shutdown = function _shutdown(wrap) {
        var self = this;
        this._stream.end(function() {
          var req = wrap.dequeue();
          if (!req)
            return;
          req.oncomplete(0, self, req);
        });
      };
    }
    if (mode !== 'rusty') {
      Handle.prototype.close = function close(callback) {
        this._close();
        if (!this._stream) {
          this.once('stream', function() {
            this.close(callback);
          });
          return 0;
        }
        if (this._options.close)
          this._options.close(callback);
        else
          process.nextTick(callback);
        return 0;
      };
    } else {
      Handle.prototype.close = function close() {
        this._close();
        if (!this._stream)
          this.once('stream', this.close);
        else if (this._options.close)
          this._options.close(function() {});
        return 0;
      };
    }
    if (mode === 'modern') {
      Handle.prototype.writeEnc = function writeEnc(req, data, enc) {
        var wrap = this._queueReq('write', req);
        if (!this._stream) {
          this.once('stream', function() {
            this._writeEnc(wrap, req, data, enc);
          });
          return 0;
        }
        return this._writeEnc(wrap, req, data, enc);
      };
      Handle.prototype._writeEnc = function _writeEnc(wrap, req, data, enc) {
        var self = this;
        req.async = true;
        req.bytes = data.length;
        if (wrap.isEmpty())
          return 0;
        this._stream.write(data, enc, function() {
          var req = wrap.dequeue();
          if (!req)
            return;
          req.oncomplete(0, self, req);
        });
        return 0;
      };
    } else {
      Handle.prototype.writeEnc = function writeEnc(data, ignored, enc, req) {
        if (!req)
          req = {bytes: data.length};
        var wrap = this._queueReq('write', req);
        if (!this._stream) {
          this.once('stream', function() {
            this._writeEnc(data, ignored, enc, wrap);
          });
          return req;
        }
        this._writeEnc(data, ignored, enc, wrap);
        return req;
      };
      Handle.prototype._writeEnc = function _writeEnc(data, ignored, enc, wrap) {
        var self = this;
        var buffer = new Buffer(data, enc);
        if (wrap.isEmpty())
          return;
        this._stream.write(buffer, function() {
          var req = wrap.dequeue();
          if (!req)
            return;
          req.oncomplete(0, self, req);
        });
      };
    }
    Handle.prototype.writeBuffer = function writeBuffer(req, data) {
      return this.writeEnc(req, data, null);
    };
    Handle.prototype.writeAsciiString = function writeAsciiString(req, data) {
      return this.writeEnc(req, data, 'ascii');
    };
    Handle.prototype.writeUtf8String = function writeUtf8String(req, data) {
      return this.writeEnc(req, data, 'utf8');
    };
    Handle.prototype.writeUcs2String = function writeUcs2String(req, data) {
      return this.writeEnc(req, data, 'ucs2');
    };
    Handle.prototype.writeBinaryString = function writeBinaryString(req, data) {
      return this.writeEnc(req, data, 'binary');
    };
    Handle.prototype.getsockname = function getsockname() {
      if (this._options.getPeerName)
        return this._options.getPeerName();
      return null;
    };
    if (mode === 'modern') {
      Handle.prototype.getpeername = function getpeername(out) {
        var res = this.getsockname();
        if (!res)
          return -1;
        Object.keys(res).forEach(function(key) {
          out[key] = res[key];
        });
        return 0;
      };
    } else {
      Handle.prototype.getpeername = function getpeername() {
        return this.getsockname();
      };
    }
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("73", ["70"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('70');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("74", ["71", "59", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var assert = $__require('71');
    var util = $__require('59');
    var Buffer = $__require('72').Buffer;
    var mode = /^v0\.8\./.test(process.version) ? 'rusty' : /^v0\.(9|10)\./.test(process.version) ? 'old' : /^v0\.12\./.test(process.version) ? 'normal' : 'modern';
    var HTTPParser;
    var reverseMethods;
    var kOnHeaders;
    var kOnHeadersComplete;
    var kOnMessageComplete;
    var kOnBody;
    if (mode === 'normal' || mode === 'modern') {
      HTTPParser = process.binding('http_parser').HTTPParser;
      reverseMethods = {};
      HTTPParser.methods.forEach(function(method, index) {
        reverseMethods[method] = index;
      });
      kOnHeaders = HTTPParser.kOnHeaders | 0;
      kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;
      kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;
      kOnBody = HTTPParser.kOnBody | 0;
    } else {
      kOnHeaders = 'onHeaders';
      kOnHeadersComplete = 'onHeadersComplete';
      kOnMessageComplete = 'onMessageComplete';
      kOnBody = 'onBody';
    }
    function Deceiver(socket, options) {
      this.socket = socket;
      this.options = options || {};
      this.isClient = this.options.isClient;
    }
    module.exports = Deceiver;
    Deceiver.create = function create(stream, options) {
      return new Deceiver(stream, options);
    };
    Deceiver.prototype._toHeaderList = function _toHeaderList(object) {
      var out = [];
      var keys = Object.keys(object);
      for (var i = 0; i < keys.length; i++)
        out.push(keys[i], object[keys[i]]);
      return out;
    };
    Deceiver.prototype._isUpgrade = function _isUpgrade(request) {
      return request.method === 'CONNECT' || request.headers.upgrade || request.headers.connection && /(^|\W)upgrade(\W|$)/i.test(request.headers.connection);
    };
    if (mode === 'modern') {
      Deceiver.prototype.emitRequest = function emitRequest(request) {
        var parser = this.socket.parser;
        assert(parser, 'No parser present');
        var self = this;
        var method = reverseMethods[request.method];
        parser.execute = function execute() {
          self._skipExecute(this);
          this[kOnHeadersComplete](1, 1, self._toHeaderList(request.headers), method, request.path, 0, '', self._isUpgrade(request), true);
          return 0;
        };
        this._emitEmpty();
      };
      Deceiver.prototype.emitResponse = function emitResponse(response) {
        var parser = this.socket.parser;
        assert(parser, 'No parser present');
        var self = this;
        parser.execute = function execute() {
          self._skipExecute(this);
          this[kOnHeadersComplete](1, 1, self._toHeaderList(response.headers), response.path, response.code, response.status, response.reason || '', self._isUpgrade(response), true);
          return 0;
        };
        this._emitEmpty();
      };
    } else {
      Deceiver.prototype.emitRequest = function emitRequest(request) {
        var parser = this.socket.parser;
        assert(parser, 'No parser present');
        var method = request.method;
        if (reverseMethods)
          method = reverseMethods[method];
        var info = {
          versionMajor: 1,
          versionMinor: 1,
          url: request.path,
          headers: this._toHeaderList(request.headers),
          method: method,
          statusCode: 0,
          statusMessage: '',
          upgrade: this._isUpgrade(request),
          shouldKeepAlive: true
        };
        var self = this;
        parser.execute = function execute() {
          self._skipExecute(this);
          this[kOnHeadersComplete](info);
          return 0;
        };
        this._emitEmpty();
      };
      Deceiver.prototype.emitResponse = function emitResponse(response) {
        var parser = this.socket.parser;
        assert(parser, 'No parser present');
        var info = {
          versionMajor: 1,
          versionMinor: 1,
          url: response.path,
          headers: this._toHeaderList(response.headers),
          method: false,
          statusCode: response.status,
          statusMessage: response.reason || '',
          upgrade: this._isUpgrade(response),
          shouldKeepAlive: true
        };
        var self = this;
        parser.execute = function execute() {
          self._skipExecute(this);
          this[kOnHeadersComplete](info);
          return 0;
        };
        this._emitEmpty();
      };
    }
    Deceiver.prototype._skipExecute = function _skipExecute(parser) {
      var self = this;
      var oldExecute = parser.constructor.prototype.execute;
      var oldFinish = parser.constructor.prototype.finish;
      parser.execute = function execute(buffer, start, len) {
        if (this.socket !== self.socket) {
          this.execute = oldExecute;
          this.finish = oldFinish;
          return this.execute(buffer, start, len);
        }
        if (start !== undefined)
          buffer = buffer.slice(start, start + len);
        self.emitBody(buffer);
        return len;
      };
      parser.finish = function finish() {
        if (this.socket !== self.socket) {
          this.execute = oldExecute;
          this.finish = oldFinish;
          return this.finish();
        }
        this.execute = oldExecute;
        this.finish = oldFinish;
        self.emitMessageComplete();
      };
    };
    Deceiver.prototype.emitBody = function emitBody(buffer) {
      var parser = this.socket.parser;
      assert(parser, 'No parser present');
      parser[kOnBody](buffer, 0, buffer.length);
    };
    Deceiver.prototype._emitEmpty = function _emitEmpty() {
      var empty = new Buffer(0);
      if (this.socket.ondata)
        this.socket.ondata(empty, 0, 0);
      else
        this.socket.emit('data', empty);
    };
    Deceiver.prototype.emitMessageComplete = function emitMessageComplete() {
      var parser = this.socket.parser;
      assert(parser, 'No parser present');
      parser[kOnMessageComplete]();
    };
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("75", ["74"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('74');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("76", ["71", "73", "75", "59", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var assert = $__require('71');
    var thing = $__require('73');
    var httpDeceiver = $__require('75');
    var util = $__require('59');
    function Handle(options, stream, socket) {
      var state = {};
      this._spdyState = state;
      state.options = options || {};
      state.stream = stream;
      state.socket = null;
      state.rawSocket = socket || stream.connection.socket;
      state.deceiver = null;
      state.ending = false;
      var self = this;
      thing.call(this, stream, {
        getPeerName: function() {
          return self._getPeerName();
        },
        close: function(callback) {
          return self._closeCallback(callback);
        }
      });
      if (!state.stream) {
        this.on('stream', function(stream) {
          state.stream = stream;
        });
      }
    }
    util.inherits(Handle, thing);
    module.exports = Handle;
    Handle.create = function create(options, stream, socket) {
      return new Handle(options, stream, socket);
    };
    Handle.prototype._getPeerName = function _getPeerName() {
      var state = this._spdyState;
      if (state.rawSocket._getpeername)
        return state.rawSocket._getpeername();
      return null;
    };
    Handle.prototype._closeCallback = function _closeCallback(callback) {
      var state = this._spdyState;
      if (state.ending)
        state.stream.end(callback);
      else
        state.stream.abort(callback);
      state.ending = false;
    };
    Handle.prototype.getStream = function getStream(callback) {
      var state = this._spdyState;
      if (!callback) {
        assert(state.stream);
        return state.stream;
      }
      if (state.stream) {
        process.nextTick(function() {
          callback(state.stream);
        });
        return;
      }
      this.on('stream', callback);
    };
    Handle.prototype.assignSocket = function assignSocket(socket, options) {
      var state = this._spdyState;
      state.socket = socket;
      state.deceiver = httpDeceiver.create(socket, options);
      function onStreamError(err) {
        state.socket.emit('error', err);
      }
      this.getStream(function(stream) {
        stream.on('error', onStreamError);
      });
    };
    Handle.prototype.assignClientRequest = function assignClientRequest(req) {
      var state = this._spdyState;
      var oldEnd = req.end;
      var oldSend = req._send;
      var self = this;
      if (thing.mode !== 'modern') {
        req.end = function end() {
          this.end = oldEnd;
          this._send('');
          return this.end.apply(this, arguments);
        };
      }
      req._send = function send(data) {
        this._headerSent = true;
        this._header = 'ignore me';
        this.connection = state.socket;
        self.getStream(function(stream) {
          stream.send();
        });
        self.emit('needStream');
        req._send = oldSend;
        if (req.method === 'GET' && data.length === 0)
          return;
        return req._send.apply(this, arguments);
      };
      req.useChunkedEncodingByDefault = false;
      req.on('finish', function() {
        req.socket.end();
      });
    };
    Handle.prototype.assignRequest = function assignRequest(req) {
      this.getStream(function(stream) {
        stream.on('headers', function(headers) {
          req.emit('trailers', headers);
        });
      });
    };
    Handle.prototype.assignResponse = function assignResponse(res) {
      var self = this;
      res.addTrailers = function addTrailers(headers) {
        self.getStream(function(stream) {
          stream.sendHeaders(headers);
        });
      };
    };
    Handle.prototype._transformHeaders = function _transformHeaders(kind, headers) {
      var state = this._spdyState;
      var res = {};
      var keys = Object.keys(headers);
      if (kind === 'request' && state.options['x-forwarded-for']) {
        var xforwarded = state.stream.connection.getXForwardedFor();
        if (xforwarded !== null)
          res['x-forwarded-for'] = xforwarded;
      }
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = headers[key];
        if (key === ':authority')
          res.host = value;
        if (/^:/.test(key))
          continue;
        res[key] = value;
      }
      return res;
    };
    Handle.prototype.emitRequest = function emitRequest() {
      var state = this._spdyState;
      var stream = state.stream;
      state.deceiver.emitRequest({
        method: stream.method,
        path: stream.path,
        headers: this._transformHeaders('request', stream.headers)
      });
    };
    Handle.prototype.emitResponse = function emitResponse(status, headers) {
      var state = this._spdyState;
      state.deceiver.emitResponse({
        status: status,
        headers: this._transformHeaders('response', headers)
      });
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("77", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function attachPush(req) {
    var handle = req.socket._handle;
    handle.getStream(function(stream) {
      stream.on('pushPromise', function(push) {
        req.emit('push', push);
      });
    });
  }
  exports.onNewListener = function onNewListener(type) {
    var req = this;
    if (type !== 'push')
      return;
    if (req.listeners('push').length !== 0)
      return;
    if (!req.socket) {
      req.on('socket', function() {
        attachPush(req);
      });
      return;
    }
    attachPush(req);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("78", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.writeHead = function writeHead(statusCode, reason, obj) {
    var headers;
    if (typeof reason === 'string') {
      this.statusMessage = reason;
    } else {
      this.statusMessage = this.statusMessage || 'unknown';
      obj = reason;
    }
    this.statusCode = statusCode;
    if (this._headers) {
      if (obj) {
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (k)
            this.setHeader(k, obj[k]);
        }
      }
      headers = this._renderHeaders();
    } else {
      headers = obj;
    }
    if (statusCode === 204 || statusCode === 304 || (100 <= statusCode && statusCode <= 199)) {
      this._hasBody = false;
    }
    if (this._expect_continue && !this._sent100) {
      this.shouldKeepAlive = false;
    }
    this._header = true;
    this._headerSent = true;
    if (this.socket._handle)
      this.socket._handle._spdyState.stream.respond(this.statusCode, headers);
  };
  exports.end = function end(data, encoding, callback) {
    if (!this._headerSent)
      this.writeHead(this.statusCode);
    if (!this.socket._handle)
      return;
    var self = this;
    var handle = this.socket._handle;
    handle._spdyState.ending = true;
    this.socket.end(data, encoding, function() {
      self.constructor.prototype.end.call(self, '', 'utf8', callback);
    });
  };
  exports.push = function push(path, headers, callback) {
    var frame = {
      path: path,
      method: 'GET',
      status: 200,
      host: this.socket.parser.incoming.headers.host,
      headers: headers.request,
      response: headers.response
    };
    var stream = this.socket._handle._spdyState.stream;
    return stream.pushPromise(frame, callback);
  };
  exports.writeContinue = function writeContinue(callback) {
    if (this.socket._handle)
      this.socket._handle._spdyState.stream.respond(100, {}, callback);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("79", ["59", "7a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var util = $__require('59');
  var net = $__require('7a');
  function Socket(parent, options) {
    net.Socket.call(this, options);
    var state = {};
    this._spdyState = state;
    state.parent = parent;
    this.servername = parent.servername;
    this.npnProtocol = parent.npnProtocol;
    this.alpnProtocol = parent.alpnProtocol;
    this.authorized = parent.authorized;
    this.authorizationError = parent.authorizationError;
    this.encrypted = true;
  }
  util.inherits(Socket, net.Socket);
  module.exports = Socket;
  var methods = ['renegotiate', 'setMaxSendFragment', 'getTLSTicket', 'setServername', 'setSession', 'getPeerCertificate', 'getSession', 'isSessionReused', 'getCipher', 'getEphemeralKeyInfo'];
  methods.forEach(function(method) {
    Socket.prototype[method] = function methodWrap() {
      var parent = this._spdyState.parent;
      return parent[method].apply(parent, arguments);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7b", ["71", "7d", "7e", "7a", "59", "7f", "80", "1a", "7c", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var assert = $__require('71');
    var http = $__require('7d');
    var https = $__require('7e');
    var net = $__require('7a');
    var util = $__require('59');
    var transport = $__require('7f');
    var debug = $__require('80')('spdy:client');
    var EventEmitter = $__require('1a').EventEmitter;
    var spdy = $__require('7c');
    var mode = /^v0\.8\./.test(process.version) ? 'rusty' : /^v0\.(9|10)\./.test(process.version) ? 'old' : /^v0\.12\./.test(process.version) ? 'normal' : 'modern';
    var proto = {};
    function instantiate(base) {
      function Agent(options) {
        this._init(base, options);
      }
      util.inherits(Agent, base);
      Agent.create = function create(options) {
        return new Agent(options);
      };
      Object.keys(proto).forEach(function(key) {
        Agent.prototype[key] = proto[key];
      });
      return Agent;
    }
    proto._init = function _init(base, options) {
      base.call(this, options);
      var state = {};
      this._spdyState = state;
      state.host = options.host;
      state.options = options.spdy || {};
      state.secure = this instanceof https.Agent;
      state.fallback = false;
      state.createSocket = this._getCreateSocket();
      state.socket = null;
      state.connection = null;
      this.keepAlive = false;
      var self = this;
      this._connect(options, function(err, connection) {
        if (err)
          return self.emit('error', err);
        state.connection = connection;
        self.emit('_connect');
      });
    };
    proto._getCreateSocket = function _getCreateSocket() {
      var createSocket;
      var cons = this.constructor.super_;
      do {
        createSocket = cons.prototype.createSocket;
        if (cons.super_ === EventEmitter || !cons.super_)
          break;
        cons = cons.super_;
      } while (!createSocket);
      if (!createSocket)
        createSocket = http.Agent.prototype.createSocket;
      assert(createSocket, '.createSocket() method not found');
      return createSocket;
    };
    proto._connect = function _connect(options, callback) {
      var state = this._spdyState;
      var protocols = state.options.protocols || ['h2', 'spdy/3.1', 'spdy/3', 'spdy/2', 'http/1.1', 'http/1.0'];
      var socket = this.createConnection(util._extend({
        NPNProtocols: protocols,
        ALPNProtocols: protocols
      }, options));
      state.socket = socket;
      socket.setNoDelay(true);
      function onError(err) {
        return callback(err);
      }
      socket.on('error', onError);
      socket.on(state.secure ? 'secureConnect' : 'connect', function() {
        socket.removeListener('error', onError);
        var protocol;
        if (state.secure)
          protocol = socket.npnProtocol || socket.alpnProtocol;
        else
          protocol = state.options.protocol;
        if (!protocol || protocol === 'http/1.1' || protocol === 'http/1.0') {
          debug('activating fallback');
          socket.destroy();
          state.fallback = true;
          return;
        }
        debug('connected protocol=%j', protocol);
        var connection = transport.connection.create(socket, util._extend({
          protocol: /spdy/.test(protocol) ? 'spdy' : 'http2',
          isServer: false
        }, state.options.connection || {}));
        if (protocol === 'h2') {
          connection.start(4);
        } else if (protocol === 'spdy/3.1') {
          connection.start(3.1);
        } else if (protocol === 'spdy/3') {
          connection.start(3);
        } else if (protocol === 'spdy/2') {
          connection.start(2);
        } else {
          socket.destroy();
          callback(new Error('Unexpected protocol: ' + protocol));
          return;
        }
        if (state.options['x-forwarded-for'] !== undefined)
          connection.sendXForwardedFor(state.options['x-forwarded-for']);
        callback(null, connection);
      });
    };
    proto._createSocket = function _createSocket(req, options, callback) {
      var state = this._spdyState;
      if (state.fallback)
        return state.createSocket(req, options);
      var handle = spdy.handle.create(null, null, state.socket);
      var socketOptions = {
        handle: handle,
        allowHalfOpen: true
      };
      var socket;
      if (state.secure)
        socket = new spdy.Socket(state.socket, socketOptions);
      else
        socket = new net.Socket(socketOptions);
      handle.assignSocket(socket);
      handle.assignClientRequest(req);
      var self = this;
      handle.once('needStream', function() {
        if (state.connection === null) {
          self.once('_connect', function() {
            handle.setStream(self._createStream(req, handle));
          });
        } else {
          handle.setStream(self._createStream(req, handle));
        }
      });
      req.on('response', function(res) {
        handle.assignRequest(res);
      });
      handle.assignResponse(req);
      req.addListener('newListener', spdy.request.onNewListener);
      socket.readable = true;
      socket.writable = true;
      if (callback)
        return callback(null, socket);
      return socket;
    };
    if (mode === 'modern' || mode === 'normal') {
      proto.createSocket = proto._createSocket;
    } else {
      proto.createSocket = function createSocket(name, host, port, addr, req) {
        var state = this._spdyState;
        if (state.fallback)
          return state.createSocket(name, host, port, addr, req);
        return this._createSocket(req, {
          host: host,
          port: port
        });
      };
    }
    proto._createStream = function _createStream(req, handle) {
      var state = this._spdyState;
      var self = this;
      return state.connection.reserveStream({
        method: req.method,
        path: req.path,
        headers: req._headers,
        host: state.host
      }, function(err, stream) {
        if (err)
          return self.emit('error', err);
        stream.on('response', function(status, headers) {
          handle.emitResponse(status, headers);
        });
      });
    };
    proto.close = function close(callback) {
      var state = this._spdyState;
      if (state.connection === null) {
        this.once('_connect', function() {
          this.close(callback);
        });
        return;
      }
      state.connection.end(callback);
    };
    exports.Agent = instantiate(https.Agent);
    exports.PlainAgent = instantiate(http.Agent);
    exports.create = function create(base, options) {
      if (typeof base === 'object') {
        options = base;
        base = null;
      }
      if (base)
        return instantiate(base).create(options);
      if (options.spdy && options.spdy.plain)
        return exports.PlainAgent.create(options);
      else
        return exports.Agent.create(options);
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("81", ["7d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var http = $__require('7d');
  var https = module.exports;
  for (var key in http) {
    if (http.hasOwnProperty(key))
      https[key] = http[key];
  }
  ;
  https.request = function(params, cb) {
    if (!params)
      params = {};
    params.scheme = 'https';
    return http.request.call(this, params, cb);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("82", ["81"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('81');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("83", ["82"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('https') : $__require('82');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7e", ["83"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('83');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("84", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if ($__System._nodeRequire)
    module.exports = $__System._nodeRequire('tls');
  else
    throw "Node tls module not supported in browsers.";
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("85", ["84"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('84');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("86", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("87", ["86"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('86');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("88", ["86", "87"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var nextTick = $__require('86').nextTick;
    var apply = Function.prototype.apply;
    var slice = Array.prototype.slice;
    var immediateIds = {};
    var nextImmediateId = 0;
    exports.setTimeout = function() {
      return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
    };
    exports.setInterval = function() {
      return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
    };
    exports.clearTimeout = exports.clearInterval = function(timeout) {
      timeout.close();
    };
    function Timeout(id, clearFn) {
      this._id = id;
      this._clearFn = clearFn;
    }
    Timeout.prototype.unref = Timeout.prototype.ref = function() {};
    Timeout.prototype.close = function() {
      this._clearFn.call(window, this._id);
    };
    exports.enroll = function(item, msecs) {
      clearTimeout(item._idleTimeoutId);
      item._idleTimeout = msecs;
    };
    exports.unenroll = function(item) {
      clearTimeout(item._idleTimeoutId);
      item._idleTimeout = -1;
    };
    exports._unrefActive = exports.active = function(item) {
      clearTimeout(item._idleTimeoutId);
      var msecs = item._idleTimeout;
      if (msecs >= 0) {
        item._idleTimeoutId = setTimeout(function onTimeout() {
          if (item._onTimeout)
            item._onTimeout();
        }, msecs);
      }
    };
    exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
      var id = nextImmediateId++;
      var args = arguments.length < 2 ? false : slice.call(arguments, 1);
      immediateIds[id] = true;
      nextTick(function onNextTick() {
        if (immediateIds[id]) {
          if (args) {
            fn.apply(null, args);
          } else {
            fn.call(null);
          }
          exports.clearImmediate(id);
        }
      });
      return id;
    };
    exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
      delete immediateIds[id];
    };
  })($__require('87'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("89", ["88"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('88');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8a", ["89"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('timers') : $__require('89');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8b", ["8a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8c", ["58", "59", "8b", "7d", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    if ($__System._nodeRequire) {
      module.exports = $__System._nodeRequire('net');
    } else {
      var stream = $__require('58');
      var util = $__require('59');
      var timers = $__require('8b');
      var http = $__require('7d');
      var debug = util.debuglog('net');
      var proxy = {
        hostname: window.location.hostname,
        port: window.location.port
      };
      function getProxy() {
        return proxy;
      }
      function getProxyHost() {
        var host = getProxy().hostname;
        if (getProxy().port) {
          host += ':' + getProxy().port;
        }
        return host;
      }
      exports.setProxy = function(options) {
        options = options || {};
        proxy.hostname = options.hostname;
        proxy.port = options.port;
      };
      exports.createServer = function() {
        throw new Error('Cannot create server in a browser');
      };
      exports.connect = exports.createConnection = function() {
        var args = normalizeConnectArgs(arguments);
        debug('createConnection', args);
        var s = new Socket(args[0]);
        return Socket.prototype.connect.apply(s, args);
      };
      function toNumber(x) {
        return (x = Number(x)) >= 0 ? x : false;
      }
      function isPipeName(s) {
        return util.isString(s) && toNumber(s) === false;
      }
      function normalizeConnectArgs(args) {
        var options = {};
        if (util.isObject(args[0])) {
          options = args[0];
        } else if (isPipeName(args[0])) {
          options.path = args[0];
        } else {
          options.port = args[0];
          if (util.isString(args[1])) {
            options.host = args[1];
          }
        }
        var cb = args[args.length - 1];
        return util.isFunction(cb) ? [options, cb] : [options];
      }
      exports._normalizeConnectArgs = normalizeConnectArgs;
      function Socket(options) {
        if (!(this instanceof Socket))
          return new Socket(options);
        this._connecting = false;
        this._host = null;
        if (util.isNumber(options))
          options = {fd: options};
        else if (util.isUndefined(options))
          options = {};
        stream.Duplex.call(this, options);
        this.readable = this.writable = false;
        this._writableState.decodeStrings = false;
        this.allowHalfOpen = options && options.allowHalfOpen || false;
      }
      util.inherits(Socket, stream.Duplex);
      exports.Socket = Socket;
      exports.Stream = Socket;
      Socket.prototype.listen = function() {
        throw new Error('Cannot listen in a browser');
      };
      Socket.prototype.setTimeout = function(msecs, callback) {
        if (msecs > 0 && isFinite(msecs)) {
          timers.enroll(this, msecs);
          if (callback) {
            this.once('timeout', callback);
          }
        } else if (msecs === 0) {
          timers.unenroll(this);
          if (callback) {
            this.removeListener('timeout', callback);
          }
        }
      };
      Socket.prototype._onTimeout = function() {
        debug('_onTimeout');
        this.emit('timeout');
      };
      Socket.prototype.setNoDelay = function(enable) {};
      Socket.prototype.setKeepAlive = function(setting, msecs) {};
      Socket.prototype.address = function() {
        return {
          address: this.remoteAddress,
          port: this.remotePort,
          family: this.remoteFamily
        };
      };
      Object.defineProperty(Socket.prototype, 'readyState', {get: function() {
          if (this._connecting) {
            return 'opening';
          } else if (this.readable && this.writable) {
            return 'open';
          } else if (this.readable && !this.writable) {
            return 'readOnly';
          } else if (!this.readable && this.writable) {
            return 'writeOnly';
          } else {
            return 'closed';
          }
        }});
      Socket.prototype.bufferSize = undefined;
      Socket.prototype._read = function() {};
      Socket.prototype.end = function(data, encoding) {
        stream.Duplex.prototype.end.call(this, data, encoding);
        this.writable = false;
        if (this._ws) {
          this._ws.close();
        }
        if (this.readable && !this._readableState.endEmitted)
          this.read(0);
        else
          maybeDestroy(this);
      };
      function maybeDestroy(socket) {
        if (!socket.readable && !socket.writable && !socket.destroyed && !socket._connecting && !socket._writableState.length) {
          socket.destroy();
        }
      }
      Socket.prototype.destroySoon = function() {
        if (this.writable)
          this.end();
        if (this._writableState.finished)
          this.destroy();
        else
          this.once('finish', this.destroy);
      };
      Socket.prototype.destroy = function(exception) {
        debug('destroy', exception);
        if (this.destroyed) {
          return;
        }
        self._connecting = false;
        this.readable = this.writable = false;
        timers.unenroll(this);
        debug('close');
        this.destroyed = true;
      };
      Socket.prototype.remoteAddress = null;
      Socket.prototype.remoteFamily = null;
      Socket.prototype.remotePort = null;
      Socket.prototype.localAddress = null;
      Socket.prototype.localPort = null;
      Socket.prototype.bytesRead = 0;
      Socket.prototype.bytesWritten = 0;
      Socket.prototype._write = function(data, encoding, cb) {
        var self = this;
        cb = cb || function() {};
        if (this._connecting) {
          this._pendingData = data;
          this._pendingEncoding = encoding;
          this.once('connect', function() {
            this._write(data, encoding, cb);
          });
          return;
        }
        this._pendingData = null;
        this._pendingEncoding = '';
        if (encoding == 'binary' && typeof data == 'string') {
          data = new Buffer(data, encoding);
        }
        this._ws.send(data);
        process.nextTick(function() {
          self.bytesWritten += data.length;
          cb();
        });
      };
      Socket.prototype.write = function(chunk, encoding, cb) {
        if (!util.isString(chunk) && !util.isBuffer(chunk))
          throw new TypeError('invalid data');
        return stream.Duplex.prototype.write.apply(this, arguments);
      };
      Socket.prototype.connect = function(options, cb) {
        var self = this;
        if (!util.isObject(options)) {
          var args = normalizeConnectArgs(arguments);
          return Socket.prototype.connect.apply(this, args);
        }
        cb = cb || function() {};
        if (this.write !== Socket.prototype.write)
          this.write = Socket.prototype.write;
        if (options.path) {
          throw new Error('options.path not supported in the browser');
        }
        self._connecting = true;
        self.writable = true;
        self._host = options.host;
        var req = http.request({
          hostname: getProxy().hostname,
          port: getProxy().port,
          path: '/api/vm/net/connect',
          method: 'POST'
        }, function(res) {
          var json = '';
          res.on('data', function(buf) {
            json += buf;
          });
          res.on('end', function() {
            var data = null;
            try {
              data = JSON.parse(json);
            } catch (e) {
              data = {
                code: res.statusCode,
                error: json
              };
            }
            if (data.error) {
              self.emit('error', 'Cannot open TCP connection [' + res.statusCode + ']: ' + data.error);
              self.destroy();
              return;
            }
            self.remoteAddress = data.remote.address;
            self.remoteFamily = data.remote.family;
            self.remotePort = data.remote.port;
            self._connectWebSocket(data.token, function(err) {
              if (err) {
                cb(err);
                return;
              }
              cb();
            });
          });
        });
        req.setHeader('Content-Type', 'application/json');
        req.write(JSON.stringify(options));
        req.end();
        return this;
      };
      Socket.prototype._connectWebSocket = function(token, cb) {
        var self = this;
        if (self._ws) {
          process.nextTick(function() {
            cb();
          });
          return;
        }
        this._ws = new WebSocket('ws://' + getProxyHost() + '/api/vm/net/socket?token=' + token);
        this._handleWebsocket();
        if (cb) {
          self.on('connect', cb);
        }
      };
      Socket.prototype._handleWebsocket = function() {
        var self = this;
        this._ws.addEventListener('open', function() {
          self._connecting = false;
          self.readable = true;
          self.emit('connect');
          self.read(0);
        });
        this._ws.addEventListener('error', function(e) {
          self.emit('error', 'An error occured with the WebSocket');
        });
        this._ws.addEventListener('message', function(e) {
          var contents = e.data;
          var gotBuffer = function(buffer) {
            self.bytesRead += buffer.length;
            self.push(buffer);
          };
          if (typeof contents == 'string') {
            var buffer = new Buffer(contents);
            gotBuffer(buffer);
          } else if (window.Blob && contents instanceof Blob) {
            var fileReader = new FileReader();
            fileReader.addEventListener('load', function(e) {
              var buf = fileReader.result;
              var arr = new Uint8Array(buf);
              gotBuffer(new Buffer(arr));
            });
            fileReader.readAsArrayBuffer(contents);
          } else {
            console.warn('Cannot read TCP stream: unsupported message type', contents);
          }
        });
        this._ws.addEventListener('close', function() {
          if (self.readyState == 'open') {
            self.destroy();
          }
        });
      };
      exports.isIP = function(input) {
        if (exports.isIPv4(input)) {
          return 4;
        } else if (exports.isIPv6(input)) {
          return 6;
        } else {
          return 0;
        }
      };
      exports.isIPv4 = function(input) {
        return /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(input);
      };
      exports.isIPv6 = function(input) {
        return /^(([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))$/.test(input);
      };
    }
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7a", ["8c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8d", ["59", "1a", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var util = $__require('59');
    var EventEmitter = $__require('1a').EventEmitter;
    function Hose(socket, options, filter) {
      EventEmitter.call(this);
      if (typeof options === 'function') {
        filter = options;
        options = {};
      }
      this.socket = socket;
      this.options = options;
      this.filter = filter;
      this.buffer = null;
      var self = this;
      this.listeners = {
        error: function(err) {
          return self.onError(err);
        },
        data: function(chunk) {
          return self.onData(chunk);
        },
        end: function() {
          return self.onEnd();
        }
      };
      this.socket.on('error', this.listeners.error);
      this.socket.on('data', this.listeners.data);
      this.socket.on('end', this.listeners.end);
    }
    util.inherits(Hose, EventEmitter);
    module.exports = Hose;
    Hose.create = function create(socket, options, filter) {
      return new Hose(socket, options, filter);
    };
    Hose.prototype.detach = function detach() {
      this.socket.pause();
      this.socket.removeListener('error', this.listeners.error);
      this.socket.removeListener('data', this.listeners.data);
      this.socket.removeListener('end', this.listeners.end);
    };
    Hose.prototype.reemit = function reemit() {
      var buffer = this.buffer;
      this.buffer = null;
      if (this.socket.unshift) {
        this.socket.unshift(buffer);
        if (this.socket.listeners('data').length > 0)
          this.socket.resume();
        return;
      }
      if (this.socket.ondata)
        this.socket.ondata(buffer, 0, buffer.length);
      this.socket.emit('data', buffer);
      this.socket.resume();
    };
    Hose.prototype.onError = function onError(err) {
      this.detach();
      this.emit('error', err);
    };
    Hose.prototype.onData = function onData(chunk) {
      if (this.buffer)
        this.buffer = Buffer.concat([this.buffer, chunk]);
      else
        this.buffer = chunk;
      var self = this;
      this.filter(this.buffer, function(err, protocol) {
        if (err)
          return self.onError(err);
        if (!protocol)
          return;
        self.detach();
        self.emit('select', protocol, self.socket);
        self.reemit();
      });
    };
    Hose.prototype.onEnd = function onEnd() {
      this.detach();
      this.emit('error', new Error('Not enough data to recognize protocol'));
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8e", ["8d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8f", ["59", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var util = $__require('59');
    function QueueItem() {
      this.prev = null;
      this.next = null;
    }
    exports.QueueItem = QueueItem;
    function Queue() {
      QueueItem.call(this);
      this.prev = this;
      this.next = this;
    }
    util.inherits(Queue, QueueItem);
    exports.Queue = Queue;
    Queue.prototype.insertTail = function insertTail(item) {
      item.prev = this.prev;
      item.next = this;
      item.prev.next = item;
      item.next.prev = item;
    };
    Queue.prototype.remove = function remove(item) {
      var next = item.next;
      var prev = item.prev;
      item.next = item;
      item.prev = item;
      next.prev = prev;
      prev.next = next;
    };
    Queue.prototype.head = function head() {
      return this.next;
    };
    Queue.prototype.tail = function tail() {
      return this.prev;
    };
    Queue.prototype.isEmpty = function isEmpty() {
      return this.next === this;
    };
    Queue.prototype.isRoot = function isRoot(item) {
      return this === item;
    };
    function LockStream(stream) {
      this.locked = false;
      this.queue = [];
      this.stream = stream;
    }
    exports.LockStream = LockStream;
    LockStream.prototype.write = function write(chunks, callback) {
      var self = this;
      if (this.locked) {
        this.queue.push(function() {
          return self.write(chunks, callback);
        });
        return;
      }
      this.locked = true;
      function done(err, chunks) {
        self.stream.removeListener('error', done);
        self.locked = false;
        if (self.queue.length > 0)
          self.queue.shift()();
        callback(err, chunks);
      }
      this.stream.on('error', done);
      var output = [];
      function onData(chunk) {
        output.push(chunk);
      }
      this.stream.on('data', onData);
      function next(err) {
        self.stream.removeListener('data', onData);
        if (err)
          return done(err);
        done(null, output);
      }
      for (var i = 0; i < chunks.length - 1; i++)
        this.stream.write(chunks[i]);
      if (chunks.length > 0)
        this.stream.write(chunks[i], next);
      else
        process.nextTick(next);
      if (this.stream.execute) {
        this.stream.execute(function(err) {
          if (err)
            return done(err);
        });
      }
    };
    function binaryLookup(list, item, compare) {
      var start = 0;
      var end = list.length;
      while (start < end) {
        var pos = (start + end) >> 1;
        var cmp = compare(item, list[pos]);
        if (cmp === 0) {
          start = pos;
          end = pos;
          break;
        } else if (cmp < 0) {
          end = pos;
        } else {
          start = pos + 1;
        }
      }
      return start;
    }
    exports.binaryLookup = binaryLookup;
    function binaryInsert(list, item, compare) {
      var index = binaryLookup(list, item, compare);
      list.splice(index, 0, item);
    }
    exports.binaryInsert = binaryInsert;
    function binarySearch(list, item, compare) {
      var index = binaryLookup(list, item, compare);
      if (index >= list.length)
        return -1;
      if (compare(item, list[index]) === 0)
        return index;
      return -1;
    }
    exports.binarySearch = binarySearch;
    function Timeout(object) {
      this.delay = 0;
      this.timer = null;
      this.object = object;
    }
    exports.Timeout = Timeout;
    Timeout.prototype.set = function set(delay, callback) {
      this.delay = delay;
      this.reset();
      if (!callback)
        return;
      if (this.delay === 0)
        this.object.removeListener('timeout', callback);
      else
        this.object.once('timeout', callback);
    };
    Timeout.prototype.reset = function reset() {
      if (this.timer !== null) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      if (this.delay === 0)
        return;
      var self = this;
      this.timer = setTimeout(function() {
        self.timer = null;
        self.object.emit('timeout');
      }, this.delay);
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("90", ["59"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var utils = exports;
  var util = $__require('59');
  function ProtocolError(code, message) {
    this.code = code;
    this.message = message;
  }
  util.inherits(ProtocolError, Error);
  utils.ProtocolError = ProtocolError;
  utils.error = function error(code, message) {
    return new ProtocolError(code, message);
  };
  utils.reverse = function reverse(object) {
    var result = [];
    Object.keys(object).forEach(function(key) {
      result[object[key] | 0] = key;
    });
    return result;
  };
  utils.weightToPriority = function weightToPriority(weight) {
    return ((Math.min(35, (weight - 1)) / 35) * 7) | 0;
  };
  utils.priorityToWeight = function priorityToWeight(priority) {
    return (((priority / 7) * 35) | 0) + 1;
  };
  exports.addHeaderLine = function addHeaderLine(field, value, dest) {
    field = field.toLowerCase();
    if (/^:/.test(field)) {
      dest[field] = value;
      return;
    }
    switch (field) {
      case 'set-cookie':
        if (dest[field] !== undefined) {
          dest[field].push(value);
        } else {
          dest[field] = [value];
        }
        break;
      case 'content-type':
      case 'content-length':
      case 'user-agent':
      case 'referer':
      case 'host':
      case 'authorization':
      case 'proxy-authorization':
      case 'if-modified-since':
      case 'if-unmodified-since':
      case 'from':
      case 'location':
      case 'max-forwards':
        if (dest[field] === undefined)
          dest[field] = value;
        break;
      case 'cookie':
        if (dest[field] !== undefined) {
          dest[field] += '; ' + value;
        } else {
          dest[field] = value;
        }
        break;
      default:
        if (dest[field] !== undefined) {
          dest[field] += ', ' + value;
        } else {
          dest[field] = value;
        }
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("91", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.DEFAULT_METHOD = 'GET';
  exports.DEFAULT_HOST = 'localhost';
  exports.MAX_PRIORITY_STREAMS = 100;
  exports.DEFAULT_MAX_CHUNK = 8 * 1024;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("92", ["93", "71", "59", "80", "94", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var transport = $__require('93');
    var utils = transport.utils;
    var assert = $__require('71');
    var util = $__require('59');
    var debug = $__require('80')('spdy:scheduler');
    var Readable = $__require('94').Readable;
    function Scheduler(options) {
      Readable.call(this);
      this.window = 0.25;
      if (options && options.window)
        this.window = options.window;
      this.sync = [];
      this.list = [];
      this.count = 0;
      this.pendingTick = false;
    }
    util.inherits(Scheduler, Readable);
    module.exports = Scheduler;
    Scheduler.create = function create(options) {
      return new Scheduler(options);
    };
    function insertCompare(a, b) {
      return a.priority === b.priority ? a.stream - b.stream : b.priority - a.priority;
    }
    Scheduler.prototype.schedule = function schedule(data) {
      var priority = data.priority;
      var stream = data.stream;
      var chunks = data.chunks;
      if (priority === false) {
        debug('queue sync', chunks);
        this.sync.push(data);
        this.count += chunks.length;
        this._read();
        return;
      }
      debug('queue async priority=%d stream=%d', priority, stream, chunks);
      var item = new SchedulerItem(stream, priority);
      var index = utils.binaryLookup(this.list, item, insertCompare);
      if (index >= this.list.length || insertCompare(this.list[index], item) !== 0)
        this.list.splice(index, 0, item);
      else
        item = this.list[index];
      item.push(data);
      this.count += chunks.length;
      this._read();
    };
    Scheduler.prototype._read = function _read() {
      if (this.count === 0)
        return;
      if (this.pendingTick)
        return;
      this.pendingTick = true;
      var self = this;
      process.nextTick(function() {
        self.pendingTick = false;
        self.tick();
      });
    };
    Scheduler.prototype.tick = function tick() {
      if (!this.tickSync())
        return false;
      return this.tickAsync();
    };
    Scheduler.prototype.tickSync = function tickSync() {
      var sync = this.sync;
      var res = true;
      this.sync = [];
      for (var i = 0; i < sync.length; i++) {
        var item = sync[i];
        debug('tick sync pending=%d', this.count, item.chunks);
        for (var j = 0; j < item.chunks.length; j++) {
          this.count--;
          res = this.push(item.chunks[j]);
        }
        debug('after tick sync pending=%d', this.count);
        if (item.callback)
          item.callback(null);
      }
      return res;
    };
    Scheduler.prototype.tickAsync = function tickAsync() {
      var res = true;
      var list = this.list;
      if (list.length === 0)
        return res;
      var startPriority = list[0].priority;
      for (var index = 0; list.length > 0; index++) {
        index %= list.length;
        if (startPriority - list[index].priority > this.window)
          index = 0;
        debug('tick async index=%d start=%d', index, startPriority);
        var current = list[index];
        var item = current.shift();
        if (current.isEmpty()) {
          list.splice(index, 1);
          if (index === 0 && list.length > 0)
            startPriority = list[0].priority;
          index--;
        }
        debug('tick async pending=%d', this.count, item.chunks);
        for (var i = 0; i < item.chunks.length; i++) {
          this.count--;
          res = this.push(item.chunks[i]);
        }
        debug('after tick pending=%d', this.count);
        if (item.callback)
          item.callback(null);
        if (!res)
          break;
      }
      return res;
    };
    Scheduler.prototype.dump = function dump() {
      this.tickSync();
      while (!this.tickAsync()) {}
      assert.equal(this.count, 0);
    };
    function SchedulerItem(stream, priority) {
      this.stream = stream;
      this.priority = priority;
      this.queue = [];
    }
    SchedulerItem.prototype.push = function push(chunks) {
      this.queue.push(chunks);
    };
    SchedulerItem.prototype.shift = function shift() {
      return this.queue.shift();
    };
    SchedulerItem.prototype.isEmpty = function isEmpty() {
      return this.queue.length === 0;
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("95", ["93", "59", "96", "97", "94", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var transport = $__require('93');
    var util = $__require('59');
    var utils = $__require('96').utils;
    var OffsetBuffer = $__require('97');
    var Transform = $__require('94').Transform;
    function Parser(options) {
      Transform.call(this, {readableObjectMode: true});
      this.buffer = new OffsetBuffer();
      this.partial = false;
      this.waiting = 0;
      this.window = options.window;
      this.version = null;
      this.decompress = null;
      this.dead = false;
    }
    module.exports = Parser;
    util.inherits(Parser, Transform);
    Parser.prototype.error = utils.error;
    Parser.prototype.kill = function kill() {
      this.dead = true;
    };
    Parser.prototype._transform = function transform(data, encoding, cb) {
      if (!this.dead)
        this.buffer.push(data);
      this._consume(cb);
    };
    Parser.prototype._consume = function _consume(cb) {
      var self = this;
      function next(err, frame) {
        if (err)
          return cb(err);
        if (Array.isArray(frame)) {
          for (var i = 0; i < frame.length; i++)
            self.push(frame[i]);
        } else if (frame) {
          self.push(frame);
        }
        if (!sync)
          return self._consume(cb);
        process.nextTick(function() {
          self._consume(cb);
        });
      }
      if (this.dead)
        return cb();
      if (this.buffer.size < this.waiting) {
        if (this.buffer.size === 0)
          return cb();
        if (this.partial) {
          var partial = this.buffer.clone(this.buffer.size);
          this.buffer.skip(partial.size);
          this.waiting -= partial.size;
          this.executePartial(partial, next);
          return;
        }
        return cb();
      }
      var sync = true;
      var content = this.buffer.clone(this.waiting);
      this.buffer.skip(this.waiting);
      this.execute(content, next);
      sync = false;
    };
    Parser.prototype.setVersion = function setVersion(version) {
      this.version = version;
      this.emit('version', version);
    };
    Parser.prototype.setCompression = function setCompresion(pair) {
      this.decompress = new transport.utils.LockStream(pair.decompress);
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("98", ["59", "93", "96", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var util = $__require('59');
    var transport = $__require('93');
    var base = $__require('96');
    var Scheduler = base.Scheduler;
    function Framer(options) {
      Scheduler.call(this);
      this.version = null;
      this.compress = null;
      this.window = options.window;
      this.timeout = options.timeout;
      this.pushEnabled = null;
    }
    util.inherits(Framer, Scheduler);
    module.exports = Framer;
    Framer.prototype.setVersion = function setVersion(version) {
      this.version = version;
      this.emit('version');
    };
    Framer.prototype.setCompression = function setCompresion(pair) {
      this.compress = new transport.utils.LockStream(pair.compress);
    };
    Framer.prototype.enablePush = function enablePush(enable) {
      this.pushEnabled = enable;
      this.emit('_pushEnabled');
    };
    Framer.prototype._checkPush = function _checkPush(callback) {
      if (this.pushEnabled === null) {
        this.once('_pushEnabled', function() {
          this._checkPush(callback);
        });
        return;
      }
      var self = this;
      var err = null;
      if (!this.pushEnabled)
        err = new Error('PUSH_PROMISE disabled by other side');
      process.nextTick(function() {
        return callback(err);
      });
    };
    Framer.prototype._resetTimeout = function _resetTimeout() {
      if (this.timeout)
        this.timeout.reset();
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("96", ["90", "91", "92", "95", "98"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.utils = $__require('90');
  exports.constants = $__require('91');
  exports.Scheduler = $__require('92');
  exports.Parser = $__require('95');
  exports.Framer = $__require('98');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("99", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var Buffer = $__require('72').Buffer;
    var dictionary = {};
    module.exports = dictionary;
    dictionary[2] = new Buffer(['optionsgetheadpostputdeletetraceacceptaccept-charsetaccept-encodingaccept-', 'languageauthorizationexpectfromhostif-modified-sinceif-matchif-none-matchi', 'f-rangeif-unmodifiedsincemax-forwardsproxy-authorizationrangerefererteuser', '-agent10010120020120220320420520630030130230330430530630740040140240340440', '5406407408409410411412413414415416417500501502503504505accept-rangesageeta', 'glocationproxy-authenticatepublicretry-afterservervarywarningwww-authentic', 'ateallowcontent-basecontent-encodingcache-controlconnectiondatetrailertran', 'sfer-encodingupgradeviawarningcontent-languagecontent-lengthcontent-locati', 'oncontent-md5content-rangecontent-typeetagexpireslast-modifiedset-cookieMo', 'ndayTuesdayWednesdayThursdayFridaySaturdaySundayJanFebMarAprMayJunJulAugSe', 'pOctNovDecchunkedtext/htmlimage/pngimage/jpgimage/gifapplication/xmlapplic', 'ation/xhtmltext/plainpublicmax-agecharset=iso-8859-1utf-8gzipdeflateHTTP/1', '.1statusversionurl\x00'].join(''));
    dictionary[3] = new Buffer([0x00, 0x00, 0x00, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x00, 0x00, 0x00, 0x04, 0x68, 0x65, 0x61, 0x64, 0x00, 0x00, 0x00, 0x04, 0x70, 0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x03, 0x70, 0x75, 0x74, 0x00, 0x00, 0x00, 0x06, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x00, 0x00, 0x00, 0x05, 0x74, 0x72, 0x61, 0x63, 0x65, 0x00, 0x00, 0x00, 0x06, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x00, 0x00, 0x00, 0x0e, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x00, 0x00, 0x00, 0x0f, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x0f, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x00, 0x00, 0x00, 0x0d, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x00, 0x00, 0x00, 0x03, 0x61, 0x67, 0x65, 0x00, 0x00, 0x00, 0x05, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x00, 0x00, 0x00, 0x0d, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x0d, 0x63, 0x61, 0x63, 0x68, 0x65, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x00, 0x00, 0x00, 0x0a, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x62, 0x61, 0x73, 0x65, 0x00, 0x00, 0x00, 0x10, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x10, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x00, 0x00, 0x00, 0x0e, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x10, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x0b, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6d, 0x64, 0x35, 0x00, 0x00, 0x00, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00, 0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x74, 0x79, 0x70, 0x65, 0x00, 0x00, 0x00, 0x04, 0x64, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x04, 0x65, 0x74, 0x61, 0x67, 0x00, 0x00, 0x00, 0x06, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x00, 0x00, 0x00, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x00, 0x00, 0x00, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x08, 0x69, 0x66, 0x2d, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x00, 0x00, 0x00, 0x11, 0x69, 0x66, 0x2d, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2d, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x00, 0x00, 0x00, 0x0d, 0x69, 0x66, 0x2d, 0x6e, 0x6f, 0x6e, 0x65, 0x2d, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x00, 0x00, 0x00, 0x08, 0x69, 0x66, 0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00, 0x00, 0x13, 0x69, 0x66, 0x2d, 0x75, 0x6e, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2d, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x00, 0x00, 0x00, 0x0d, 0x6c, 0x61, 0x73, 0x74, 0x2d, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x00, 0x00, 0x00, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x0c, 0x6d, 0x61, 0x78, 0x2d, 0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x73, 0x00, 0x00, 0x00, 0x06, 0x70, 0x72, 0x61, 0x67, 0x6d, 0x61, 0x00, 0x00, 0x00, 0x12, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x13, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2d, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00, 0x00, 0x07, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x72, 0x00, 0x00, 0x00, 0x0b, 0x72, 0x65, 0x74, 0x72, 0x79, 0x2d, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00, 0x00, 0x00, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x00, 0x00, 0x00, 0x02, 0x74, 0x65, 0x00, 0x00, 0x00, 0x07, 0x74, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72, 0x00, 0x00, 0x00, 0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x2d, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x07, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x00, 0x00, 0x00, 0x0a, 0x75, 0x73, 0x65, 0x72, 0x2d, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x00, 0x00, 0x00, 0x04, 0x76, 0x61, 0x72, 0x79, 0x00, 0x00, 0x00, 0x03, 0x76, 0x69, 0x61, 0x00, 0x00, 0x00, 0x07, 0x77, 0x61, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x10, 0x77, 0x77, 0x77, 0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x00, 0x00, 0x00, 0x03, 0x67, 0x65, 0x74, 0x00, 0x00, 0x00, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x00, 0x00, 0x00, 0x06, 0x32, 0x30, 0x30, 0x20, 0x4f, 0x4b, 0x00, 0x00, 0x00, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x08, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x03, 0x75, 0x72, 0x6c, 0x00, 0x00, 0x00, 0x06, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x00, 0x00, 0x00, 0x0a, 0x73, 0x65, 0x74, 0x2d, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x00, 0x00, 0x00, 0x0a, 0x6b, 0x65, 0x65, 0x70, 0x2d, 0x61, 0x6c, 0x69, 0x76, 0x65, 0x00, 0x00, 0x00, 0x06, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x32, 0x30, 0x31, 0x32, 0x30, 0x32, 0x32, 0x30, 0x35, 0x32, 0x30, 0x36, 0x33, 0x30, 0x30, 0x33, 0x30, 0x32, 0x33, 0x30, 0x33, 0x33, 0x30, 0x34, 0x33, 0x30, 0x35, 0x33, 0x30, 0x36, 0x33, 0x30, 0x37, 0x34, 0x30, 0x32, 0x34, 0x30, 0x35, 0x34, 0x30, 0x36, 0x34, 0x30, 0x37, 0x34, 0x30, 0x38, 0x34, 0x30, 0x39, 0x34, 0x31, 0x30, 0x34, 0x31, 0x31, 0x34, 0x31, 0x32, 0x34, 0x31, 0x33, 0x34, 0x31, 0x34, 0x34, 0x31, 0x35, 0x34, 0x31, 0x36, 0x34, 0x31, 0x37, 0x35, 0x30, 0x32, 0x35, 0x30, 0x34, 0x35, 0x30, 0x35, 0x32, 0x30, 0x33, 0x20, 0x4e, 0x6f, 0x6e, 0x2d, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x32, 0x30, 0x34, 0x20, 0x4e, 0x6f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x33, 0x30, 0x31, 0x20, 0x4d, 0x6f, 0x76, 0x65, 0x64, 0x20, 0x50, 0x65, 0x72, 0x6d, 0x61, 0x6e, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x34, 0x30, 0x30, 0x20, 0x42, 0x61, 0x64, 0x20, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x34, 0x30, 0x31, 0x20, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x34, 0x30, 0x33, 0x20, 0x46, 0x6f, 0x72, 0x62, 0x69, 0x64, 0x64, 0x65, 0x6e, 0x34, 0x30, 0x34, 0x20, 0x4e, 0x6f, 0x74, 0x20, 0x46, 0x6f, 0x75, 0x6e, 0x64, 0x35, 0x30, 0x30, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x35, 0x30, 0x31, 0x20, 0x4e, 0x6f, 0x74, 0x20, 0x49, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x65, 0x64, 0x35, 0x30, 0x33, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x55, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x4a, 0x61, 0x6e, 0x20, 0x46, 0x65, 0x62, 0x20, 0x4d, 0x61, 0x72, 0x20, 0x41, 0x70, 0x72, 0x20, 0x4d, 0x61, 0x79, 0x20, 0x4a, 0x75, 0x6e, 0x20, 0x4a, 0x75, 0x6c, 0x20, 0x41, 0x75, 0x67, 0x20, 0x53, 0x65, 0x70, 0x74, 0x20, 0x4f, 0x63, 0x74, 0x20, 0x4e, 0x6f, 0x76, 0x20, 0x44, 0x65, 0x63, 0x20, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x20, 0x4d, 0x6f, 0x6e, 0x2c, 0x20, 0x54, 0x75, 0x65, 0x2c, 0x20, 0x57, 0x65, 0x64, 0x2c, 0x20, 0x54, 0x68, 0x75, 0x2c, 0x20, 0x46, 0x72, 0x69, 0x2c, 0x20, 0x53, 0x61, 0x74, 0x2c, 0x20, 0x53, 0x75, 0x6e, 0x2c, 0x20, 0x47, 0x4d, 0x54, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x65, 0x64, 0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x2c, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2f, 0x70, 0x6e, 0x67, 0x2c, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2f, 0x6a, 0x70, 0x67, 0x2c, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2f, 0x67, 0x69, 0x66, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x6d, 0x6c, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x68, 0x74, 0x6d, 0x6c, 0x2b, 0x78, 0x6d, 0x6c, 0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x6a, 0x61, 0x76, 0x61, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x2c, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x6d, 0x61, 0x78, 0x2d, 0x61, 0x67, 0x65, 0x3d, 0x67, 0x7a, 0x69, 0x70, 0x2c, 0x64, 0x65, 0x66, 0x6c, 0x61, 0x74, 0x65, 0x2c, 0x73, 0x64, 0x63, 0x68, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d, 0x75, 0x74, 0x66, 0x2d, 0x38, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d, 0x69, 0x73, 0x6f, 0x2d, 0x38, 0x38, 0x35, 0x39, 0x2d, 0x31, 0x2c, 0x75, 0x74, 0x66, 0x2d, 0x2c, 0x2a, 0x2c, 0x65, 0x6e, 0x71, 0x3d, 0x30, 0x2e]);
    dictionary[3.1] = dictionary[3];
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9a", ["93"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var transport = $__require('93');
  var base = transport.protocol.base;
  exports.FRAME_HEADER_SIZE = 8;
  exports.PING_OPAQUE_SIZE = 4;
  exports.MAX_CONCURRENT_STREAMS = Infinity;
  exports.DEFAULT_MAX_HEADER_LIST_SIZE = Infinity;
  exports.DEFAULT_WEIGHT = 16;
  exports.frameType = {
    SYN_STREAM: 1,
    SYN_REPLY: 2,
    RST_STREAM: 3,
    SETTINGS: 4,
    PING: 6,
    GOAWAY: 7,
    HEADERS: 8,
    WINDOW_UPDATE: 9,
    X_FORWARDED_FOR: 0xf000
  };
  exports.flags = {
    FLAG_FIN: 0x01,
    FLAG_COMPRESSED: 0x02,
    FLAG_UNIDIRECTIONAL: 0x02
  };
  exports.error = {
    PROTOCOL_ERROR: 1,
    INVALID_STREAM: 2,
    REFUSED_STREAM: 3,
    UNSUPPORTED_VERSION: 4,
    CANCEL: 5,
    INTERNAL_ERROR: 6,
    FLOW_CONTROL_ERROR: 7,
    STREAM_IN_USE: 8,
    STREAM_CLOSED: 9,
    INVALID_CREDENTIALS: 10,
    FRAME_TOO_LARGE: 11
  };
  exports.errorByCode = base.utils.reverse(exports.error);
  exports.settings = {
    FLAG_SETTINGS_PERSIST_VALUE: 1,
    FLAG_SETTINGS_PERSISTED: 2,
    SETTINGS_UPLOAD_BANDWIDTH: 1,
    SETTINGS_DOWNLOAD_BANDWIDTH: 2,
    SETTINGS_ROUND_TRIP_TIME: 3,
    SETTINGS_MAX_CONCURRENT_STREAMS: 4,
    SETTINGS_CURRENT_CWND: 5,
    SETTINGS_DOWNLOAD_RETRANS_RATE: 6,
    SETTINGS_INITIAL_WINDOW_SIZE: 7,
    SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE: 8
  };
  exports.settingsIndex = [null, 'upload_bandwidth', 'download_bandwidth', 'round_trip_time', 'max_concurrent_streams', 'current_cwnd', 'download_retrans_rate', 'initial_window_size', 'client_certificate_vector_size'];
  exports.DEFAULT_WINDOW = 64 * 1024;
  exports.MAX_INITIAL_WINDOW_SIZE = 2147483647;
  exports.goaway = {
    OK: 0,
    PROTOCOL_ERROR: 1,
    INTERNAL_ERROR: 2
  };
  exports.goawayByCode = base.utils.reverse(exports.goaway);
  exports.statusReason = {
    100: 'Continue',
    101: 'Switching Protocols',
    102: 'Processing',
    200: 'OK',
    201: 'Created',
    202: 'Accepted',
    203: 'Non-Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    207: 'Multi-Status',
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Moved Temporarily',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    307: 'Temporary Redirect',
    308: 'Permanent Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Time-out',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Request Entity Too Large',
    414: 'Request-URI Too Large',
    415: 'Unsupported Media Type',
    416: 'Requested Range Not Satisfiable',
    417: 'Expectation Failed',
    418: 'I\'m a teapot',
    422: 'Unprocessable Entity',
    423: 'Locked',
    424: 'Failed Dependency',
    425: 'Unordered Collection',
    426: 'Upgrade Required',
    428: 'Precondition Required',
    429: 'Too Many Requests',
    431: 'Request Header Fields Too Large',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Time-out',
    505: 'HTTP Version Not Supported',
    506: 'Variant Also Negotiates',
    507: 'Insufficient Storage',
    509: 'Bandwidth Limit Exceeded',
    510: 'Not Extended',
    511: 'Network Authentication Required'
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9b", ["93", "9a", "71", "59", "97"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var parser = exports;
  var transport = $__require('93');
  var base = transport.protocol.base;
  var utils = base.utils;
  var constants = $__require('9a');
  var assert = $__require('71');
  var util = $__require('59');
  var OffsetBuffer = $__require('97');
  function Parser(options) {
    base.Parser.call(this, options);
    this.isServer = options.isServer;
    this.waiting = constants.FRAME_HEADER_SIZE;
    this.state = 'frame-head';
    this.pendingHeader = null;
  }
  util.inherits(Parser, base.Parser);
  parser.create = function create(options) {
    return new Parser(options);
  };
  Parser.prototype.setMaxFrameSize = function setMaxFrameSize(size) {};
  Parser.prototype.setMaxHeaderListSize = function setMaxHeaderListSize(size) {};
  Parser.prototype.skipPreface = function skipPreface() {};
  Parser.prototype.execute = function execute(buffer, callback) {
    if (this.state === 'frame-head')
      return this.onFrameHead(buffer, callback);
    assert(this.state === 'frame-body' && this.pendingHeader !== null);
    var self = this;
    var header = this.pendingHeader;
    this.pendingHeader = null;
    this.onFrameBody(header, buffer, function(err, frame) {
      if (err)
        return callback(err);
      self.state = 'frame-head';
      self.waiting = constants.FRAME_HEADER_SIZE;
      self.partial = false;
      callback(null, frame);
    });
  };
  Parser.prototype.executePartial = function executePartial(buffer, callback) {
    var header = this.pendingHeader;
    if (this.window)
      this.window.recv.update(-buffer.size);
    callback(null, {
      type: 'DATA',
      id: header.id,
      fin: false,
      data: buffer.take(buffer.size)
    });
  };
  Parser.prototype.onFrameHead = function onFrameHead(buffer, callback) {
    var header = {
      control: (buffer.peekUInt8() & 0x80) === 0x80 ? true : false,
      version: null,
      type: null,
      id: null,
      flags: null,
      length: null
    };
    if (header.control) {
      header.version = buffer.readUInt16BE() & 0x7fff;
      header.type = buffer.readUInt16BE();
    } else {
      header.id = buffer.readUInt32BE(0) & 0x7fffffff;
    }
    header.flags = buffer.readUInt8();
    header.length = buffer.readUInt24BE();
    if (this.version === null && header.control) {
      if (header.version !== 2 && header.version !== 3)
        return callback(new Error('Unsupported SPDY version: ' + header.version));
      this.setVersion(header.version);
    }
    this.state = 'frame-body';
    this.waiting = header.length;
    this.pendingHeader = header;
    this.partial = !header.control;
    callback(null, null);
  };
  Parser.prototype.onFrameBody = function onFrameBody(header, buffer, callback) {
    if (!header.control) {
      if (this.window)
        this.window.recv.update(-buffer.size);
      if ((header.flags & constants.flags.FLAG_COMPRESSED) !== 0)
        return callback(new Error('DATA compression not supported'));
      if (header.id === 0) {
        return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for DATA'));
      }
      return callback(null, {
        type: 'DATA',
        id: header.id,
        fin: (header.flags & constants.flags.FLAG_FIN) !== 0,
        data: buffer.take(buffer.size)
      });
    }
    if (header.type === 0x01 || header.type === 0x02)
      this.onSynHeadFrame(header.type, header.flags, buffer, callback);
    else if (header.type === 0x03)
      this.onRSTFrame(buffer, callback);
    else if (header.type === 0x04)
      this.onSettingsFrame(buffer, callback);
    else if (header.type === 0x05)
      callback(null, {type: 'NOOP'});
    else if (header.type === 0x06)
      this.onPingFrame(buffer, callback);
    else if (header.type === 0x07)
      this.onGoawayFrame(buffer, callback);
    else if (header.type === 0x08)
      this.onHeaderFrames(buffer, callback);
    else if (header.type === 0x09)
      this.onWindowUpdateFrame(buffer, callback);
    else if (header.type === 0xf000)
      this.onXForwardedFrame(buffer, callback);
    else
      callback(null, {type: 'unknown: ' + header.type});
  };
  Parser.prototype._filterHeader = function _filterHeader(headers, name) {
    var res = {};
    var keys = Object.keys(headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key !== name)
        res[key] = headers[key];
    }
    return res;
  };
  Parser.prototype.onSynHeadFrame = function onSynHeadFrame(type, flags, body, callback) {
    var self = this;
    var stream = type === 0x01;
    var offset = stream ? 10 : this.version === 2 ? 6 : 4;
    if (!body.has(offset))
      return callback(new Error('SynHead OOB'));
    var head = body.clone(offset);
    body.skip(offset);
    this.parseKVs(body, function(err, headers) {
      if (err)
        return callback(err);
      if (stream && (!headers[':method'] || !headers[':path'])) {
        return callback(new Error('Missing `:method` and/or `:path` header'));
      }
      var id = head.readUInt32BE() & 0x7fffffff;
      if (id === 0) {
        return callback(self.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for HEADERS'));
      }
      var associated = stream ? head.readUInt32BE() & 0x7fffffff : 0;
      var priority = stream ? head.readUInt8() >> 5 : utils.weightToPriority(constants.DEFAULT_WEIGHT);
      var fin = (flags & constants.flags.FLAG_FIN) !== 0;
      var unidir = (flags & constants.flags.FLAG_UNIDIRECTIONAL) !== 0;
      var path = headers[':path'];
      var isPush = stream && associated !== 0;
      var weight = utils.priorityToWeight(priority);
      var priorityInfo = {
        weight: weight,
        exclusive: false,
        parent: 0
      };
      if (!isPush) {
        callback(null, {
          type: 'HEADERS',
          id: id,
          priority: priorityInfo,
          fin: fin,
          writable: !unidir,
          headers: headers,
          path: path
        });
        return;
      }
      if (stream && !headers[':status'])
        return callback(new Error('Missing `:status` header'));
      var filteredHeaders = self._filterHeader(headers, ':status');
      callback(null, [{
        type: 'PUSH_PROMISE',
        id: associated,
        fin: false,
        promisedId: id,
        headers: filteredHeaders,
        path: path
      }, {
        type: 'HEADERS',
        id: id,
        fin: fin,
        priority: priorityInfo,
        writable: true,
        path: undefined,
        headers: {':status': headers[':status']}
      }]);
    });
  };
  Parser.prototype.onHeaderFrames = function onHeaderFrames(body, callback) {
    var offset = this.version === 2 ? 6 : 4;
    if (!body.has(offset))
      return callback(new Error('HEADERS OOB'));
    var streamId = body.readUInt32BE() & 0x7fffffff;
    if (this.version === 2)
      body.skip(2);
    this.parseKVs(body, function(err, headers) {
      if (err)
        return callback(err);
      callback(null, {
        type: 'HEADERS',
        priority: {
          parent: 0,
          exclusive: false,
          weight: constants.DEFAULT_WEIGHT
        },
        id: streamId,
        fin: false,
        writable: true,
        path: undefined,
        headers: headers
      });
    });
  };
  Parser.prototype.parseKVs = function parseKVs(buffer, callback) {
    var self = this;
    this.decompress.write(buffer.toChunks(), function(err, chunks) {
      if (err)
        return callback(err);
      var buffer = new OffsetBuffer();
      for (var i = 0; i < chunks.length; i++)
        buffer.push(chunks[i]);
      var size = self.version === 2 ? 2 : 4;
      if (!buffer.has(size))
        return callback(new Error('KV OOB'));
      var count = self.version === 2 ? buffer.readUInt16BE() : buffer.readUInt32BE();
      var headers = {};
      function readString() {
        if (!buffer.has(size))
          return null;
        var len = self.version === 2 ? buffer.readUInt16BE() : buffer.readUInt32BE();
        if (!buffer.has(len))
          return null;
        var value = buffer.take(len);
        return value.toString();
      }
      while (count > 0) {
        var key = readString();
        var value = readString();
        if (key === null || value === null)
          return callback(new Error('Headers OOB'));
        if (self.version < 3) {
          var isInternal = /^(method|version|url|host|scheme|status)$/.test(key);
          if (key === 'url')
            key = 'path';
          if (isInternal)
            key = ':' + key;
        }
        if (key === ':status')
          value = value.split(/ /g, 2)[0];
        count--;
        if (key === ':host')
          key = ':authority';
        if (key === ':version')
          continue;
        value = value.split(/\0/g);
        for (var i = 0; i < value.length; i++)
          utils.addHeaderLine(key, value[i], headers);
      }
      callback(null, headers);
    });
  };
  Parser.prototype.onRSTFrame = function onRSTFrame(body, callback) {
    if (!body.has(8))
      return callback(new Error('RST OOB'));
    var frame = {
      type: 'RST',
      id: body.readUInt32BE() & 0x7fffffff,
      code: constants.errorByCode[body.readUInt32BE()]
    };
    if (frame.id === 0) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for RST'));
    }
    if (body.size !== 0)
      frame.extra = body.take(body.size);
    callback(null, frame);
  };
  Parser.prototype.onSettingsFrame = function onSettingsFrame(body, callback) {
    if (!body.has(4))
      return callback(new Error('SETTINGS OOB'));
    var settings = {},
        number = body.readUInt32BE(),
        idMap = {
          1: 'upload_bandwidth',
          2: 'download_bandwidth',
          3: 'round_trip_time',
          4: 'max_concurrent_streams',
          5: 'current_cwnd',
          6: 'download_retrans_rate',
          7: 'initial_window_size',
          8: 'client_certificate_vector_size'
        };
    if (!body.has(number * 8))
      return callback(new Error('SETTINGS OOB#2'));
    for (var i = 0; i < number; i++) {
      var id = this.version === 2 ? body.readUInt32LE() : body.readUInt32BE();
      var flags = (id >> 24) & 0xff;
      id = id & 0xffffff;
      if (flags & 0x2)
        continue;
      var name = idMap[id];
      settings[name] = body.readUInt32BE();
    }
    callback(null, {
      type: 'SETTINGS',
      settings: settings
    });
  };
  Parser.prototype.onPingFrame = function onPingFrame(body, callback) {
    if (!body.has(4))
      return callback(new Error('PING OOB'));
    var isServer = this.isServer;
    var opaque = body.clone(body.size).take(body.size);
    var id = body.readUInt32BE();
    var ack = isServer ? (id % 2 === 0) : (id % 2 === 1);
    callback(null, {
      type: 'PING',
      opaque: opaque,
      ack: ack
    });
  };
  Parser.prototype.onGoawayFrame = function onGoawayFrame(body, callback) {
    if (!body.has(8))
      return callback(new Error('GOAWAY OOB'));
    callback(null, {
      type: 'GOAWAY',
      lastId: body.readUInt32BE() & 0x7fffffff,
      code: constants.goawayByCode[body.readUInt32BE()]
    });
  };
  Parser.prototype.onWindowUpdateFrame = function onWindowUpdateFrame(body, callback) {
    if (!body.has(8))
      return callback(new Error('WINDOW_UPDATE OOB'));
    callback(null, {
      type: 'WINDOW_UPDATE',
      id: body.readUInt32BE() & 0x7fffffff,
      delta: body.readInt32BE()
    });
  };
  Parser.prototype.onXForwardedFrame = function onXForwardedFrame(body, callback) {
    if (!body.has(4))
      return callback(new Error('X_FORWARDED OOB'));
    var len = body.readUInt32BE();
    if (!body.has(len))
      return callback(new Error('X_FORWARDED host length OOB'));
    callback(null, {
      type: 'X_FORWARDED_FOR',
      host: body.take(len).toString()
    });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9c", ["93", "9d", "71", "59", "72", "9e", "80", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    'use strict';
    var transport = $__require('93');
    var constants = $__require('9d').constants;
    var base = transport.protocol.base;
    var utils = base.utils;
    var assert = $__require('71');
    var util = $__require('59');
    var Buffer = $__require('72').Buffer;
    var WriteBuffer = $__require('9e');
    var debug = $__require('80')('spdy:framer');
    function Framer(options) {
      base.Framer.call(this, options);
    }
    util.inherits(Framer, base.Framer);
    module.exports = Framer;
    Framer.create = function create(options) {
      return new Framer(options);
    };
    Framer.prototype.setMaxFrameSize = function setMaxFrameSize(size) {};
    Framer.prototype.headersToDict = function headersToDict(headers, preprocess, callback) {
      function stringify(value) {
        if (value !== undefined) {
          if (Array.isArray(value)) {
            return value.join('\x00');
          } else if (typeof value === 'string') {
            return value;
          } else {
            return value.toString();
          }
        } else {
          return '';
        }
      }
      var loweredHeaders = {};
      Object.keys(headers || {}).map(function(key) {
        loweredHeaders[key.toLowerCase()] = headers[key];
      });
      if (preprocess)
        preprocess(loweredHeaders);
      var size = this.version === 2 ? 2 : 4;
      var len = size;
      var pairs = Object.keys(loweredHeaders).filter(function(key) {
        var lkey = key.toLowerCase();
        if (lkey === 'host' && this.version >= 3)
          return false;
        return lkey !== 'connection' && lkey !== 'keep-alive' && lkey !== 'proxy-connection' && lkey !== 'transfer-encoding';
      }, this).map(function(key) {
        var klen = Buffer.byteLength(key),
            value = stringify(loweredHeaders[key]),
            vlen = Buffer.byteLength(value);
        len += size * 2 + klen + vlen;
        return [klen, key, vlen, value];
      });
      var block = new WriteBuffer();
      block.reserve(len);
      if (this.version === 2)
        block.writeUInt16BE(pairs.length);
      else
        block.writeUInt32BE(pairs.length);
      pairs.forEach(function(pair) {
        if (this.version === 2)
          block.writeUInt16BE(pair[0]);
        else
          block.writeUInt32BE(pair[0]);
        block.write(pair[1]);
        if (this.version === 2)
          block.writeUInt16BE(pair[2]);
        else
          block.writeUInt32BE(pair[2]);
        block.write(pair[3]);
      }, this);
      assert(this.compress !== null, 'Framer version not initialized');
      this.compress.write(block.render(), callback);
    };
    Framer.prototype._frame = function _frame(frame, body, callback) {
      if (!this.version) {
        this.on('version', function() {
          this._frame(frame, body, callback);
        });
        return;
      }
      debug('id=%d type=%s', frame.id, frame.type);
      var buffer = new WriteBuffer();
      buffer.writeUInt16BE(0x8000 | this.version);
      buffer.writeUInt16BE(constants.frameType[frame.type]);
      buffer.writeUInt8(frame.flags);
      var len = buffer.skip(3);
      var self = this;
      body(buffer);
      var frameSize = buffer.size - constants.FRAME_HEADER_SIZE;
      len.writeUInt24BE(frameSize);
      var chunks = buffer.render();
      var toWrite = {
        stream: frame.id,
        priority: false,
        chunks: chunks,
        callback: callback
      };
      this._resetTimeout();
      this.schedule(toWrite);
      return chunks;
    };
    Framer.prototype._synFrame = function _synFrame(frame, callback) {
      var self = this;
      if (!frame.path)
        throw new Error('`path` is required frame argument');
      function preprocess(headers) {
        var method = frame.method || base.constants.DEFAULT_METHOD;
        var version = frame.version || 'HTTP/1.1';
        var scheme = frame.scheme || 'https';
        var host = frame.host || frame.headers && frame.headers.host || base.constants.DEFAULT_HOST;
        if (self.version === 2) {
          headers.method = method;
          headers.version = version;
          headers.url = frame.path;
          headers.scheme = scheme;
          headers.host = host;
          if (frame.status)
            headers.status = frame.status;
        } else {
          headers[':method'] = method;
          headers[':version'] = version;
          headers[':path'] = frame.path;
          headers[':scheme'] = scheme;
          headers[':host'] = host;
          if (frame.status)
            headers[':status'] = frame.status;
        }
      }
      this.headersToDict(frame.headers, preprocess, function(err, chunks) {
        if (err) {
          if (callback)
            return callback(err);
          else
            return self.emit('error', err);
        }
        self._frame({
          type: 'SYN_STREAM',
          id: frame.id,
          flags: frame.fin ? constants.flags.FLAG_FIN : 0
        }, function(buf) {
          buf.reserve(10);
          buf.writeUInt32BE(frame.id & 0x7fffffff);
          buf.writeUInt32BE(frame.associated & 0x7fffffff);
          var weight = frame.priority && frame.priority.weight || constants.DEFAULT_WEIGHT;
          var priority = utils.weightToPriority(weight);
          buf.writeUInt8(priority << 5);
          buf.writeUInt8(0);
          for (var i = 0; i < chunks.length; i++)
            buf.copyFrom(chunks[i]);
        }, callback);
      });
    };
    Framer.prototype.requestFrame = function requestFrame(frame, callback) {
      this._synFrame({
        id: frame.id,
        fin: frame.fin,
        associated: 0,
        method: frame.method,
        version: frame.version,
        scheme: frame.scheme,
        host: frame.host,
        path: frame.path,
        priority: frame.priority,
        headers: frame.headers
      }, callback);
    };
    Framer.prototype.responseFrame = function responseFrame(frame, callback) {
      var self = this;
      var reason = frame.reason;
      if (!reason)
        reason = constants.statusReason[frame.status];
      function preprocess(headers) {
        if (self.version === 2) {
          headers.status = frame.status + ' ' + reason;
          headers.version = 'HTTP/1.1';
        } else {
          headers[':status'] = frame.status + ' ' + reason;
          headers[':version'] = 'HTTP/1.1';
        }
      }
      this.headersToDict(frame.headers, preprocess, function(err, chunks) {
        if (err) {
          if (callback)
            return callback(err);
          else
            return self.emit('error', err);
        }
        self._frame({
          type: 'SYN_REPLY',
          id: frame.id,
          flags: 0
        }, function(buf) {
          buf.reserve(self.version === 2 ? 6 : 4);
          buf.writeUInt32BE(frame.id & 0x7fffffff);
          if (self.version === 2)
            buf.writeUInt16BE(0);
          for (var i = 0; i < chunks.length; i++)
            buf.copyFrom(chunks[i]);
        }, callback);
      });
    };
    Framer.prototype.pushFrame = function pushFrame(frame, callback) {
      var self = this;
      this._checkPush(function(err) {
        if (err)
          return callback(err);
        self._synFrame({
          id: frame.promisedId,
          associated: frame.id,
          method: frame.method,
          status: frame.status || 200,
          version: frame.version,
          scheme: frame.scheme,
          host: frame.host,
          path: frame.path,
          priority: frame.priority,
          headers: util._extend(util._extend({}, frame.headers), frame.response)
        }, callback);
      });
    };
    Framer.prototype.headersFrame = function headersFrame(frame, callback) {
      var self = this;
      this.headersToDict(frame.headers, null, function(err, chunks) {
        if (err) {
          if (callback)
            return callback(err);
          else
            return self.emit('error', err);
        }
        self._frame({
          type: 'HEADERS',
          id: frame.id,
          priority: false,
          flags: 0
        }, function(buf) {
          buf.reserve(4 + (self.version === 2 ? 2 : 0));
          buf.writeUInt32BE(frame.id & 0x7fffffff);
          if (self.version === 2)
            buf.writeUInt16BE(0);
          for (var i = 0; i < chunks.length; i++)
            buf.copyFrom(chunks[i]);
        }, callback);
      });
    };
    Framer.prototype.dataFrame = function dataFrame(frame, callback) {
      if (!this.version) {
        return this.on('version', function() {
          this.dataFrame(frame, callback);
        });
      }
      debug('id=%d type=DATA', frame.id);
      var buffer = new WriteBuffer();
      buffer.reserve(8 + frame.data.length);
      buffer.writeUInt32BE(frame.id & 0x7fffffff);
      buffer.writeUInt8(frame.fin ? 0x01 : 0x0);
      buffer.writeUInt24BE(frame.data.length);
      buffer.copyFrom(frame.data);
      var chunks = buffer.render();
      var toWrite = {
        stream: frame.id,
        priority: frame.priority,
        chunks: chunks,
        callback: callback
      };
      var self = this;
      this._resetTimeout();
      this.window.send.update(-frame.data.length, function() {
        self._resetTimeout();
        self.schedule(toWrite);
      });
    };
    Framer.prototype.pingFrame = function pingFrame(frame, callback) {
      this._frame({
        type: 'PING',
        id: 0,
        flags: 0
      }, function(buf, callback) {
        buf.reserve(4);
        var opaque = frame.opaque;
        buf.writeUInt32BE(opaque.readUInt32BE(opaque.length - 4, true));
      }, callback);
    };
    Framer.prototype.rstFrame = function rstFrame(frame, callback) {
      var self = this;
      this._frame({
        type: 'RST_STREAM',
        id: frame.id,
        flags: 0
      }, function(buf) {
        buf.reserve(8);
        buf.writeUInt32BE(frame.id & 0x7fffffff);
        buf.writeUInt32BE(constants.error[frame.code]);
        if (frame.extra)
          buf.write(frame.extra);
      }, callback);
    };
    Framer.prototype.prefaceFrame = function prefaceFrame() {};
    Framer.prototype.settingsFrame = function settingsFrame(options, callback) {
      var self = this;
      var key = this.version + '/' + JSON.stringify(options);
      var settings = Framer.settingsCache[key];
      if (settings) {
        debug('cached settings');
        this._resetTimeout();
        this.schedule({
          stream: 0,
          priority: false,
          chunks: settings,
          callback: callback
        });
        return;
      }
      var params = [];
      for (var i = 0; i < constants.settingsIndex.length; i++) {
        var name = constants.settingsIndex[i];
        if (!name)
          continue;
        if (!isFinite(options[name]))
          continue;
        if (options[name] !== undefined)
          params.push({
            key: i,
            value: options[name]
          });
      }
      var frame = this._frame({
        type: 'SETTINGS',
        id: 0,
        flags: 0
      }, function(buf) {
        buf.reserve(4 + 8 * params.length);
        buf.writeUInt32BE(params.length);
        params.forEach(function(param) {
          var flag = constants.settings.FLAG_SETTINGS_PERSIST_VALUE << 24;
          if (self.version === 2)
            buf.writeUInt32LE(flag | param.key);
          else
            buf.writeUInt32BE(flag | param.key);
          buf.writeUInt32BE(param.value & 0x7fffffff);
        });
      }, callback);
      Framer.settingsCache[key] = frame;
    };
    Framer.settingsCache = {};
    Framer.prototype.ackSettingsFrame = function ackSettingsFrame(callback) {
      if (callback)
        process.nextTick(callback);
    };
    Framer.prototype.windowUpdateFrame = function windowUpdateFrame(frame, callback) {
      this._frame({
        type: 'WINDOW_UPDATE',
        id: frame.id,
        flags: 0
      }, function(buf) {
        buf.reserve(8);
        buf.writeUInt32BE(frame.id & 0x7fffffff);
        buf.writeInt32BE(frame.delta);
      }, callback);
    };
    Framer.prototype.goawayFrame = function goawayFrame(frame, callback) {
      this._frame({
        type: 'GOAWAY',
        id: 0,
        flags: 0
      }, function(buf) {
        buf.reserve(8);
        buf.writeUInt32BE(frame.lastId & 0x7fffffff);
        buf.writeUInt32BE(constants.goaway[frame.code]);
      }, callback);
    };
    Framer.prototype.priorityFrame = function priorityFrame(frame, callback) {
      if (callback)
        process.nextTick(callback);
    };
    Framer.prototype.xForwardedFor = function xForwardedFor(frame, callback) {
      this._frame({
        type: 'X_FORWARDED_FOR',
        id: 0,
        flags: 0
      }, function(buf) {
        buf.writeUInt32BE(Buffer.byteLength(frame.host));
        buf.write(frame.host);
      }, callback);
    };
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9f", ["a0", "93"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var zlibpool = exports;
  var zlib = $__require('a0');
  var transport = $__require('93');
  function createDeflate(version, compression) {
    var deflate = zlib.createDeflate({
      dictionary: transport.protocol.spdy.dictionary[version],
      flush: zlib.Z_SYNC_FLUSH,
      windowBits: 11,
      level: compression ? zlib.Z_DEFAULT_COMPRESSION : zlib.Z_NO_COMPRESSION
    });
    deflate._flush = zlib.Z_SYNC_FLUSH;
    return deflate;
  }
  function createInflate(version) {
    var inflate = zlib.createInflate({
      dictionary: transport.protocol.spdy.dictionary[version],
      flush: zlib.Z_SYNC_FLUSH,
      windowBits: 0
    });
    inflate._flush = zlib.Z_SYNC_FLUSH;
    return inflate;
  }
  function Pool(compression) {
    this.compression = compression;
    this.pool = {
      2: [],
      3: [],
      3.1: []
    };
  }
  zlibpool.create = function create(compression) {
    return new Pool(compression);
  };
  Pool.prototype.get = function get(version) {
    if (this.pool[version].length > 0) {
      return this.pool[version].pop();
    } else {
      var id = version;
      return {
        version: version,
        compress: createDeflate(id, this.compression),
        decompress: createInflate(id)
      };
    }
  };
  Pool.prototype.put = function put(pair) {
    this.pool[pair.version].push(pair);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9d", ["99", "9a", "9b", "9c", "9f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.name = 'spdy';
  exports.dictionary = $__require('99');
  exports.constants = $__require('9a');
  exports.parser = $__require('9b');
  exports.framer = $__require('9c');
  exports.compressionPool = $__require('9f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a1", ["93", "59", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var transport = $__require('93');
    var base = transport.protocol.base;
    var util = $__require('59');
    var Buffer = $__require('72').Buffer;
    exports.PREFACE_SIZE = 24;
    exports.PREFACE = 'PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n';
    exports.PREFACE_BUFFER = new Buffer(exports.PREFACE);
    exports.PING_OPAQUE_SIZE = 8;
    exports.FRAME_HEADER_SIZE = 9;
    exports.INITIAL_MAX_FRAME_SIZE = 16384;
    exports.ABSOLUTE_MAX_FRAME_SIZE = 16777215;
    exports.HEADER_TABLE_SIZE = 4096;
    exports.DEFAULT_MAX_HEADER_LIST_SIZE = 80 * 1024;
    exports.MAX_INITIAL_WINDOW_SIZE = 2147483647;
    exports.DEFAULT_WEIGHT = 16;
    exports.MAX_CONCURRENT_STREAMS = Infinity;
    exports.frameType = {
      DATA: 0,
      HEADERS: 1,
      PRIORITY: 2,
      RST_STREAM: 3,
      SETTINGS: 4,
      PUSH_PROMISE: 5,
      PING: 6,
      GOAWAY: 7,
      WINDOW_UPDATE: 8,
      CONTINUATION: 9,
      X_FORWARDED_FOR: 0xde
    };
    exports.flags = {
      ACK: 0x01,
      END_STREAM: 0x01,
      END_HEADERS: 0x04,
      PADDED: 0x08,
      PRIORITY: 0x20
    };
    exports.settings = {
      SETTINGS_HEADER_TABLE_SIZE: 0x01,
      SETTINGS_ENABLE_PUSH: 0x02,
      SETTINGS_MAX_CONCURRENT_STREAMS: 0x03,
      SETTINGS_INITIAL_WINDOW_SIZE: 0x04,
      SETTINGS_MAX_FRAME_SIZE: 0x05,
      SETTINGS_MAX_HEADER_LIST_SIZE: 0x06
    };
    exports.settingsIndex = [null, 'header_table_size', 'enable_push', 'max_concurrent_streams', 'initial_window_size', 'max_frame_size', 'max_header_list_size'];
    exports.error = {
      OK: 0,
      NO_ERROR: 0,
      PROTOCOL_ERROR: 1,
      INTERNAL_ERROR: 2,
      FLOW_CONTROL_ERROR: 3,
      SETTINGS_TIMEOUT: 4,
      STREAM_CLOSED: 5,
      INVALID_STREAM: 5,
      FRAME_SIZE_ERROR: 6,
      REFUSED_STREAM: 7,
      CANCEL: 8,
      COMPRESSION_ERROR: 9,
      CONNECT_ERROR: 10,
      ENHANCE_YOUR_CALM: 11,
      INADEQUATE_SECURITY: 12,
      HTTP_1_1_REQUIRED: 13
    };
    exports.errorByCode = base.utils.reverse(exports.error);
    exports.DEFAULT_WINDOW = 64 * 1024 - 1;
    exports.goaway = exports.error;
    exports.goawayByCode = util._extend({}, exports.errorByCode);
    exports.goawayByCode[0] = 'OK';
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a2", ["93", "a3", "71", "59"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var parser = exports;
  var transport = $__require('93');
  var base = transport.protocol.base;
  var utils = base.utils;
  var constants = $__require('a3').constants;
  var assert = $__require('71');
  var util = $__require('59');
  function Parser(options) {
    base.Parser.call(this, options);
    this.isServer = options.isServer;
    this.waiting = constants.PREFACE_SIZE;
    this.state = 'preface';
    this.pendingHeader = null;
    this._lastHeaderBlock = null;
    this.maxFrameSize = constants.INITIAL_MAX_FRAME_SIZE;
    this.maxHeaderListSize = constants.DEFAULT_MAX_HEADER_LIST_SIZE;
  }
  util.inherits(Parser, base.Parser);
  parser.create = function create(options) {
    return new Parser(options);
  };
  Parser.prototype.setMaxFrameSize = function setMaxFrameSize(size) {
    this.maxFrameSize = size;
  };
  Parser.prototype.setMaxHeaderListSize = function setMaxHeaderListSize(size) {
    this.maxHeaderListSize = size;
  };
  Parser.prototype.skipPreface = function skipPreface() {
    this.setVersion(4);
    this.state = 'frame-head';
    this.waiting = constants.FRAME_HEADER_SIZE;
  };
  Parser.prototype.execute = function execute(buffer, callback) {
    if (this.state === 'preface')
      return this.onPreface(buffer, callback);
    if (this.state === 'frame-head')
      return this.onFrameHead(buffer, callback);
    assert(this.state === 'frame-body' && this.pendingHeader !== null);
    var self = this;
    var header = this.pendingHeader;
    this.pendingHeader = null;
    this.onFrameBody(header, buffer, function(err, frame) {
      if (err)
        return callback(err);
      self.state = 'frame-head';
      self.partial = false;
      self.waiting = constants.FRAME_HEADER_SIZE;
      callback(null, frame);
    });
  };
  Parser.prototype.executePartial = function executePartial(buffer, callback) {
    var header = this.pendingHeader;
    assert.equal(header.flags & constants.flags.PADDED, 0);
    if (this.window)
      this.window.recv.update(-buffer.size);
    callback(null, {
      type: 'DATA',
      id: header.id,
      fin: false,
      data: buffer.take(buffer.size)
    });
  };
  Parser.prototype.onPreface = function onPreface(buffer, callback) {
    if (buffer.take(buffer.size).toString() !== constants.PREFACE) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid preface'));
    }
    this.skipPreface();
    callback(null, null);
  };
  Parser.prototype.onFrameHead = function onFrameHead(buffer, callback) {
    var header = {
      length: buffer.readUInt24BE(),
      control: true,
      type: buffer.readUInt8(),
      flags: buffer.readUInt8(),
      id: buffer.readUInt32BE() & 0x7fffffff
    };
    if (header.length > this.maxFrameSize) {
      return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'Frame length OOB'));
    }
    header.control = header.type !== constants.frameType.DATA;
    this.state = 'frame-body';
    this.pendingHeader = header;
    this.waiting = header.length;
    this.partial = !header.control;
    if (this.partial)
      this.partial = (header.flags & constants.flags.PADDED) === 0;
    callback(null, null);
  };
  Parser.prototype.onFrameBody = function onFrameBody(header, buffer, callback) {
    var frameType = constants.frameType;
    if (header.type === frameType.DATA)
      this.onDataFrame(header, buffer, callback);
    else if (header.type === frameType.HEADERS)
      this.onHeadersFrame(header, buffer, callback);
    else if (header.type === frameType.CONTINUATION)
      this.onContinuationFrame(header, buffer, callback);
    else if (header.type === frameType.WINDOW_UPDATE)
      this.onWindowUpdateFrame(header, buffer, callback);
    else if (header.type === frameType.RST_STREAM)
      this.onRSTFrame(header, buffer, callback);
    else if (header.type === frameType.SETTINGS)
      this.onSettingsFrame(header, buffer, callback);
    else if (header.type === frameType.PUSH_PROMISE)
      this.onPushPromiseFrame(header, buffer, callback);
    else if (header.type === frameType.PING)
      this.onPingFrame(header, buffer, callback);
    else if (header.type === frameType.GOAWAY)
      this.onGoawayFrame(header, buffer, callback);
    else if (header.type === frameType.PRIORITY)
      this.onPriorityFrame(header, buffer, callback);
    else if (header.type === frameType.X_FORWARDED_FOR)
      this.onXForwardedFrame(header, buffer, callback);
    else
      this.onUnknownFrame(header, buffer, callback);
  };
  Parser.prototype.onUnknownFrame = function onUnknownFrame(header, buffer, callback) {
    if (this._lastHeaderBlock !== null) {
      callback(this.error(constants.error.PROTOCOL_ERROR, 'Received unknown frame in the middle of a header block'));
      return;
    }
    callback(null, {type: 'unknown: ' + header.type});
  };
  Parser.prototype.unpadData = function unpadData(header, body, callback) {
    var isPadded = (header.flags & constants.flags.PADDED) !== 0;
    if (!isPadded)
      return callback(null, body);
    if (!body.has(1)) {
      return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'Not enough space for padding'));
    }
    var pad = body.readUInt8();
    if (!body.has(pad)) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid padding size'));
    }
    var contents = body.clone(body.size - pad);
    body.skip(body.size);
    callback(null, contents);
  };
  Parser.prototype.onDataFrame = function onDataFrame(header, body, callback) {
    var isEndStream = (header.flags & constants.flags.END_STREAM) !== 0;
    if (header.id === 0) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Received DATA frame with stream=0'));
    }
    if (this.window)
      this.window.recv.update(-body.size);
    this.unpadData(header, body, function(err, data) {
      if (err)
        return callback(err);
      callback(null, {
        type: 'DATA',
        id: header.id,
        fin: isEndStream,
        data: data.take(data.size)
      });
    });
  };
  Parser.prototype.initHeaderBlock = function initHeaderBlock(header, frame, block, callback) {
    if (this._lastHeaderBlock) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Duplicate Stream ID'));
    }
    this._lastHeaderBlock = {
      id: header.id,
      frame: frame,
      queue: [],
      size: 0
    };
    this.queueHeaderBlock(header, block, callback);
  };
  Parser.prototype.queueHeaderBlock = function queueHeaderBlock(header, block, callback) {
    var self = this;
    var item = this._lastHeaderBlock;
    if (!this._lastHeaderBlock || item.id !== header.id) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'No matching stream for continuation'));
    }
    var fin = (header.flags & constants.flags.END_HEADERS) !== 0;
    var chunks = block.toChunks();
    for (var i = 0; i < chunks.length; i++) {
      var chunk = chunks[i];
      item.queue.push(chunk);
      item.size += chunk.length;
    }
    if (item.size >= self.maxHeaderListSize) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Compressed header list is too large'));
    }
    if (!fin)
      return callback(null, null);
    this._lastHeaderBlock = null;
    this.decompress.write(item.queue, function(err, chunks) {
      if (err) {
        return callback(self.error(constants.error.COMPRESSION_ERROR, err.message));
      }
      var headers = {};
      var size = 0;
      for (var i = 0; i < chunks.length; i++) {
        var header = chunks[i];
        size += header.name.length + header.value.length + 32;
        if (size >= self.maxHeaderListSize) {
          return callback(self.error(constants.error.PROTOCOL_ERROR, 'Header list is too large'));
        }
        if (/[A-Z]/.test(header.name)) {
          return callback(self.error(constants.error.PROTOCOL_ERROR, 'Header name must be lowercase'));
        }
        utils.addHeaderLine(header.name, header.value, headers);
      }
      item.frame.headers = headers;
      item.frame.path = headers[':path'];
      callback(null, item.frame);
    });
  };
  Parser.prototype.onHeadersFrame = function onHeadersFrame(header, body, callback) {
    var self = this;
    if (header.id === 0) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for HEADERS'));
    }
    this.unpadData(header, body, function(err, data) {
      if (err)
        return callback(err);
      var isPriority = (header.flags & constants.flags.PRIORITY) !== 0;
      if (!data.has(isPriority ? 5 : 0)) {
        return callback(self.error(constants.error.FRAME_SIZE_ERROR, 'Not enough data for HEADERS'));
      }
      var exclusive = false;
      var dependency = 0;
      var weight = constants.DEFAULT_WEIGHT;
      if (isPriority) {
        dependency = data.readUInt32BE();
        exclusive = (dependency & 0x80000000) !== 0;
        dependency &= 0x7fffffff;
        weight = data.readUInt8() + 1;
      }
      if (dependency === header.id) {
        return callback(self.error(constants.error.PROTOCOL_ERROR, 'Stream can\'t dependend on itself'));
      }
      var streamInfo = {
        type: 'HEADERS',
        id: header.id,
        priority: {
          parent: dependency,
          exclusive: exclusive,
          weight: weight
        },
        fin: (header.flags & constants.flags.END_STREAM) !== 0,
        writable: true,
        headers: null,
        path: null
      };
      self.initHeaderBlock(header, streamInfo, data, callback);
    });
  };
  Parser.prototype.onContinuationFrame = function onContinuationFrame(header, body, callback) {
    this.queueHeaderBlock(header, body, callback);
  };
  Parser.prototype.onRSTFrame = function onRSTFrame(header, body, callback) {
    if (body.size !== 4) {
      return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'RST_STREAM length not 4'));
    }
    if (header.id === 0) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for RST_STREAM'));
    }
    callback(null, {
      type: 'RST',
      id: header.id,
      code: constants.errorByCode[body.readUInt32BE()]
    });
  };
  Parser.prototype._validateSettings = function _validateSettings(settings) {
    if (settings['enable_push'] !== undefined && settings['enable_push'] !== 0 && settings['enable_push'] !== 1)
      return this.error(constants.error.PROTOCOL_ERROR, 'SETTINGS_ENABLE_PUSH must be 0 or 1');
    if (settings['initial_window_size'] !== undefined && (settings['initial_window_size'] > constants.MAX_INITIAL_WINDOW_SIZE || settings['initial_window_size'] < 0))
      return this.error(constants.error.FLOW_CONTROL_ERROR, 'SETTINGS_INITIAL_WINDOW_SIZE is OOB');
    if (settings['max_frame_size'] !== undefined && (settings['max_frame_size'] > constants.ABSOLUTE_MAX_FRAME_SIZE || settings['max_frame_size'] < constants.INITIAL_MAX_FRAME_SIZE))
      return this.error(constants.error.PROTOCOL_ERROR, 'SETTINGS_MAX_FRAME_SIZE is OOB');
    return undefined;
  };
  Parser.prototype.onSettingsFrame = function onSettingsFrame(header, body, callback) {
    if (header.id !== 0) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for SETTINGS'));
    }
    var isAck = (header.flags & constants.flags.ACK) !== 0;
    if (isAck && body.size !== 0) {
      return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'SETTINGS with ACK and non-zero length'));
    }
    if (isAck)
      return callback(null, {type: 'ACK_SETTINGS'});
    if (body.size % 6 !== 0) {
      return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'SETTINGS length not multiple of 6'));
    }
    var settings = {};
    while (!body.isEmpty()) {
      var id = body.readUInt16BE();
      var value = body.readUInt32BE();
      var name = constants.settingsIndex[id];
      if (name)
        settings[name] = value;
    }
    var err = this._validateSettings(settings);
    if (err !== undefined) {
      return callback(err);
    }
    callback(null, {
      type: 'SETTINGS',
      settings: settings
    });
  };
  Parser.prototype.onPushPromiseFrame = function onPushPromiseFrame(header, body, callback) {
    if (header.id === 0) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for PUSH_PROMISE'));
    }
    var self = this;
    this.unpadData(header, body, function(err, data) {
      if (err)
        return callback(err);
      if (!data.has(4)) {
        return callback(self.error(constants.error.FRAME_SIZE_ERROR, 'PUSH_PROMISE length less than 4'));
      }
      var streamInfo = {
        type: 'PUSH_PROMISE',
        id: header.id,
        fin: false,
        promisedId: data.readUInt32BE() & 0x7fffffff,
        headers: null,
        path: null
      };
      self.initHeaderBlock(header, streamInfo, data, callback);
    });
  };
  Parser.prototype.onPingFrame = function onPingFrame(header, body, callback) {
    if (body.size !== 8) {
      return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'PING length != 8'));
    }
    if (header.id !== 0) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for PING'));
    }
    var ack = (header.flags & constants.flags.ACK) !== 0;
    callback(null, {
      type: 'PING',
      opaque: body.take(body.size),
      ack: ack
    });
  };
  Parser.prototype.onGoawayFrame = function onGoawayFrame(header, body, callback) {
    if (!body.has(8)) {
      return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'GOAWAY length < 8'));
    }
    if (header.id !== 0) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for GOAWAY'));
    }
    var frame = {
      type: 'GOAWAY',
      lastId: body.readUInt32BE(),
      code: constants.goawayByCode[body.readUInt32BE()]
    };
    if (body.size !== 0)
      frame.debug = body.take(body.size);
    callback(null, frame);
  };
  Parser.prototype.onPriorityFrame = function onPriorityFrame(header, body, callback) {
    if (body.size !== 5) {
      return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'PRIORITY length != 5'));
    }
    if (header.id === 0) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Invalid stream id for PRIORITY'));
    }
    var dependency = body.readUInt32BE();
    var weight = body.readUInt8() + 1;
    if (dependency === header.id) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'Stream can\'t dependend on itself'));
    }
    callback(null, {
      type: 'PRIORITY',
      id: header.id,
      priority: {
        exclusive: (dependency & 0x80000000) !== 0,
        parent: dependency & 0x7fffffff,
        weight: weight
      }
    });
  };
  Parser.prototype.onWindowUpdateFrame = function onWindowUpdateFrame(header, body, callback) {
    if (body.size !== 4) {
      return callback(this.error(constants.error.FRAME_SIZE_ERROR, 'WINDOW_UPDATE length != 4'));
    }
    var delta = body.readInt32BE();
    if (delta === 0) {
      return callback(this.error(constants.error.PROTOCOL_ERROR, 'WINDOW_UPDATE delta == 0'));
    }
    callback(null, {
      type: 'WINDOW_UPDATE',
      id: header.id,
      delta: delta
    });
  };
  Parser.prototype.onXForwardedFrame = function onXForwardedFrame(header, body, callback) {
    callback(null, {
      type: 'X_FORWARDED_FOR',
      host: body.take(body.size).toString()
    });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a4", ["93", "a3", "71", "59", "9e", "97", "72", "80"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var transport = $__require('93');
    var base = transport.protocol.base;
    var constants = $__require('a3').constants;
    var assert = $__require('71');
    var util = $__require('59');
    var WriteBuffer = $__require('9e');
    var OffsetBuffer = $__require('97');
    var Buffer = $__require('72').Buffer;
    var debug = $__require('80')('spdy:framer');
    var debugExtra = $__require('80')('spdy:framer:extra');
    function Framer(options) {
      base.Framer.call(this, options);
      this.maxFrameSize = constants.INITIAL_MAX_FRAME_SIZE;
    }
    util.inherits(Framer, base.Framer);
    module.exports = Framer;
    Framer.create = function create(options) {
      return new Framer(options);
    };
    Framer.prototype.setMaxFrameSize = function setMaxFrameSize(size) {
      this.maxFrameSize = size;
    };
    Framer.prototype._frame = function _frame(frame, body, callback) {
      debug('id=%d type=%s', frame.id, frame.type);
      var buffer = new WriteBuffer();
      buffer.reserve(constants.FRAME_HEADER_SIZE);
      var len = buffer.skip(3);
      buffer.writeUInt8(constants.frameType[frame.type]);
      buffer.writeUInt8(frame.flags);
      buffer.writeUInt32BE(frame.id & 0x7fffffff);
      body(buffer);
      var frameSize = buffer.size - constants.FRAME_HEADER_SIZE;
      len.writeUInt24BE(frameSize);
      var chunks = buffer.render();
      var toWrite = {
        stream: frame.id,
        priority: frame.priority === undefined ? false : frame.priority,
        chunks: chunks,
        callback: callback
      };
      if (this.window && frame.type === 'DATA') {
        var self = this;
        this._resetTimeout();
        this.window.send.update(-frameSize, function() {
          self._resetTimeout();
          self.schedule(toWrite);
        });
      } else {
        this._resetTimeout();
        this.schedule(toWrite);
      }
      return chunks;
    };
    Framer.prototype._split = function _split(frame) {
      var buf = new OffsetBuffer();
      for (var i = 0; i < frame.chunks.length; i++)
        buf.push(frame.chunks[i]);
      var frames = [];
      while (!buf.isEmpty()) {
        var size = this.maxFrameSize;
        if (frames.length === 0)
          size -= frame.reserve;
        size = Math.min(size, buf.size);
        var frameBuf = buf.clone(size);
        buf.skip(size);
        frames.push({
          size: frameBuf.size,
          chunks: frameBuf.toChunks()
        });
      }
      return frames;
    };
    Framer.prototype._continuationFrame = function _continuationFrame(frame, body, callback) {
      var frames = this._split(frame);
      frames.forEach(function(subFrame, i) {
        var isFirst = i === 0;
        var isLast = i === frames.length - 1;
        var flags = isLast ? constants.flags.END_HEADERS : 0;
        if (isFirst)
          flags |= frame.flags;
        this._frame({
          id: frame.id,
          priority: false,
          type: isFirst ? frame.type : 'CONTINUATION',
          flags: flags
        }, function(buf) {
          if (isFirst && body)
            body(buf);
          buf.reserve(subFrame.size);
          for (var i = 0; i < subFrame.chunks.length; i++)
            buf.copyFrom(subFrame.chunks[i]);
        }, isLast ? callback : null);
      }, this);
      if (frames.length === 0) {
        this._frame({
          id: frame.id,
          priority: false,
          type: frame.type,
          flags: frame.flags | constants.flags.END_HEADERS
        }, function(buf) {
          if (body)
            body(buf);
        }, callback);
      }
    };
    Framer.prototype._compressHeaders = function _compressHeaders(headers, pairs, callback) {
      Object.keys(headers || {}).forEach(function(name) {
        var lowName = name.toLowerCase();
        if (lowName === 'host')
          return;
        if (lowName === 'connection')
          return;
        if (/^:/.test(lowName))
          return;
        var neverIndex = lowName === 'cookie' || lowName === 'set-cookie';
        var value = headers[name];
        if (Array.isArray(value)) {
          for (var i = 0; i < value.length; i++) {
            pairs.push({
              name: lowName,
              value: value[i] + '',
              neverIndex: neverIndex,
              huffman: !neverIndex
            });
          }
        } else {
          pairs.push({
            name: lowName,
            value: value + '',
            neverIndex: neverIndex,
            huffman: !neverIndex
          });
        }
      });
      var self = this;
      assert(this.compress !== null, 'Framer version not initialized');
      debugExtra('compressing headers=%j', pairs);
      this.compress.write([pairs], callback);
    };
    Framer.prototype._isDefaultPriority = function _isDefaultPriority(priority) {
      if (!priority)
        return true;
      return !priority.parent && priority.weight === constants.DEFAULT && !priority.exclusive;
    };
    Framer.prototype._defaultHeaders = function _defaultHeaders(frame, pairs) {
      if (!frame.path)
        throw new Error('`path` is required frame argument');
      pairs.push({
        name: ':method',
        value: frame.method || base.constants.DEFAULT_METHOD
      });
      pairs.push({
        name: ':path',
        value: frame.path
      });
      pairs.push({
        name: ':scheme',
        value: frame.scheme || 'https'
      });
      pairs.push({
        name: ':authority',
        value: frame.host || frame.headers && frame.headers.host || base.constants.DEFAULT_HOST
      });
    };
    Framer.prototype._headersFrame = function _headersFrame(kind, frame, callback) {
      var pairs = [];
      if (kind === 'request') {
        this._defaultHeaders(frame, pairs);
      } else if (kind === 'response') {
        pairs.push({
          name: ':status',
          value: (frame.status || 200) + ''
        });
      }
      var self = this;
      this._compressHeaders(frame.headers, pairs, function(err, chunks) {
        if (err) {
          if (callback)
            return callback(err);
          else
            return self.emit('error', err);
        }
        var reserve = 0;
        var priority = frame.priority;
        if (!self._isDefaultPriority(priority))
          reserve = 5;
        var flags = reserve === 0 ? 0 : constants.flags.PRIORITY;
        if (frame.fin)
          flags |= constants.flags.END_STREAM;
        self._continuationFrame({
          id: frame.id,
          type: 'HEADERS',
          flags: flags,
          reserve: reserve,
          chunks: chunks
        }, function(buf) {
          if (reserve === 0)
            return;
          buf.writeUInt32BE((priority.exclusive ? 0x80000000 : 0) | priority.parent);
          buf.writeUInt8((priority.weight | 0) - 1);
        }, callback);
      });
    };
    Framer.prototype.requestFrame = function requestFrame(frame, callback) {
      return this._headersFrame('request', frame, callback);
    };
    Framer.prototype.responseFrame = function responseFrame(frame, callback) {
      return this._headersFrame('response', frame, callback);
    };
    Framer.prototype.headersFrame = function headersFrame(frame, callback) {
      return this._headersFrame('headers', frame, callback);
    };
    Framer.prototype.pushFrame = function pushFrame(frame, callback) {
      var self = this;
      function compress(headers, pairs, callback) {
        self._compressHeaders(headers, pairs, function(err, chunks) {
          if (err) {
            if (callback)
              return callback(err);
            else
              return self.emit('error', err);
          }
          callback(chunks);
        });
      }
      function sendPromise(chunks) {
        self._continuationFrame({
          id: frame.id,
          type: 'PUSH_PROMISE',
          reserve: 4,
          chunks: chunks
        }, function(buf) {
          buf.writeUInt32BE(frame.promisedId);
        });
      }
      function sendResponse(chunks, callback) {
        var priority = frame.priority;
        var isDefaultPriority = self._isDefaultPriority(priority);
        var flags = isDefaultPriority ? 0 : constants.flags.PRIORITY;
        if (frame.fin)
          flags |= constants.flags.END_STREAM;
        self._continuationFrame({
          id: frame.promisedId,
          type: 'HEADERS',
          flags: flags,
          reserve: isDefaultPriority ? 0 : 5,
          chunks: chunks
        }, function(buf) {
          if (isDefaultPriority)
            return;
          buf.writeUInt32BE((priority.exclusive ? 0x80000000 : 0) | priority.parent);
          buf.writeUInt8((priority.weight | 0) - 1);
        }, callback);
      }
      this._checkPush(function(err) {
        if (err)
          return callback(err);
        var pairs = {
          promise: [],
          response: []
        };
        self._defaultHeaders(frame, pairs.promise);
        pairs.response.push({
          name: ':status',
          value: (frame.status || 200) + ''
        });
        compress(frame.headers, pairs.promise, function(promiseChunks) {
          sendPromise(promiseChunks);
          compress(frame.response, pairs.response, function(responseChunks) {
            sendResponse(responseChunks, callback);
          });
        });
      });
    };
    Framer.prototype.priorityFrame = function priorityFrame(frame, callback) {
      this._frame({
        id: frame.id,
        priority: false,
        type: 'PRIORITY',
        flags: 0
      }, function(buf) {
        var priority = frame.priority;
        buf.writeUInt32BE((priority.exclusive ? 0x80000000 : 0) | priority.parent);
        buf.writeUInt8((priority.weight | 0) - 1);
      }, callback);
    };
    Framer.prototype.dataFrame = function dataFrame(frame, callback) {
      var frames = this._split({
        reserve: 0,
        chunks: [frame.data]
      });
      var fin = frame.fin ? constants.flags.END_STREAM : 0;
      var self = this;
      frames.forEach(function(subFrame, i) {
        var isLast = i === frames.length - 1;
        var flags = 0;
        if (isLast)
          flags |= fin;
        self._frame({
          id: frame.id,
          priority: frame.priority,
          type: 'DATA',
          flags: flags
        }, function(buf) {
          buf.reserve(subFrame.size);
          for (var i = 0; i < subFrame.chunks.length; i++)
            buf.copyFrom(subFrame.chunks[i]);
        }, isLast ? callback : null);
      });
      if (frames.length === 0) {
        this._frame({
          id: frame.id,
          priority: frame.priority,
          type: 'DATA',
          flags: fin
        }, function(buf) {}, callback);
      }
    };
    Framer.prototype.pingFrame = function pingFrame(frame, callback) {
      this._frame({
        id: 0,
        type: 'PING',
        flags: frame.ack ? constants.flags.ACK : 0
      }, function(buf) {
        buf.copyFrom(frame.opaque);
      }, callback);
    };
    Framer.prototype.rstFrame = function rstFrame(frame, callback) {
      this._frame({
        id: frame.id,
        type: 'RST_STREAM',
        flags: 0
      }, function(buf) {
        buf.writeUInt32BE(constants.error[frame.code]);
      }, callback);
    };
    Framer.prototype.prefaceFrame = function prefaceFrame(callback) {
      debug('preface');
      this._resetTimeout();
      this.schedule({
        stream: 0,
        priority: false,
        chunks: [constants.PREFACE_BUFFER],
        callback: callback
      });
    };
    Framer.prototype.settingsFrame = function settingsFrame(options, callback) {
      var key = JSON.stringify(options);
      var settings = Framer.settingsCache[key];
      if (settings) {
        debug('cached settings');
        this._resetTimeout();
        this.schedule({
          id: 0,
          priority: false,
          chunks: settings,
          callback: callback
        });
        return;
      }
      var params = [];
      for (var i = 0; i < constants.settingsIndex.length; i++) {
        var name = constants.settingsIndex[i];
        if (!name)
          continue;
        if (!isFinite(options[name]))
          continue;
        if (options[name] !== undefined)
          params.push({
            key: i,
            value: options[name]
          });
      }
      var bodySize = params.length * 6;
      var chunks = this._frame({
        id: 0,
        type: 'SETTINGS',
        flags: 0
      }, function(buffer) {
        buffer.reserve(bodySize);
        for (var i = 0; i < params.length; i++) {
          var param = params[i];
          buffer.writeUInt16BE(param.key);
          buffer.writeUInt32BE(param.value);
        }
      }, callback);
      Framer.settingsCache[key] = chunks;
    };
    Framer.settingsCache = {};
    Framer.prototype.ackSettingsFrame = function ackSettingsFrame(callback) {
      var chunks = this._frame({
        id: 0,
        type: 'SETTINGS',
        flags: constants.flags.ACK
      }, function(buffer) {}, callback);
    };
    Framer.prototype.windowUpdateFrame = function windowUpdateFrame(frame, callback) {
      this._frame({
        id: frame.id,
        type: 'WINDOW_UPDATE',
        flags: 0
      }, function(buffer) {
        buffer.reserve(4);
        buffer.writeInt32BE(frame.delta);
      }, callback);
    };
    Framer.prototype.goawayFrame = function goawayFrame(frame, callback) {
      this._frame({
        type: 'GOAWAY',
        id: 0,
        flags: 0
      }, function(buf) {
        buf.reserve(8);
        buf.writeUInt32BE(frame.lastId & 0x7fffffff);
        buf.writeUInt32BE(constants.goaway[frame.code]);
        if (frame.extra)
          buf.write(frame.extra);
      }, callback);
    };
    Framer.prototype.xForwardedFor = function xForwardedFor(frame, callback) {
      this._frame({
        type: 'X_FORWARDED_FOR',
        id: 0,
        flags: 0
      }, function(buf) {
        buf.write(frame.host);
      }, callback);
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a5", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.assert = function assert(cond, text) {
    if (!cond)
      throw new Error(text);
  };
  exports.stringify = function stringify(arr) {
    var res = '';
    for (var i = 0; i < arr.length; i++)
      res += String.fromCharCode(arr[i]);
    return res;
  };
  exports.toArray = function toArray(str) {
    var res = [];
    for (var i = 0; i < str.length; i++) {
      var c = str.charCodeAt(i);
      var hi = c >>> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
    return res;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a6", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.decode = [2608, 2609, 2610, 2657, 2659, 2661, 2665, 2671, 2675, 2676, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3104, 3109, 3117, 3118, 3119, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3133, 3137, 3167, 3170, 3172, 3174, 3175, 3176, 3180, 3181, 3182, 3184, 3186, 3189, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3642, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3673, 3690, 3691, 3697, 3702, 3703, 3704, 3705, 3706, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4134, 4138, 4140, 4155, 4184, 4186, [1057, 1058, 1064, 1065, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1087, 0, 1575, 1579, 1660, 0, 0, 0, 0, 0, 2083, 2110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2560, 2596, 2624, 2651, 2653, 2686, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3166, 3197, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3644, 3680, 3707, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, [1628, 1731, 1744, 0, 0, 0, 2176, 2178, 2179, 2210, 2232, 2242, 2272, 2274, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2713, 2721, 2727, 2732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2736, 2737, 2739, 2769, 2776, 2777, 2787, 2789, 2790, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3201, 3204, 3205, 3206, 3208, 3218, 3226, 3228, 3232, 3235, 3236, 3241, 3242, 3245, 3250, 3253, 3257, 3258, 3259, 3261, 3262, 3268, 3270, 3300, 3304, 3305, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3585, 3719, 3721, 3722, 3723, 3724, 3725, 3727, 3731, 3733, 3734, 3735, 3736, 3739, 3741, 3742, 3749, 3750, 3752, 3758, 3759, 3764, 3766, 3767, 3772, 3775, 3781, 3815, 3823, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4105, 4238, 4240, 4241, 4244, 4255, 4267, 4302, 4311, 4321, 4332, 4333, [711, 719, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [746, 747, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1216, 1217, 1224, 1225, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1226, 1229, 1234, 1237, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1242, 1243, 1262, 1264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1266, 1267, 1279, 0, 0, 0, 1739, 1740, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1747, 1748, 1750, 1757, 1758, 1759, 1777, 1780, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1781, 1782, 1783, 1784, 1786, 1787, 1788, 1789, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1790, 0, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2059, 2060, 2062, 2063, 2064, 2065, 2066, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2067, 2068, 2069, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2175, 2268, 2297, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3082, 3085, 3094, 3328, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]];
  exports.encode = [[13, 8184], [23, 8388568], [28, 268435426], [28, 268435427], [28, 268435428], [28, 268435429], [28, 268435430], [28, 268435431], [28, 268435432], [24, 16777194], [30, 1073741820], [28, 268435433], [28, 268435434], [30, 1073741821], [28, 268435435], [28, 268435436], [28, 268435437], [28, 268435438], [28, 268435439], [28, 268435440], [28, 268435441], [28, 268435442], [30, 1073741822], [28, 268435443], [28, 268435444], [28, 268435445], [28, 268435446], [28, 268435447], [28, 268435448], [28, 268435449], [28, 268435450], [28, 268435451], [6, 20], [10, 1016], [10, 1017], [12, 4090], [13, 8185], [6, 21], [8, 248], [11, 2042], [10, 1018], [10, 1019], [8, 249], [11, 2043], [8, 250], [6, 22], [6, 23], [6, 24], [5, 0], [5, 1], [5, 2], [6, 25], [6, 26], [6, 27], [6, 28], [6, 29], [6, 30], [6, 31], [7, 92], [8, 251], [15, 32764], [6, 32], [12, 4091], [10, 1020], [13, 8186], [6, 33], [7, 93], [7, 94], [7, 95], [7, 96], [7, 97], [7, 98], [7, 99], [7, 100], [7, 101], [7, 102], [7, 103], [7, 104], [7, 105], [7, 106], [7, 107], [7, 108], [7, 109], [7, 110], [7, 111], [7, 112], [7, 113], [7, 114], [8, 252], [7, 115], [8, 253], [13, 8187], [19, 524272], [13, 8188], [14, 16380], [6, 34], [15, 32765], [5, 3], [6, 35], [5, 4], [6, 36], [5, 5], [6, 37], [6, 38], [6, 39], [5, 6], [7, 116], [7, 117], [6, 40], [6, 41], [6, 42], [5, 7], [6, 43], [7, 118], [6, 44], [5, 8], [5, 9], [6, 45], [7, 119], [7, 120], [7, 121], [7, 122], [7, 123], [15, 32766], [11, 2044], [14, 16381], [13, 8189], [28, 268435452], [20, 1048550], [22, 4194258], [20, 1048551], [20, 1048552], [22, 4194259], [22, 4194260], [22, 4194261], [23, 8388569], [22, 4194262], [23, 8388570], [23, 8388571], [23, 8388572], [23, 8388573], [23, 8388574], [24, 16777195], [23, 8388575], [24, 16777196], [24, 16777197], [22, 4194263], [23, 8388576], [24, 16777198], [23, 8388577], [23, 8388578], [23, 8388579], [23, 8388580], [21, 2097116], [22, 4194264], [23, 8388581], [22, 4194265], [23, 8388582], [23, 8388583], [24, 16777199], [22, 4194266], [21, 2097117], [20, 1048553], [22, 4194267], [22, 4194268], [23, 8388584], [23, 8388585], [21, 2097118], [23, 8388586], [22, 4194269], [22, 4194270], [24, 16777200], [21, 2097119], [22, 4194271], [23, 8388587], [23, 8388588], [21, 2097120], [21, 2097121], [22, 4194272], [21, 2097122], [23, 8388589], [22, 4194273], [23, 8388590], [23, 8388591], [20, 1048554], [22, 4194274], [22, 4194275], [22, 4194276], [23, 8388592], [22, 4194277], [22, 4194278], [23, 8388593], [26, 67108832], [26, 67108833], [20, 1048555], [19, 524273], [22, 4194279], [23, 8388594], [22, 4194280], [25, 33554412], [26, 67108834], [26, 67108835], [26, 67108836], [27, 134217694], [27, 134217695], [26, 67108837], [24, 16777201], [25, 33554413], [19, 524274], [21, 2097123], [26, 67108838], [27, 134217696], [27, 134217697], [26, 67108839], [27, 134217698], [24, 16777202], [21, 2097124], [21, 2097125], [26, 67108840], [26, 67108841], [28, 268435453], [27, 134217699], [27, 134217700], [27, 134217701], [20, 1048556], [24, 16777203], [20, 1048557], [21, 2097126], [22, 4194281], [21, 2097127], [21, 2097128], [23, 8388595], [22, 4194282], [22, 4194283], [25, 33554414], [25, 33554415], [24, 16777204], [24, 16777205], [26, 67108842], [23, 8388596], [26, 67108843], [27, 134217702], [26, 67108844], [26, 67108845], [27, 134217703], [27, 134217704], [27, 134217705], [27, 134217706], [27, 134217707], [28, 268435454], [27, 134217708], [27, 134217709], [27, 134217710], [27, 134217711], [27, 134217712], [26, 67108846], [30, 1073741823]];
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a7", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.table = [{
    "name": ":authority",
    "value": "",
    "nameSize": 10,
    "totalSize": 42
  }, {
    "name": ":method",
    "value": "GET",
    "nameSize": 7,
    "totalSize": 42
  }, {
    "name": ":method",
    "value": "POST",
    "nameSize": 7,
    "totalSize": 43
  }, {
    "name": ":path",
    "value": "/",
    "nameSize": 5,
    "totalSize": 38
  }, {
    "name": ":path",
    "value": "/index.html",
    "nameSize": 5,
    "totalSize": 48
  }, {
    "name": ":scheme",
    "value": "http",
    "nameSize": 7,
    "totalSize": 43
  }, {
    "name": ":scheme",
    "value": "https",
    "nameSize": 7,
    "totalSize": 44
  }, {
    "name": ":status",
    "value": "200",
    "nameSize": 7,
    "totalSize": 42
  }, {
    "name": ":status",
    "value": "204",
    "nameSize": 7,
    "totalSize": 42
  }, {
    "name": ":status",
    "value": "206",
    "nameSize": 7,
    "totalSize": 42
  }, {
    "name": ":status",
    "value": "304",
    "nameSize": 7,
    "totalSize": 42
  }, {
    "name": ":status",
    "value": "400",
    "nameSize": 7,
    "totalSize": 42
  }, {
    "name": ":status",
    "value": "404",
    "nameSize": 7,
    "totalSize": 42
  }, {
    "name": ":status",
    "value": "500",
    "nameSize": 7,
    "totalSize": 42
  }, {
    "name": "accept-charset",
    "value": "",
    "nameSize": 14,
    "totalSize": 46
  }, {
    "name": "accept-encoding",
    "value": "gzip, deflate",
    "nameSize": 15,
    "totalSize": 60
  }, {
    "name": "accept-language",
    "value": "",
    "nameSize": 15,
    "totalSize": 47
  }, {
    "name": "accept-ranges",
    "value": "",
    "nameSize": 13,
    "totalSize": 45
  }, {
    "name": "accept",
    "value": "",
    "nameSize": 6,
    "totalSize": 38
  }, {
    "name": "access-control-allow-origin",
    "value": "",
    "nameSize": 27,
    "totalSize": 59
  }, {
    "name": "age",
    "value": "",
    "nameSize": 3,
    "totalSize": 35
  }, {
    "name": "allow",
    "value": "",
    "nameSize": 5,
    "totalSize": 37
  }, {
    "name": "authorization",
    "value": "",
    "nameSize": 13,
    "totalSize": 45
  }, {
    "name": "cache-control",
    "value": "",
    "nameSize": 13,
    "totalSize": 45
  }, {
    "name": "content-disposition",
    "value": "",
    "nameSize": 19,
    "totalSize": 51
  }, {
    "name": "content-encoding",
    "value": "",
    "nameSize": 16,
    "totalSize": 48
  }, {
    "name": "content-language",
    "value": "",
    "nameSize": 16,
    "totalSize": 48
  }, {
    "name": "content-length",
    "value": "",
    "nameSize": 14,
    "totalSize": 46
  }, {
    "name": "content-location",
    "value": "",
    "nameSize": 16,
    "totalSize": 48
  }, {
    "name": "content-range",
    "value": "",
    "nameSize": 13,
    "totalSize": 45
  }, {
    "name": "content-type",
    "value": "",
    "nameSize": 12,
    "totalSize": 44
  }, {
    "name": "cookie",
    "value": "",
    "nameSize": 6,
    "totalSize": 38
  }, {
    "name": "date",
    "value": "",
    "nameSize": 4,
    "totalSize": 36
  }, {
    "name": "etag",
    "value": "",
    "nameSize": 4,
    "totalSize": 36
  }, {
    "name": "expect",
    "value": "",
    "nameSize": 6,
    "totalSize": 38
  }, {
    "name": "expires",
    "value": "",
    "nameSize": 7,
    "totalSize": 39
  }, {
    "name": "from",
    "value": "",
    "nameSize": 4,
    "totalSize": 36
  }, {
    "name": "host",
    "value": "",
    "nameSize": 4,
    "totalSize": 36
  }, {
    "name": "if-match",
    "value": "",
    "nameSize": 8,
    "totalSize": 40
  }, {
    "name": "if-modified-since",
    "value": "",
    "nameSize": 17,
    "totalSize": 49
  }, {
    "name": "if-none-match",
    "value": "",
    "nameSize": 13,
    "totalSize": 45
  }, {
    "name": "if-range",
    "value": "",
    "nameSize": 8,
    "totalSize": 40
  }, {
    "name": "if-unmodified-since",
    "value": "",
    "nameSize": 19,
    "totalSize": 51
  }, {
    "name": "last-modified",
    "value": "",
    "nameSize": 13,
    "totalSize": 45
  }, {
    "name": "link",
    "value": "",
    "nameSize": 4,
    "totalSize": 36
  }, {
    "name": "location",
    "value": "",
    "nameSize": 8,
    "totalSize": 40
  }, {
    "name": "max-forwards",
    "value": "",
    "nameSize": 12,
    "totalSize": 44
  }, {
    "name": "proxy-authenticate",
    "value": "",
    "nameSize": 18,
    "totalSize": 50
  }, {
    "name": "proxy-authorization",
    "value": "",
    "nameSize": 19,
    "totalSize": 51
  }, {
    "name": "range",
    "value": "",
    "nameSize": 5,
    "totalSize": 37
  }, {
    "name": "referer",
    "value": "",
    "nameSize": 7,
    "totalSize": 39
  }, {
    "name": "refresh",
    "value": "",
    "nameSize": 7,
    "totalSize": 39
  }, {
    "name": "retry-after",
    "value": "",
    "nameSize": 11,
    "totalSize": 43
  }, {
    "name": "server",
    "value": "",
    "nameSize": 6,
    "totalSize": 38
  }, {
    "name": "set-cookie",
    "value": "",
    "nameSize": 10,
    "totalSize": 42
  }, {
    "name": "strict-transport-security",
    "value": "",
    "nameSize": 25,
    "totalSize": 57
  }, {
    "name": "transfer-encoding",
    "value": "",
    "nameSize": 17,
    "totalSize": 49
  }, {
    "name": "user-agent",
    "value": "",
    "nameSize": 10,
    "totalSize": 42
  }, {
    "name": "vary",
    "value": "",
    "nameSize": 4,
    "totalSize": 36
  }, {
    "name": "via",
    "value": "",
    "nameSize": 3,
    "totalSize": 35
  }, {
    "name": "www-authenticate",
    "value": "",
    "nameSize": 16,
    "totalSize": 48
  }];
  exports.map = {
    ":authority": {
      "index": 1,
      "values": {"": 1}
    },
    ":method": {
      "index": 2,
      "values": {
        "GET": 2,
        "POST": 3
      }
    },
    ":path": {
      "index": 4,
      "values": {
        "/": 4,
        "/index.html": 5
      }
    },
    ":scheme": {
      "index": 6,
      "values": {
        "http": 6,
        "https": 7
      }
    },
    ":status": {
      "index": 8,
      "values": {
        "200": 8,
        "204": 9,
        "206": 10,
        "304": 11,
        "400": 12,
        "404": 13,
        "500": 14
      }
    },
    "accept-charset": {
      "index": 15,
      "values": {"": 15}
    },
    "accept-encoding": {
      "index": 16,
      "values": {"gzip, deflate": 16}
    },
    "accept-language": {
      "index": 17,
      "values": {"": 17}
    },
    "accept-ranges": {
      "index": 18,
      "values": {"": 18}
    },
    "accept": {
      "index": 19,
      "values": {"": 19}
    },
    "access-control-allow-origin": {
      "index": 20,
      "values": {"": 20}
    },
    "age": {
      "index": 21,
      "values": {"": 21}
    },
    "allow": {
      "index": 22,
      "values": {"": 22}
    },
    "authorization": {
      "index": 23,
      "values": {"": 23}
    },
    "cache-control": {
      "index": 24,
      "values": {"": 24}
    },
    "content-disposition": {
      "index": 25,
      "values": {"": 25}
    },
    "content-encoding": {
      "index": 26,
      "values": {"": 26}
    },
    "content-language": {
      "index": 27,
      "values": {"": 27}
    },
    "content-length": {
      "index": 28,
      "values": {"": 28}
    },
    "content-location": {
      "index": 29,
      "values": {"": 29}
    },
    "content-range": {
      "index": 30,
      "values": {"": 30}
    },
    "content-type": {
      "index": 31,
      "values": {"": 31}
    },
    "cookie": {
      "index": 32,
      "values": {"": 32}
    },
    "date": {
      "index": 33,
      "values": {"": 33}
    },
    "etag": {
      "index": 34,
      "values": {"": 34}
    },
    "expect": {
      "index": 35,
      "values": {"": 35}
    },
    "expires": {
      "index": 36,
      "values": {"": 36}
    },
    "from": {
      "index": 37,
      "values": {"": 37}
    },
    "host": {
      "index": 38,
      "values": {"": 38}
    },
    "if-match": {
      "index": 39,
      "values": {"": 39}
    },
    "if-modified-since": {
      "index": 40,
      "values": {"": 40}
    },
    "if-none-match": {
      "index": 41,
      "values": {"": 41}
    },
    "if-range": {
      "index": 42,
      "values": {"": 42}
    },
    "if-unmodified-since": {
      "index": 43,
      "values": {"": 43}
    },
    "last-modified": {
      "index": 44,
      "values": {"": 44}
    },
    "link": {
      "index": 45,
      "values": {"": 45}
    },
    "location": {
      "index": 46,
      "values": {"": 46}
    },
    "max-forwards": {
      "index": 47,
      "values": {"": 47}
    },
    "proxy-authenticate": {
      "index": 48,
      "values": {"": 48}
    },
    "proxy-authorization": {
      "index": 49,
      "values": {"": 49}
    },
    "range": {
      "index": 50,
      "values": {"": 50}
    },
    "referer": {
      "index": 51,
      "values": {"": 51}
    },
    "refresh": {
      "index": 52,
      "values": {"": 52}
    },
    "retry-after": {
      "index": 53,
      "values": {"": 53}
    },
    "server": {
      "index": 54,
      "values": {"": 54}
    },
    "set-cookie": {
      "index": 55,
      "values": {"": 55}
    },
    "strict-transport-security": {
      "index": 56,
      "values": {"": 56}
    },
    "transfer-encoding": {
      "index": 57,
      "values": {"": 57}
    },
    "user-agent": {
      "index": 58,
      "values": {"": 58}
    },
    "vary": {
      "index": 59,
      "values": {"": 59}
    },
    "via": {
      "index": 60,
      "values": {"": 60}
    },
    "www-authenticate": {
      "index": 61,
      "values": {"": 61}
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a8", ["a9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hpack = $__require('a9');
  var utils = hpack.utils;
  var assert = utils.assert;
  function Table(options) {
    this['static'] = hpack['static-table'];
    this.dynamic = [];
    this.size = 0;
    this.maxSize = 0;
    this.length = this['static'].table.length;
    this.protocolMaxSize = options.maxSize;
    this.maxSize = this.protocolMaxSize;
    this.lookupDepth = options.lookupDepth || 32;
  }
  module.exports = Table;
  Table.create = function create(options) {
    return new Table(options);
  };
  Table.prototype.lookup = function lookup(index) {
    assert(index !== 0, 'Zero indexed field');
    assert(index <= this.length, 'Indexed field OOB');
    if (index <= this['static'].table.length)
      return this['static'].table[index - 1];
    else
      return this.dynamic[this.length - index];
  };
  Table.prototype.reverseLookup = function reverseLookup(name, value) {
    var staticEntry = this['static'].map[name];
    if (staticEntry && staticEntry.values[value])
      return staticEntry.values[value];
    var limit = Math.max(0, this.dynamic.length - this.lookupDepth);
    for (var i = this.dynamic.length - 1; i >= limit; i--) {
      var entry = this.dynamic[i];
      if (entry.name === name && entry.value === value)
        return this.length - i;
      if (entry.name === name) {
        if (staticEntry)
          break;
        return -(this.length - i);
      }
    }
    if (staticEntry)
      return -staticEntry.index;
    return 0;
  };
  Table.prototype.add = function add(name, value, nameSize, valueSize) {
    var totalSize = nameSize + valueSize + 32;
    this.dynamic.push({
      name: name,
      value: value,
      nameSize: nameSize,
      totalSize: totalSize
    });
    this.size += totalSize;
    this.length++;
    this.evict();
  };
  Table.prototype.evict = function evict() {
    while (this.size > this.maxSize) {
      var entry = this.dynamic.shift();
      this.size -= entry.totalSize;
      this.length--;
    }
    assert(this.size >= 0, 'Table size sanity check failed');
  };
  Table.prototype.updateSize = function updateSize(size) {
    assert(size <= this.protocolMaxSize, 'Table size bigger than maximum');
    this.maxSize = size;
    this.evict();
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("aa", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var Buffer = $__require('72').Buffer;
    function OffsetBuffer() {
      this.offset = 0;
      this.size = 0;
      this.buffers = [];
    }
    module.exports = OffsetBuffer;
    OffsetBuffer.prototype.isEmpty = function isEmpty() {
      return this.size === 0;
    };
    OffsetBuffer.prototype.clone = function clone(size) {
      var r = new OffsetBuffer();
      r.offset = this.offset;
      r.size = size;
      r.buffers = this.buffers.slice();
      return r;
    };
    OffsetBuffer.prototype.toChunks = function toChunks() {
      if (this.size === 0)
        return [];
      if (this.offset !== 0) {
        this.buffers[0] = this.buffers[0].slice(this.offset);
        this.offset = 0;
      }
      var chunks = [];
      var off = 0;
      for (var i = 0; off <= this.size && i < this.buffers.length; i++) {
        var buf = this.buffers[i];
        off += buf.length;
        if (off > this.size) {
          buf = buf.slice(0, buf.length - (off - this.size));
          this.buffers[i] = buf;
        }
        chunks.push(buf);
      }
      if (i < this.buffers.length)
        this.buffers.length = i;
      return chunks;
    };
    OffsetBuffer.prototype.toString = function toString(enc) {
      return this.toChunks().map(function(c) {
        return c.toString(enc);
      }).join('');
    };
    OffsetBuffer.prototype.use = function use(buf, off, n) {
      this.buffers = [buf];
      this.offset = off;
      this.size = n;
    };
    OffsetBuffer.prototype.push = function push(data) {
      if (data.length === 0)
        return;
      this.size += data.length;
      this.buffers.push(data);
    };
    OffsetBuffer.prototype.has = function has(n) {
      return this.size >= n;
    };
    OffsetBuffer.prototype.skip = function skip(n) {
      if (this.size === 0)
        return;
      this.size -= n;
      if (this.offset + n < this.buffers[0].length) {
        this.offset += n;
        return;
      }
      var left = n - (this.buffers[0].length - this.offset);
      this.offset = 0;
      for (var shift = 1; left > 0 && shift < this.buffers.length; shift++) {
        var buf = this.buffers[shift];
        if (buf.length > left) {
          this.offset = left;
          break;
        }
        left -= buf.length;
      }
      this.buffers = this.buffers.slice(shift);
    };
    OffsetBuffer.prototype.copy = function copy(target, targetOff, off, n) {
      if (this.size === 0)
        return;
      if (off !== 0)
        throw new Error('Unsupported offset in .copy()');
      var toff = targetOff;
      var first = this.buffers[0];
      var toCopy = Math.min(n, first.length - this.offset);
      first.copy(target, toff, this.offset, this.offset + toCopy);
      toff += toCopy;
      var left = n - toCopy;
      for (var i = 1; left > 0 && i < this.buffers.length; i++) {
        var buf = this.buffers[i];
        var toCopy = Math.min(left, buf.length);
        buf.copy(target, toff, 0, toCopy);
        toff += toCopy;
        left -= toCopy;
      }
    };
    OffsetBuffer.prototype.take = function take(n) {
      if (n === 0)
        return new Buffer(0);
      this.size -= n;
      var first = this.buffers[0].length - this.offset;
      if (first === n) {
        var r = this.buffers.shift();
        if (this.offset !== 0) {
          r = r.slice(this.offset);
          this.offset = 0;
        }
        return r;
      } else if (first > n) {
        var r = this.buffers[0].slice(this.offset, this.offset + n);
        this.offset += n;
        return r;
      }
      var out = new Buffer(n);
      var toOff = 0;
      var startOff = this.offset;
      for (var i = 0; toOff !== n && i < this.buffers.length; i++) {
        var buf = this.buffers[i];
        var toCopy = Math.min(buf.length - startOff, n - toOff);
        buf.copy(out, toOff, startOff, startOff + toCopy);
        if (startOff + toCopy < buf.length) {
          this.offset = startOff + toCopy;
          break;
        } else {
          toOff += toCopy;
          startOff = 0;
        }
      }
      this.buffers = this.buffers.slice(i);
      if (this.buffers.length === 0)
        this.offset = 0;
      return out;
    };
    OffsetBuffer.prototype.peekUInt8 = function peekUInt8() {
      return this.buffers[0][this.offset];
    };
    OffsetBuffer.prototype.readUInt8 = function readUInt8() {
      this.size -= 1;
      var first = this.buffers[0];
      var r = first[this.offset];
      if (++this.offset === first.length) {
        this.offset = 0;
        this.buffers.shift();
      }
      return r;
    };
    OffsetBuffer.prototype.readUInt16LE = function readUInt16LE() {
      var first = this.buffers[0];
      this.size -= 2;
      var r;
      var shift;
      if (first.length - this.offset >= 2) {
        r = first.readUInt16LE(this.offset, true);
        shift = 0;
        this.offset += 2;
      } else {
        r = first[this.offset] | (this.buffers[1][0] << 8);
        shift = 1;
        this.offset = 1;
      }
      if (this.offset === this.buffers[shift].length) {
        this.offset = 0;
        shift++;
      }
      if (shift !== 0)
        this.buffers = this.buffers.slice(shift);
      return r;
    };
    OffsetBuffer.prototype.readUInt24LE = function readUInt24LE() {
      var first = this.buffers[0];
      var r;
      var shift;
      var firstHas = first.length - this.offset;
      if (firstHas >= 3) {
        r = first.readUInt16LE(this.offset, true) | (first[this.offset + 2] << 16);
        shift = 0;
        this.offset += 3;
      } else if (firstHas >= 2) {
        r = first.readUInt16LE(this.offset, true) | (this.buffers[1][0] << 16);
        shift = 1;
        this.offset = 1;
      } else {
        r = first[this.offset];
        this.offset = 0;
        this.buffers.shift();
        this.size -= 1;
        r |= this.readUInt16LE() << 8;
        return r;
      }
      this.size -= 3;
      if (this.offset === this.buffers[shift].length) {
        this.offset = 0;
        shift++;
      }
      if (shift !== 0)
        this.buffers = this.buffers.slice(shift);
      return r;
    };
    OffsetBuffer.prototype.readUInt32LE = function readUInt32LE() {
      var first = this.buffers[0];
      var r;
      var shift;
      var firstHas = first.length - this.offset;
      if (firstHas >= 4) {
        r = first.readUInt32LE(this.offset, true);
        shift = 0;
        this.offset += 4;
      } else if (firstHas >= 3) {
        r = (first.readUInt16LE(this.offset, true) | (first[this.offset + 2] << 16)) + (this.buffers[1][0] * 0x1000000);
        shift = 1;
        this.offset = 1;
      } else if (firstHas >= 2) {
        r = first.readUInt16LE(this.offset, true);
        this.offset = 0;
        this.buffers.shift();
        this.size -= 2;
        r += this.readUInt16LE() * 0x10000;
        return r;
      } else {
        r = first[this.offset];
        this.offset = 0;
        this.buffers.shift();
        this.size -= 1;
        r += this.readUInt24LE() * 0x100;
        return r;
      }
      this.size -= 4;
      if (this.offset === this.buffers[shift].length) {
        this.offset = 0;
        shift++;
      }
      if (shift !== 0)
        this.buffers = this.buffers.slice(shift);
      return r;
    };
    OffsetBuffer.prototype.readUInt16BE = function readUInt16BE() {
      var r = this.readUInt16LE();
      return ((r & 0xff) << 8) | (r >> 8);
    };
    OffsetBuffer.prototype.readUInt24BE = function readUInt24BE() {
      var r = this.readUInt24LE();
      return ((r & 0xff) << 16) | (((r >> 8) & 0xff) << 8) | (r >> 16);
    };
    OffsetBuffer.prototype.readUInt32BE = function readUInt32BE() {
      var r = this.readUInt32LE();
      return (((r & 0xff) << 24) | (((r >>> 8) & 0xff) << 16) | (((r >>> 16) & 0xff) << 8) | (r >>> 24)) >>> 0;
    };
    function signedInt8(num) {
      if (num >= 0x80)
        return -(0xff ^ num) - 1;
      else
        return num;
    }
    OffsetBuffer.prototype.peekInt8 = function peekInt8() {
      return signedInt8(this.peekUInt8());
    };
    OffsetBuffer.prototype.readInt8 = function readInt8() {
      return signedInt8(this.readUInt8());
    };
    function signedInt16(num) {
      if (num >= 0x8000)
        return -(0xffff ^ num) - 1;
      else
        return num;
    }
    OffsetBuffer.prototype.readInt16BE = function readInt16BE() {
      return signedInt16(this.readUInt16BE());
    };
    OffsetBuffer.prototype.readInt16LE = function readInt16LE() {
      return signedInt16(this.readUInt16LE());
    };
    function signedInt24(num) {
      if (num >= 0x800000)
        return -(0xffffff ^ num) - 1;
      else
        return num;
    }
    OffsetBuffer.prototype.readInt24BE = function readInt24BE() {
      return signedInt24(this.readUInt24BE());
    };
    OffsetBuffer.prototype.readInt24LE = function readInt24LE() {
      return signedInt24(this.readUInt24LE());
    };
    function signedInt32(num) {
      if (num >= 0x80000000)
        return -(0xffffffff ^ num) - 1;
      else
        return num;
    }
    OffsetBuffer.prototype.readInt32BE = function readInt32BE() {
      return signedInt32(this.readUInt32BE());
    };
    OffsetBuffer.prototype.readInt32LE = function readInt32LE() {
      return signedInt32(this.readUInt32LE());
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("97", ["aa"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('aa');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ab", ["a9", "97", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var hpack = $__require('a9');
    var utils = hpack.utils;
    var huffman = hpack.huffman.decode;
    var assert = utils.assert;
    var OffsetBuffer = $__require('97');
    function Decoder() {
      this.buffer = new OffsetBuffer();
      this.bitOffset = 0;
      this._huffmanNode = null;
    }
    module.exports = Decoder;
    Decoder.create = function create() {
      return new Decoder();
    };
    Decoder.prototype.isEmpty = function isEmpty() {
      return this.buffer.isEmpty();
    };
    Decoder.prototype.push = function push(chunk) {
      this.buffer.push(chunk);
    };
    Decoder.prototype.decodeBit = function decodeBit() {
      assert(this.buffer.has(1), 'Buffer too small for an int');
      var octet;
      var offset = this.bitOffset;
      if (++this.bitOffset === 8) {
        octet = this.buffer.readUInt8();
        this.bitOffset = 0;
      } else {
        octet = this.buffer.peekUInt8();
      }
      return (octet >>> (7 - offset)) & 1;
    };
    Decoder.prototype.skipBits = function skipBits(n) {
      this.bitOffset += n;
      this.buffer.skip(this.bitOffset >> 3);
      this.bitOffset &= 0x7;
    };
    Decoder.prototype.decodeInt = function decodeInt() {
      assert(this.buffer.has(1), 'Buffer too small for an int');
      var prefix = 8 - this.bitOffset;
      this.bitOffset = 0;
      var max = (1 << prefix) - 1;
      var octet = this.buffer.readUInt8() & max;
      if (octet !== max)
        return octet;
      var res = 0;
      var isLast = false;
      var len = 0;
      do {
        octet = this.buffer.readUInt8();
        isLast = (octet & 0x80) === 0;
        res <<= 7;
        res |= octet & 0x7f;
        len++;
      } while (!isLast);
      assert(isLast, 'Incomplete data for multi-octet integer');
      assert(len <= 4, 'Integer does not fit into 32 bits');
      res = (res >>> 21) | (((res >> 14) & 0x7f) << 7) | (((res >> 7) & 0x7f) << 14) | ((res & 0x7f) << 21);
      res >>= (4 - len) * 7;
      res += max;
      return res;
    };
    Decoder.prototype.decodeHuffmanWord = function decodeHuffmanWord(input, inputBits, out) {
      var root = huffman;
      var node = this._huffmanNode;
      var word = input;
      var bits = inputBits;
      for (; bits > 0; word &= (1 << bits) - 1) {
        for (var i = Math.max(0, bits - 8); i < bits; i++) {
          var subnode = node[word >>> i];
          if (typeof subnode !== 'number') {
            node = subnode;
            bits = i;
            break;
          }
          if (subnode === 0)
            continue;
          if ((subnode >>> 9) !== bits - i) {
            subnode = 0;
            continue;
          }
          var octet = subnode & 0x1ff;
          assert(octet !== 256, 'EOS in encoding');
          out.push(octet);
          node = root;
          bits = i;
          break;
        }
        if (subnode === 0)
          break;
      }
      this._huffmanNode = node;
      return bits;
    };
    Decoder.prototype.decodeStr = function decodeStr() {
      var isHuffman = this.decodeBit();
      var len = this.decodeInt();
      assert(this.buffer.has(len), 'Not enough octets for string');
      if (!isHuffman)
        return this.buffer.take(len);
      this._huffmanNode = huffman;
      var out = [];
      var word = 0;
      var bits = 0;
      var lastKey = 0;
      for (var i = 0; i < len; i++) {
        word <<= 8;
        word |= this.buffer.readUInt8();
        bits += 8;
        bits = this.decodeHuffmanWord(word, bits, out);
        lastKey = word >> bits;
        word &= (1 << bits) - 1;
      }
      assert(this._huffmanNode === huffman, '8-bit EOS');
      assert(word + 1 === (1 << bits), 'Final sequence is not EOS');
      this._huffmanNode = null;
      return out;
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ac", ["a9", "ad", "94", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var hpack = $__require('a9');
    var utils = hpack.utils;
    var decoder = hpack.decoder;
    var table = hpack.table;
    var assert = utils.assert;
    var inherits = $__require('ad');
    var Duplex = $__require('94').Duplex;
    function Decompressor(options) {
      Duplex.call(this, {readableObjectMode: true});
      this._decoder = decoder.create();
      this._table = table.create(options.table);
    }
    inherits(Decompressor, Duplex);
    module.exports = Decompressor;
    Decompressor.create = function create(options) {
      return new Decompressor(options);
    };
    Decompressor.prototype._read = function _read() {};
    Decompressor.prototype._write = function _write(data, enc, cb) {
      this._decoder.push(data);
      cb(null);
    };
    Decompressor.prototype.execute = function execute(cb) {
      while (!this._decoder.isEmpty()) {
        try {
          this._execute();
        } catch (err) {
          if (cb)
            return done(err);
          else
            return this.emit('error', err);
        }
      }
      if (cb)
        done(null);
      function done(err) {
        process.nextTick(function() {
          cb(err);
        });
      }
    };
    Decompressor.prototype.updateTableSize = function updateTableSize(size) {
      this._table.updateSize(size);
    };
    Decompressor.prototype._execute = function _execute() {
      var isIndexed = this._decoder.decodeBit();
      if (isIndexed)
        return this._processIndexed();
      var isIncremental = this._decoder.decodeBit();
      var neverIndex = 0;
      if (!isIncremental) {
        var isUpdate = this._decoder.decodeBit();
        if (isUpdate)
          return this._processUpdate();
        neverIndex = this._decoder.decodeBit();
      }
      this._processLiteral(isIncremental, neverIndex);
    };
    Decompressor.prototype._processIndexed = function _processIndexed() {
      var index = this._decoder.decodeInt();
      var lookup = this._table.lookup(index);
      this.push({
        name: lookup.name,
        value: lookup.value,
        neverIndex: false
      });
    };
    Decompressor.prototype._processLiteral = function _processLiteral(inc, never) {
      var index = this._decoder.decodeInt();
      var name;
      var nameSize;
      if (index === 0) {
        name = this._decoder.decodeStr();
        nameSize = name.length;
        name = utils.stringify(name);
      } else {
        var lookup = this._table.lookup(index);
        nameSize = lookup.nameSize;
        name = lookup.name;
      }
      var value = this._decoder.decodeStr();
      var valueSize = value.length;
      value = utils.stringify(value);
      if (inc)
        this._table.add(name, value, nameSize, valueSize);
      this.push({
        name: name,
        value: value,
        neverIndex: never !== 0
      });
    };
    Decompressor.prototype._processUpdate = function _processUpdate() {
      var size = this._decoder.decodeInt();
      this.updateTableSize(size);
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ae", ["af", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var assert = $__require('af');
    var Buffer = $__require('72').Buffer;
    function WBuf() {
      this.buffers = [];
      this.toReserve = 0;
      this.size = 0;
      this.maxSize = 0;
      this.avail = 0;
      this.last = null;
      this.offset = 0;
      this.sliceQueue = null;
      this.forceReserve = false;
      this.reserveRate = 64;
    }
    module.exports = WBuf;
    WBuf.prototype.reserve = function reserve(n) {
      this.toReserve += n;
      if (this.forceReserve)
        this.toReserve = Math.max(this.toReserve, this.reserveRate);
    };
    WBuf.prototype._ensure = function _ensure(n) {
      if (this.avail >= n)
        return;
      if (this.toReserve === 0)
        this.toReserve = this.reserveRate;
      this.toReserve = Math.max(n - this.avail, this.toReserve);
      if (this.avail === 0)
        this._next();
    };
    WBuf.prototype._next = function _next() {
      var buf;
      if (this.sliceQueue === null) {
        buf = new Buffer(this.toReserve);
      } else {
        buf = this.sliceQueue.shift();
        if (this.sliceQueue.length === 0)
          this.sliceQueue = null;
      }
      this.toReserve = 0;
      this.buffers.push(buf);
      this.avail = buf.length;
      this.offset = 0;
      this.last = buf;
    };
    WBuf.prototype._rangeCheck = function _rangeCheck() {
      if (this.maxSize !== 0 && this.size > this.maxSize)
        throw new RangeError('WBuf overflow');
    };
    WBuf.prototype._move = function _move(n) {
      this.size += n;
      if (this.avail === 0)
        this.last = null;
      this._rangeCheck();
    };
    WBuf.prototype.slice = function slice(start, end) {
      assert(0 <= start && start <= this.size);
      assert(0 <= end && end <= this.size);
      if (this.last === null)
        this._next();
      var res = new WBuf();
      if (start >= this.size - this.offset) {
        res.buffers.push(this.last);
        res.last = this.last;
        res.offset = start - this.size + this.offset;
        res.maxSize = end - start;
        res.avail = res.maxSize;
        return res;
      }
      var startIndex = -1;
      var startOffset = 0;
      var endIndex = -1;
      var offset = 0;
      for (var i = 0; i < this.buffers.length; i++) {
        var buf = this.buffers[i];
        var next = offset + buf.length;
        if (start >= offset && start <= next) {
          startIndex = i;
          startOffset = start - offset;
          if (endIndex !== -1)
            break;
        }
        if (end >= offset && end <= next) {
          endIndex = i;
          if (startIndex !== -1)
            break;
        }
        offset = next;
      }
      res.last = this.buffers[startIndex];
      res.offset = startOffset;
      res.maxSize = end - start;
      if (startIndex < endIndex) {
        res.sliceQueue = this.buffers.slice(startIndex + 1, endIndex + 1);
        res.last = res.last.slice(res.offset);
        res.offset = 0;
      }
      res.avail = res.last.length - res.offset;
      res.buffers.push(res.last);
      return res;
    };
    WBuf.prototype.skip = function skip(n) {
      if (n === 0)
        return this.slice(this.size, this.size);
      this._ensure(n);
      var left = n;
      while (left > 0) {
        var toSkip = Math.min(left, this.avail);
        left -= toSkip;
        this.size += toSkip;
        if (toSkip === this.avail) {
          if (left !== 0)
            this._next();
          else
            this.avail -= toSkip;
        } else {
          this.offset += toSkip;
          this.avail -= toSkip;
        }
      }
      this._rangeCheck();
      return this.slice(this.size - n, this.size);
    };
    WBuf.prototype.write = function write(str) {
      var len = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c > 255)
          len += 2;
        else
          len += 1;
      }
      this.reserve(len);
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        var hi = c >>> 8;
        var lo = c & 0xff;
        if (hi)
          this.writeUInt8(hi);
        this.writeUInt8(lo);
      }
    };
    WBuf.prototype.copyFrom = function copyFrom(buf, start, end) {
      var off = start === undefined ? 0 : start;
      var len = end === undefined ? buf.length : end;
      if (off === len)
        return;
      this._ensure(len - off);
      while (off < len) {
        var toCopy = Math.min(len - off, this.avail);
        buf.copy(this.last, this.offset, off, off + toCopy);
        off += toCopy;
        this.size += toCopy;
        if (toCopy === this.avail) {
          if (off !== len)
            this._next();
          else
            this.avail = 0;
        } else {
          this.offset += toCopy;
          this.avail -= toCopy;
        }
      }
      this._rangeCheck();
    };
    WBuf.prototype.writeUInt8 = function writeUInt8(v) {
      this._ensure(1);
      this.last[this.offset++] = v;
      this.avail--;
      this._move(1);
    };
    WBuf.prototype.writeUInt16BE = function writeUInt16BE(v) {
      this._ensure(2);
      if (this.avail >= 2) {
        this.last.writeUInt16BE(v, this.offset, true);
        this.offset += 2;
        this.avail -= 2;
      } else {
        this.last[this.offset] = (v >>> 8);
        this._next();
        this.last[this.offset++] = v & 0xff;
        this.avail--;
      }
      this._move(2);
    };
    WBuf.prototype.writeUInt24BE = function writeUInt24BE(v) {
      this._ensure(3);
      if (this.avail >= 3) {
        this.last.writeUInt16BE(v >>> 8, this.offset, true);
        this.last[this.offset + 2] = v & 0xff;
        this.offset += 3;
        this.avail -= 3;
        this._move(3);
      } else if (this.avail >= 2) {
        this.last.writeUInt16BE(v >>> 8, this.offset, true);
        this._next();
        this.last[this.offset++] = v & 0xff;
        this.avail--;
        this._move(3);
      } else {
        this.last[this.offset] = v >>> 16;
        this._move(1);
        this._next();
        this.writeUInt16BE(v & 0xffff);
      }
    };
    WBuf.prototype.writeUInt32BE = function writeUInt32BE(v) {
      this._ensure(4);
      if (this.avail >= 4) {
        this.last.writeUInt32BE(v, this.offset, true);
        this.offset += 4;
        this.avail -= 4;
        this._move(4);
      } else if (this.avail >= 3) {
        this.writeUInt24BE(v >>> 8);
        this._next();
        this.last[this.offset++] = v & 0xff;
        this.avail--;
        this._move(1);
      } else {
        this.writeUInt16BE(v >>> 16);
        this.writeUInt16BE(v & 0xffff);
      }
    };
    WBuf.prototype.writeUInt16LE = function writeUInt16LE(num) {
      var r = ((num & 0xff) << 8) | (num >>> 8);
      this.writeUInt16BE(r);
    };
    WBuf.prototype.writeUInt24LE = function writeUInt24LE(num) {
      var r = ((num & 0xff) << 16) | (((num >>> 8) & 0xff) << 8) | (num >>> 16);
      this.writeUInt24BE(r);
    };
    WBuf.prototype.writeUInt32LE = function writeUInt32LE(num) {
      var r = ((num & 0xff) << 24) | (((num >>> 8) & 0xff) << 16) | (((num >>> 16) & 0xff) << 8) | (num >>> 24);
      this.writeUInt32BE(r);
    };
    WBuf.prototype.render = function render() {
      var left = this.size;
      var out = [];
      for (var i = 0; i < this.buffers.length && left >= 0; i++) {
        var buf = this.buffers[i];
        left -= buf.length;
        if (left >= 0) {
          out.push(buf);
        } else {
          out.push(buf.slice(0, buf.length + left));
        }
      }
      return out;
    };
    WBuf.prototype.writeInt8 = function writeInt8(num) {
      if (num < 0)
        return this.writeUInt8(0x100 + num);
      else
        return this.writeUInt8(num);
    };
    function toUnsigned16(num) {
      if (num < 0)
        return 0x10000 + num;
      else
        return num;
    }
    WBuf.prototype.writeInt16LE = function writeInt16LE(num) {
      this.writeUInt16LE(toUnsigned16(num));
    };
    WBuf.prototype.writeInt16BE = function writeInt16BE(num) {
      this.writeUInt16BE(toUnsigned16(num));
    };
    function toUnsigned24(num) {
      if (num < 0)
        return 0x1000000 + num;
      else
        return num;
    }
    WBuf.prototype.writeInt24LE = function writeInt24LE(num) {
      this.writeUInt24LE(toUnsigned24(num));
    };
    WBuf.prototype.writeInt24BE = function writeInt24BE(num) {
      this.writeUInt24BE(toUnsigned24(num));
    };
    function toUnsigned32(num) {
      if (num < 0)
        return (0xffffffff + num) + 1;
      else
        return num;
    }
    WBuf.prototype.writeInt32LE = function writeInt32LE(num) {
      this.writeUInt32LE(toUnsigned32(num));
    };
    WBuf.prototype.writeInt32BE = function writeInt32BE(num) {
      this.writeUInt32BE(toUnsigned32(num));
    };
    WBuf.prototype.writeComb = function writeComb(size, endian, value) {
      if (size === 1)
        return this.writeUInt8(value);
      if (endian === 'le') {
        if (size === 2)
          this.writeUInt16LE(value);
        else if (size === 3)
          this.writeUInt24LE(value);
        else if (size === 4)
          this.writeUInt32LE(value);
      } else {
        if (size === 2)
          this.writeUInt16BE(value);
        else if (size === 3)
          this.writeUInt24BE(value);
        else if (size === 4)
          this.writeUInt32BE(value);
      }
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9e", ["ae"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('ae');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b0", ["a9", "9e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hpack = $__require('a9');
  var utils = hpack.utils;
  var huffman = hpack.huffman.encode;
  var assert = utils.assert;
  var WBuf = $__require('9e');
  function Encoder() {
    this.buffer = new WBuf();
    this.word = 0;
    this.bitOffset = 0;
  }
  module.exports = Encoder;
  Encoder.create = function create() {
    return new Encoder();
  };
  Encoder.prototype.render = function render() {
    return this.buffer.render();
  };
  Encoder.prototype.encodeBit = function encodeBit(bit) {
    var octet;
    this.word <<= 1;
    this.word |= bit;
    this.bitOffset++;
    if (this.bitOffset === 8) {
      this.buffer.writeUInt8(this.word);
      this.word = 0;
      this.bitOffset = 0;
    }
  };
  Encoder.prototype.encodeBits = function encodeBits(bits, len) {
    var left = bits;
    var leftLen = len;
    while (leftLen > 0) {
      var avail = Math.min(leftLen, 8 - this.bitOffset);
      var toWrite = left >>> (leftLen - avail);
      if (avail === 8) {
        this.buffer.writeUInt8(toWrite);
      } else {
        this.word <<= avail;
        this.word |= toWrite;
        this.bitOffset += avail;
        if (this.bitOffset === 8) {
          this.buffer.writeUInt8(this.word);
          this.word = 0;
          this.bitOffset = 0;
        }
      }
      leftLen -= avail;
      left &= (1 << leftLen) - 1;
    }
  };
  Encoder.prototype.skipBits = function skipBits(num) {
    this.bitOffset += num;
    this.buffer.skip(this.bitOffset >> 3);
    this.bitOffset &= 0x7;
  };
  Encoder.prototype.encodeInt = function encodeInt(num) {
    var prefix = 8 - this.bitOffset;
    this.bitOffset = 0;
    var max = (1 << prefix) - 1;
    if (num < max) {
      this.buffer.writeUInt8((this.word << prefix) | num);
      return octet;
    }
    var left = num - max;
    this.buffer.writeUInt8((this.word << prefix) | max);
    do {
      var octet = left & 0x7f;
      left >>= 7;
      if (left !== 0)
        octet |= 0x80;
      this.buffer.writeUInt8(octet);
    } while (left !== 0);
  };
  Encoder.prototype.encodeStr = function encodeStr(value, isHuffman) {
    this.encodeBit(isHuffman ? 1 : 0);
    if (!isHuffman) {
      this.buffer.reserve(value.length + 1);
      this.encodeInt(value.length);
      for (var i = 0; i < value.length; i++)
        this.buffer.writeUInt8(value[i]);
      return;
    }
    var codes = [];
    var len = 0;
    var pad = 0;
    for (var i = 0; i < value.length; i++) {
      var code = huffman[value[i]];
      codes.push(code);
      len += code[0];
    }
    if (len % 8 !== 0)
      pad = 8 - (len % 8);
    len += pad;
    this.buffer.reserve((len / 8) + 1);
    this.encodeInt(len / 8);
    for (var i = 0; i < codes.length; i++) {
      var code = codes[i];
      this.encodeBits(code[1], code[0]);
    }
    this.encodeBits(0xff >>> (8 - pad), pad);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b1", ["a9", "ad", "94"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hpack = $__require('a9');
  var utils = hpack.utils;
  var encoder = hpack.encoder;
  var table = hpack.table;
  var assert = utils.assert;
  var inherits = $__require('ad');
  var Duplex = $__require('94').Duplex;
  function Compressor(options) {
    Duplex.call(this, {writableObjectMode: true});
    this._encoder = null;
    this._table = table.create(options.table);
  }
  inherits(Compressor, Duplex);
  module.exports = Compressor;
  Compressor.create = function create(options) {
    return new Compressor(options);
  };
  Compressor.prototype._read = function _read() {};
  Compressor.prototype._write = function _write(data, enc, cb) {
    assert(Array.isArray(data), 'Compressor.write() expects list of headers');
    this._encoder = encoder.create();
    for (var i = 0; i < data.length; i++)
      this._encodeHeader(data[i]);
    var data = this._encoder.render();
    this._encoder = null;
    cb(null);
    for (var i = 0; i < data.length; i++)
      this.push(data[i]);
  };
  Compressor.prototype.updateTableSize = function updateTableSize(size) {
    this._table.updateSize(size);
  };
  Compressor.prototype.reset = function reset() {
    var enc = encoder.create();
    var size = this._table.size;
    enc.encodeBits(1, 3);
    enc.encodeInt(0);
    this.updateTableSize(0);
    enc.encodeBits(1, 3);
    enc.encodeInt(size);
    this.updateTableSize(size);
    var data = enc.render();
    for (var i = 0; i < data.length; i++)
      this.push(data[i]);
  };
  Compressor.prototype._encodeHeader = function _encodeHeader(header) {
    if (header.neverIndex) {
      var index = 0;
      var neverIndex = 1;
      var isIndexed = 0;
      var isIncremental = 0;
    } else {
      var index = this._table.reverseLookup(header.name, header.value);
      var isIndexed = index > 0;
      var isIncremental = header.incremental !== false;
      var neverIndex = 0;
    }
    this._encoder.encodeBit(isIndexed);
    if (isIndexed) {
      this._encoder.encodeInt(index);
      return;
    }
    var name = utils.toArray(header.name);
    var value = utils.toArray(header.value);
    this._encoder.encodeBit(isIncremental);
    if (isIncremental) {
      this._table.add(header.name, header.value, name.length, value.length);
    } else {
      this._encoder.encodeBit(0);
      this._encoder.encodeBit(neverIndex);
    }
    this._encoder.encodeInt(-index);
    if (index === 0)
      this._encoder.encodeStr(name, header.huffman !== false);
    this._encoder.encodeStr(value, header.huffman !== false);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a9", ["a5", "a6", "a7", "a8", "ab", "ac", "b0", "b1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hpack = exports;
  hpack.utils = $__require('a5');
  hpack.huffman = $__require('a6');
  hpack['static-table'] = $__require('a7');
  hpack.table = $__require('a8');
  hpack.decoder = $__require('ab');
  hpack.decompressor = $__require('ac');
  hpack.encoder = $__require('b0');
  hpack.compressor = $__require('b1');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b2", ["a9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('a9');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b3", ["93", "a3", "b2"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var transport = $__require('93');
  var constants = $__require('a3').constants;
  var hpack = $__require('b2');
  function Pool() {}
  module.exports = Pool;
  Pool.create = function create() {
    return new Pool();
  };
  Pool.prototype.get = function get(version) {
    var options = {table: {maxSize: constants.HEADER_TABLE_SIZE}};
    var compress = hpack.compressor.create(options);
    var decompress = hpack.decompressor.create(options);
    return {
      version: version,
      compress: compress,
      decompress: decompress
    };
  };
  Pool.prototype.put = function put() {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a3", ["a1", "a2", "a4", "b3"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.name = 'h2';
  exports.constants = $__require('a1');
  exports.parser = $__require('a2');
  exports.framer = $__require('a4');
  exports.compressionPool = $__require('b3');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b4", ["59", "1a", "80", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var util = $__require('59');
    var EventEmitter = $__require('1a').EventEmitter;
    var debug = {
      server: $__require('80')('spdy:window:server'),
      client: $__require('80')('spdy:window:client')
    };
    function Side(window, name, options) {
      EventEmitter.call(this);
      this.name = name;
      this.window = window;
      this.current = options.size;
      this.max = options.size;
      this.limit = options.max;
      this.lowWaterMark = options.lowWaterMark === undefined ? this.max / 2 : options.lowWaterMark;
      this._refilling = false;
      this._refillQueue = [];
    }
    util.inherits(Side, EventEmitter);
    Side.prototype.setMax = function setMax(max) {
      this.window.debug('id=%d side=%s setMax=%d', this.window.id, this.name, max);
      this.max = max;
      this.lowWaterMark = this.max / 2;
    };
    Side.prototype.updateMax = function updateMax(max) {
      var delta = max - this.max;
      this.window.debug('id=%d side=%s updateMax=%d delta=%d', this.window.id, this.name, max, delta);
      this.max = max;
      this.lowWaterMark = max / 2;
      this.update(delta);
    };
    Side.prototype.setLowWaterMark = function setLowWaterMark(lwm) {
      this.lowWaterMark = lwm;
    };
    Side.prototype.update = function update(size, callback) {
      if (size < 0 && callback && this.isEmpty()) {
        this.window.debug('id=%d side=%s wait for refill=%d [%d/%d]', this.window.id, this.name, -size, this.current, this.max);
        this._refillQueue.push({
          size: size,
          callback: callback
        });
        return;
      }
      this.current += size;
      if (this.current > this.limit) {
        this.emit('overflow');
        return;
      }
      this.window.debug('id=%d side=%s update by=%d [%d/%d]', this.window.id, this.name, size, this.current, this.max);
      if (size < 0 && this.isDraining()) {
        this.window.debug('id=%d side=%s drained', this.window.id, this.name);
        this.emit('drain');
      }
      if (size > 0 && this.current > 0 && this.current <= size) {
        this.window.debug('id=%d side=%s full', this.window.id, this.name);
        this.emit('full');
      }
      this._processRefillQueue();
      if (callback)
        process.nextTick(callback);
    };
    Side.prototype.getCurrent = function getCurrent() {
      return this.current;
    };
    Side.prototype.getMax = function getMax() {
      return this.max;
    };
    Side.prototype.getDelta = function getDelta() {
      return this.max - this.current;
    };
    Side.prototype.isDraining = function isDraining() {
      return this.current <= this.lowWaterMark;
    };
    Side.prototype.isEmpty = function isEmpty() {
      return this.current <= 0;
    };
    Side.prototype._processRefillQueue = function _processRefillQueue() {
      if (this._refilling)
        return;
      this._refilling = true;
      while (this._refillQueue.length > 0) {
        var item = this._refillQueue[0];
        if (this.isEmpty())
          break;
        this.window.debug('id=%d side=%s refilled for size=%d', this.window.id, this.name, -item.size);
        this._refillQueue.shift();
        this.update(item.size, item.callback);
      }
      this._refilling = false;
    };
    function Window(options) {
      this.id = options.id;
      this.isServer = options.isServer;
      this.debug = this.isServer ? debug.server : debug.client;
      this.recv = new Side(this, 'recv', options.recv);
      this.send = new Side(this, 'send', options.send);
    }
    module.exports = Window;
    Window.prototype.clone = function clone(id) {
      return new Window({
        id: id,
        isServer: this.isServer,
        recv: {
          size: this.recv.max,
          max: this.recv.limit,
          lowWaterMark: this.recv.lowWaterMark
        },
        send: {
          size: this.send.max,
          max: this.send.limit,
          lowWaterMark: this.send.lowWaterMark
        }
      });
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b5", ["93", "71", "80"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var transport = $__require('93');
  var utils = transport.utils;
  var assert = $__require('71');
  var debug = $__require('80')('spdy:priority');
  function PriorityNode(tree, options) {
    this.tree = tree;
    this.id = options.id;
    this.parent = options.parent;
    this.weight = options.weight;
    this.priorityFrom = 0;
    this.priorityTo = 1;
    this.priority = 1;
    this.children = {
      list: [],
      weight: 0
    };
    if (this.parent !== null)
      this.parent.addChild(this);
  }
  function compareChildren(a, b) {
    return a.weight === b.weight ? a.id - b.id : a.weight - b.weight;
  }
  PriorityNode.prototype.toJSON = function toJSON() {
    return {
      parent: this.parent,
      weight: this.weight,
      exclusive: this.exclusive
    };
  };
  PriorityNode.prototype.getPriority = function getPriority() {
    return this.priority;
  };
  PriorityNode.prototype.getPriorityRange = function getPriorityRange() {
    return {
      from: this.priorityFrom,
      to: this.priorityTo
    };
  };
  PriorityNode.prototype.addChild = function addChild(child) {
    child.parent = this;
    utils.binaryInsert(this.children.list, child, compareChildren);
    this.children.weight += child.weight;
    this._updatePriority(this.priorityFrom, this.priorityTo);
  };
  PriorityNode.prototype.remove = function remove() {
    assert(this.parent, 'Can\'t remove root node');
    this.parent.removeChild(this);
    this.tree._removeNode(this);
    for (var i = 0; i < this.children.list.length; i++)
      this.parent.addChild(this.children.list[i]);
  };
  PriorityNode.prototype.removeChild = function removeChild(child) {
    this.children.weight -= child.weight;
    var index = utils.binarySearch(this.children.list, child, compareChildren);
    assert(index !== -1);
    this.children.list.splice(index, 1);
  };
  PriorityNode.prototype.removeChildren = function removeChildren() {
    var children = this.children.list;
    this.children.list = [];
    this.children.weight = 0;
    return children;
  };
  PriorityNode.prototype._updatePriority = function _updatePriority(from, to) {
    this.priority = to - from;
    this.priorityFrom = from;
    this.priorityTo = to;
    var weight = 0;
    for (var i = 0; i < this.children.list.length; i++) {
      var node = this.children.list[i];
      var nextWeight = weight + node.weight;
      node._updatePriority(from + this.priority * (weight / this.children.weight), from + this.priority * (nextWeight / this.children.weight));
      weight = nextWeight;
    }
  };
  function PriorityTree(options) {
    this.map = {};
    this.list = [];
    this.defaultWeight = options.defaultWeight || 16;
    this.count = 0;
    this.maxCount = options.maxCount;
    this.root = this.add({
      id: 0,
      parent: null,
      weight: 1
    });
  }
  module.exports = PriorityTree;
  PriorityTree.create = function create(options) {
    return new PriorityTree(options);
  };
  PriorityTree.prototype.add = function add(options) {
    if (options.id === options.parent)
      return this.addDefault(options.id);
    var parent = options.parent === null ? null : this.map[options.parent];
    if (parent === undefined)
      return this.addDefault(options.id);
    debug('add node=%d parent=%d weight=%d exclusive=%d', options.id, options.parent === null ? -1 : options.parent, options.weight || this.defaultWeight, options.exclusive ? 1 : 0);
    var children;
    if (options.exclusive)
      children = parent.removeChildren();
    var node = new PriorityNode(this, {
      id: options.id,
      parent: parent,
      weight: options.weight || this.defaultWeight
    });
    this.map[options.id] = node;
    if (options.exclusive) {
      for (var i = 0; i < children.length; i++)
        node.addChild(children[i]);
    }
    this.count++;
    if (this.count > this.maxCount) {
      debug('hit maximum remove id=%d', this.list[0].id);
      this.list.shift().remove();
    }
    if (node.parent !== null)
      this.list.push(node);
    return node;
  };
  PriorityTree.prototype.get = function get(id) {
    return this.map[id];
  };
  PriorityTree.prototype.addDefault = function addDefault(id) {
    debug('creating default node');
    return this.add({
      id: id,
      parent: 0,
      weight: this.defaultWeight
    });
  };
  PriorityTree.prototype._removeNode = function _removeNode(node) {
    delete this.map[node.id];
    this.count--;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b6", ["b7", "b8", "ad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = PassThrough;
  var Transform = $__require('b7');
  var util = $__require('b8');
  util.inherits = $__require('ad');
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b9", ["ba", "bb", "bc", "b7", "b6", "58", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var Stream = (function() {
      try {
        return $__require('st' + 'ream');
      } catch (_) {}
    }());
    exports = module.exports = $__require('ba');
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = $__require('bb');
    exports.Duplex = $__require('bc');
    exports.Transform = $__require('b7');
    exports.PassThrough = $__require('b6');
    if (!process.browser && process.env.READABLE_STREAM === 'disable') {
      module.exports = $__require('58');
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("94", ["b9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('b9');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bd", ["93", "71", "59", "80", "72", "94", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    'use strict';
    var transport = $__require('93');
    var assert = $__require('71');
    var util = $__require('59');
    var debug = {
      client: $__require('80')('spdy:stream:client'),
      server: $__require('80')('spdy:stream:server')
    };
    var Buffer = $__require('72').Buffer;
    var Duplex = $__require('94').Duplex;
    function Stream(connection, options) {
      Duplex.call(this);
      var connectionState = connection._spdyState;
      var state = {};
      this._spdyState = state;
      this.id = options.id;
      this.method = options.method;
      this.path = options.path;
      this.host = options.host;
      this.headers = options.headers || {};
      this.connection = connection;
      this.parent = options.parent || null;
      state.socket = null;
      state.protocol = connectionState.protocol;
      state.constants = state.protocol.constants;
      state.priority = null;
      state.version = this.connection.getVersion();
      state.isServer = this.connection.isServer();
      state.debug = state.isServer ? debug.server : debug.client;
      state.framer = connectionState.framer;
      state.parser = connectionState.parser;
      state.request = options.request;
      state.needResponse = options.request;
      state.window = connectionState.streamWindow.clone(options.id);
      state.sessionWindow = connectionState.window;
      state.maxChunk = connectionState.maxChunk;
      state.sent = !state.request;
      state.readable = options.readable !== false;
      state.writable = options.writable !== false;
      state.aborted = false;
      state.corked = 0;
      state.corkQueue = [];
      state.timeout = new transport.utils.Timeout(this);
      this.on('finish', this._onFinish);
      this.on('end', this._onEnd);
      var self = this;
      function _onWindowOverflow() {
        self._onWindowOverflow();
      }
      state.window.recv.on('overflow', _onWindowOverflow);
      state.window.send.on('overflow', _onWindowOverflow);
      this._initPriority(options.priority);
      if (!state.readable)
        this.push(null);
      if (!state.writable) {
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
    }
    util.inherits(Stream, Duplex);
    exports.Stream = Stream;
    Stream.prototype._init = function _init(socket) {
      this.socket = socket;
    };
    Stream.prototype._initPriority = function _initPriority(priority) {
      var state = this._spdyState;
      var connectionState = this.connection._spdyState;
      var root = connectionState.priorityRoot;
      if (!priority) {
        state.priority = root.addDefault(this.id);
        return;
      }
      state.priority = root.add({
        id: this.id,
        parent: priority.parent,
        weight: priority.weight,
        exclusive: priority.exclusive
      });
    };
    Stream.prototype._handleFrame = function _handleFrame(frame) {
      var state = this._spdyState;
      if (state.aborted) {
        state.debug('id=%d ignoring frame=%s after abort', this.id, frame.type);
        return;
      }
      state.timeout.reset();
      if (frame.type === 'DATA')
        this._handleData(frame);
      else if (frame.type === 'HEADERS')
        this._handleHeaders(frame);
      else if (frame.type === 'RST')
        this._handleRST(frame);
      else if (frame.type === 'WINDOW_UPDATE')
        this._handleWindowUpdate(frame);
      else if (frame.type === 'PRIORITY')
        this._handlePriority(frame);
      else if (frame.type === 'PUSH_PROMISE')
        this._handlePushPromise(frame);
      if (frame.fin) {
        state.debug('id=%d end', this.id);
        this.push(null);
      }
    };
    function checkAborted(stream, state, callback) {
      if (state.aborted) {
        state.debug('id=%d abort write', stream.id);
        process.nextTick(function() {
          callback(new Error('Stream write aborted'));
        });
        return true;
      }
      return false;
    }
    function _send(stream, state, data, callback) {
      if (checkAborted(stream, state, callback))
        return;
      state.debug('id=%d presend=%d', stream.id, data.length);
      state.timeout.reset();
      state.window.send.update(-data.length, function() {
        if (checkAborted(stream, state, callback))
          return;
        state.debug('id=%d send=%d', stream.id, data.length);
        state.timeout.reset();
        state.framer.dataFrame({
          id: stream.id,
          priority: state.priority.getPriority(),
          fin: false,
          data: data
        }, function(err) {
          state.debug('id=%d postsend=%d', stream.id, data.length);
          callback(err);
        });
      });
    }
    Stream.prototype._write = function _write(data, enc, callback) {
      var state = this._spdyState;
      if (!state.sent)
        this.send();
      if (state.corked !== 0) {
        var self = this;
        state.corkQueue.push(function() {
          self._write(data, enc, callback);
        });
        return;
      }
      this._splitStart(data, _send, callback);
    };
    Stream.prototype._splitStart = function _splitStart(data, onChunk, callback) {
      return this._split(data, 0, onChunk, callback);
    };
    Stream.prototype._split = function _split(data, offset, onChunk, callback) {
      if (offset === data.length)
        return process.nextTick(callback);
      var state = this._spdyState;
      var local = state.window.send;
      var session = state.sessionWindow.send;
      var availSession = Math.max(0, session.getCurrent());
      if (availSession === 0)
        availSession = session.getMax();
      var availLocal = Math.max(0, local.getCurrent());
      if (availLocal === 0)
        availLocal = local.getMax();
      var avail = Math.min(availSession, availLocal);
      avail = Math.min(avail, state.maxChunk);
      var limit = avail === 0 ? this.max : avail;
      var size = Math.min(data.length - offset, limit);
      var chunk = data.slice(offset, offset + size);
      var self = this;
      onChunk(this, state, chunk, function(err) {
        if (err)
          return callback(err);
        self._split(data, offset + size, onChunk, callback);
      });
    };
    Stream.prototype._read = function _read() {
      var state = this._spdyState;
      if (!state.window.recv.isDraining())
        return;
      var delta = state.window.recv.getDelta();
      state.debug('id=%d window emptying, update by %d', this.id, delta);
      state.window.recv.update(delta);
      state.framer.windowUpdateFrame({
        id: this.id,
        delta: delta
      });
    };
    Stream.prototype._handleData = function _handleData(frame) {
      var state = this._spdyState;
      if (!state.readable || this._readableState.ended) {
        state.framer.rstFrame({
          id: this.id,
          code: 'STREAM_CLOSED'
        });
        return;
      }
      state.debug('id=%d recv=%d', this.id, frame.data.length);
      state.window.recv.update(-frame.data.length);
      this.push(frame.data);
    };
    Stream.prototype._handleRST = function _handleRST(frame) {
      if (frame.code !== 'CANCEL')
        this.emit('error', new Error('Got RST: ' + frame.code));
      this.abort();
    };
    Stream.prototype._handleWindowUpdate = function _handleWindowUpdate(frame) {
      var state = this._spdyState;
      state.window.send.update(frame.delta);
    };
    Stream.prototype._onWindowOverflow = function _onWindowOverflow() {
      var state = this._spdyState;
      state.debug('id=%d window overflow', this.id);
      state.framer.rstFrame({
        id: this.id,
        code: 'FLOW_CONTROL_ERROR'
      });
    };
    Stream.prototype._handlePriority = function _handlePriority(frame) {
      var state = this._spdyState;
      state.priority.remove();
      state.priority = null;
      this._initPriority(frame.priority);
      this.emit('priority', frame.priority);
    };
    Stream.prototype._handleHeaders = function _handleHeaders(frame) {
      var state = this._spdyState;
      if (!state.readable || this._readableState.ended) {
        state.framer.rstFrame({
          id: this.id,
          code: 'STREAM_CLOSED'
        });
        return;
      }
      if (state.needResponse)
        return this._handleResponse(frame);
      this.emit('headers', frame.headers);
    };
    Stream.prototype._handleResponse = function _handleResponse(frame) {
      var state = this._spdyState;
      if (frame.headers[':status'] === undefined) {
        state.framer.rstFrame({
          id: this.id,
          code: 'PROTOCOL_ERROR'
        });
        return;
      }
      state.needResponse = false;
      this.emit('response', frame.headers[':status'] | 0, frame.headers);
    };
    Stream.prototype._onFinish = function _onFinish() {
      var state = this._spdyState;
      if (!state.sent) {
        this.send();
      } else {
        if (state.corked !== 0) {
          var self = this;
          state.corkQueue.push(function() {
            self._onFinish();
          });
          return;
        }
        state.framer.dataFrame({
          id: this.id,
          priority: state.priority.getPriority(),
          fin: true,
          data: new Buffer(0)
        });
      }
      this._maybeClose();
    };
    Stream.prototype._onEnd = function _onEnd() {
      this._maybeClose();
    };
    Stream.prototype._checkEnded = function _checkEnded(callback) {
      var state = this._spdyState;
      var ended = false;
      if (state.aborted)
        ended = true;
      if (!state.writable || this._writableState.finished)
        ended = true;
      if (!ended)
        return true;
      if (!callback)
        return false;
      var err = new Error('Ended stream can\'t send frames');
      process.nextTick(function() {
        callback(err);
      });
      return false;
    };
    Stream.prototype._maybeClose = function _maybeClose() {
      var state = this._spdyState;
      if (state.aborted)
        return;
      if ((!state.readable || this._readableState.ended) && this._writableState.finished) {
        state.timeout.set(0);
        this.emit('close');
      }
    };
    Stream.prototype._handlePushPromise = function _handlePushPromise(frame) {
      var push = this.connection._createStream({
        id: frame.promisedId,
        parent: this,
        push: true,
        request: true,
        method: frame.headers[':method'],
        path: frame.headers[':path'],
        host: frame.headers[':authority'],
        priority: frame.priority,
        headers: frame.headers,
        writable: false
      });
      if (this.connection._isGoaway(push.id))
        return;
      if (!this.emit('pushPromise', push))
        push.abort();
    };
    Stream.prototype._hardCork = function _hardCork() {
      var state = this._spdyState;
      this.cork();
      state.corked++;
    };
    Stream.prototype._hardUncork = function _hardUncork() {
      var state = this._spdyState;
      this.uncork();
      state.corked--;
      if (state.corked !== 0)
        return;
      var queue = state.corkQueue;
      state.corkQueue = [];
      for (var i = 0; i < queue.length; i++)
        queue[i]();
    };
    Stream.prototype._sendPush = function _sendPush(status, response, callback) {
      var self = this;
      var state = this._spdyState;
      this._hardCork();
      state.framer.pushFrame({
        id: this.parent.id,
        promisedId: this.id,
        priority: state.priority.toJSON(),
        path: this.path,
        host: this.host,
        method: this.method,
        status: status,
        headers: this.headers,
        response: response
      }, function(err) {
        self._hardUncork();
        callback(err);
      });
    };
    Stream.prototype._wasSent = function _wasSent() {
      var state = this._spdyState;
      return state.sent;
    };
    Stream.prototype.send = function send(callback) {
      var state = this._spdyState;
      if (state.sent) {
        var err = new Error('Stream was already sent');
        process.nextTick(function() {
          if (callback)
            callback(err);
        });
        return;
      }
      state.sent = true;
      state.timeout.reset();
      if (this.method === 'GET') {
        this._writableState.ended = true;
        this._writableState.finished = true;
      }
      var self = this;
      this._hardCork();
      state.framer.requestFrame({
        id: this.id,
        method: this.method,
        path: this.path,
        host: this.host,
        priority: state.priority.toJSON(),
        headers: this.headers,
        fin: this._writableState.finished
      }, function(err) {
        self._hardUncork();
        if (!callback)
          return;
        callback(err);
      });
    };
    Stream.prototype.respond = function respond(status, headers, callback) {
      var self = this;
      var state = this._spdyState;
      assert(!state.request, 'Can\'t respond on request');
      state.timeout.reset();
      if (!this._checkEnded(callback))
        return;
      var frame = {
        id: this.id,
        status: status,
        headers: headers
      };
      this._hardCork();
      state.framer.responseFrame(frame, function(err) {
        self._hardUncork();
        if (callback)
          callback(err);
      });
    };
    Stream.prototype.setWindow = function setWindow(size) {
      var state = this._spdyState;
      state.timeout.reset();
      if (!this._checkEnded())
        return;
      state.debug('id=%d force window max=%d', this.id, size);
      state.window.recv.setMax(size);
      var delta = state.window.recv.getDelta();
      state.framer.windowUpdateFrame({
        id: this.id,
        delta: delta
      });
      state.window.recv.update(delta);
    };
    Stream.prototype.sendHeaders = function sendHeaders(headers, callback) {
      var self = this;
      var state = this._spdyState;
      state.timeout.reset();
      if (!this._checkEnded(callback))
        return;
      if (!state.sent) {
        this.headers = util._extend({}, this.headers);
        util._extend(this.headers, headers);
        process.nextTick(function() {
          if (callback)
            callback(null);
        });
        return;
      }
      this._hardCork();
      state.framer.headersFrame({
        id: this.id,
        headers: headers
      }, function(err) {
        self._hardUncork();
        if (callback)
          callback(err);
      });
    };
    Stream.prototype.destroy = function destroy() {
      this.abort();
    };
    Stream.prototype.abort = function abort(code, callback) {
      var state = this._spdyState;
      if (typeof code === 'function') {
        callback = code;
        code = null;
      }
      if (this._readableState.ended && this._writableState.finished) {
        state.debug('id=%d already closed', this.id);
        if (callback)
          process.nextTick(callback);
        return;
      }
      if (state.aborted) {
        state.debug('id=%d already aborted', this.id);
        if (callback)
          process.nextTick(callback);
        return;
      }
      state.aborted = true;
      state.debug('id=%d abort', this.id);
      this.setTimeout(0);
      var abortCode = code || 'CANCEL';
      state.framer.rstFrame({
        id: this.id,
        code: abortCode
      });
      var self = this;
      process.nextTick(function() {
        if (callback)
          callback(null);
        self.emit('close', new Error('Aborted, code: ' + abortCode));
      });
    };
    Stream.prototype.setPriority = function setPriority(info) {
      var state = this._spdyState;
      state.timeout.reset();
      if (!this._checkEnded())
        return;
      state.debug('id=%d priority change', this.id, info);
      var frame = {
        id: this.id,
        priority: info
      };
      this._handlePriority(frame);
      state.framer.priorityFrame(frame);
    };
    Stream.prototype.pushPromise = function pushPromise(uri, callback) {
      if (!this._checkEnded(callback))
        return;
      var self = this;
      this._hardCork();
      var push = this.connection.pushPromise(this, uri, function(err) {
        self._hardUncork();
        if (!err)
          push._hardUncork();
        if (callback)
          return callback(err, push);
        if (err)
          push.emit('error', err);
      });
      push._hardCork();
      return push;
    };
    Stream.prototype.setMaxChunk = function setMaxChunk(size) {
      var state = this._spdyState;
      state.maxChunk = size;
    };
    Stream.prototype.setTimeout = function setTimeout(delay, callback) {
      var state = this._spdyState;
      state.timeout.set(delay, callback);
    };
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("be", ["59", "93", "80", "1a", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    'use strict';
    var util = $__require('59');
    var transport = $__require('93');
    var debug = {
      server: $__require('80')('spdy:connection:server'),
      client: $__require('80')('spdy:connection:client')
    };
    var EventEmitter = $__require('1a').EventEmitter;
    var Stream = transport.Stream;
    function Connection(socket, options) {
      EventEmitter.call(this);
      var state = {};
      this._spdyState = state;
      this.httpAllowHalfOpen = true;
      state.timeout = new transport.utils.Timeout(this);
      state.protocol = transport.protocol[options.protocol];
      state.version = null;
      state.constants = state.protocol.constants;
      state.pair = null;
      state.isServer = options.isServer;
      state.priorityRoot = new transport.Priority({
        defaultWeight: state.constants.DEFAULT_WEIGHT,
        maxCount: transport.protocol.base.constants.MAX_PRIORITY_STREAMS
      });
      state.maxStreams = options.maxStreams || state.constants.MAX_CONCURRENT_STREAMS;
      state.autoSpdy31 = options.protocol.name !== 'h2' && options.autoSpdy31;
      state.acceptPush = options.acceptPush === undefined ? !state.isServer : options.acceptPush;
      if (options.maxChunk === false)
        state.maxChunk = Infinity;
      else if (options.maxChunk === undefined)
        state.maxChunk = transport.protocol.base.constants.DEFAULT_MAX_CHUNK;
      else
        state.maxChunk = options.maxChunk;
      var windowSize = options.windowSize || 1 << 20;
      state.window = new transport.Window({
        id: 0,
        isServer: state.isServer,
        recv: {
          size: state.constants.DEFAULT_WINDOW,
          max: state.constants.MAX_INITIAL_WINDOW_SIZE
        },
        send: {
          size: state.constants.DEFAULT_WINDOW,
          max: state.constants.MAX_INITIAL_WINDOW_SIZE
        }
      });
      state.window.recv.setMax(windowSize);
      state.streamWindow = new transport.Window({
        id: -1,
        isServer: state.isServer,
        recv: {
          size: windowSize,
          max: state.constants.MAX_INITIAL_WINDOW_SIZE
        },
        send: {
          size: state.constants.DEFAULT_WINDOW,
          max: state.constants.MAX_INITIAL_WINDOW_SIZE
        }
      });
      state.maxChunk = options.maxChunk === undefined ? 8 * 1024 : options.maxChunk;
      state.pool = state.protocol.compressionPool.create(options.headerCompression);
      state.counters = {
        push: 0,
        stream: 0
      };
      state.stream = {
        map: {},
        count: 0,
        nextId: state.isServer ? 2 : 1,
        lastId: {
          both: 0,
          received: 0
        }
      };
      state.ping = {
        nextId: state.isServer ? 2 : 1,
        map: {}
      };
      state.goaway = false;
      state.debug = state.isServer ? debug.server : debug.client;
      state.xForward = null;
      state.parser = state.protocol.parser.create({
        isServer: state.isServer,
        window: state.window
      });
      state.framer = state.protocol.framer.create({
        window: state.window,
        timeout: state.timeout
      });
      if (state.protocol.name === 'spdy')
        state.framer.enablePush(state.isServer);
      if (!state.isServer)
        state.parser.skipPreface();
      this.socket = socket;
      this._init();
    }
    util.inherits(Connection, EventEmitter);
    exports.Connection = Connection;
    Connection.create = function create(socket, options) {
      return new Connection(socket, options);
    };
    Connection.prototype._init = function init() {
      var self = this;
      var state = this._spdyState;
      var pool = state.pool;
      state.window.recv.on('drain', function() {
        self._onSessionWindowDrain();
      });
      state.parser.on('data', function(frame) {
        self._handleFrame(frame);
      });
      state.parser.once('version', function(version) {
        self._onVersion(version);
      });
      state.parser.on('error', function(err) {
        self._onParserError(err);
      });
      state.framer.on('error', function(err) {
        self.emit('error', err);
      });
      this.socket.pipe(state.parser);
      state.framer.pipe(this.socket);
      this.socket.on('error', function onSocketError(e) {
        self.emit('error', e);
      });
      this.socket.once('close', function onclose() {
        var err = new Error('socket hang up');
        err.code = 'ECONNRESET';
        self.destroyStreams(err);
        self.emit('close', err);
        if (state.pair)
          pool.put(state.pair);
      });
      this.once('close', function() {
        self.setTimeout(0);
      });
      function _onWindowOverflow() {
        self._onWindowOverflow();
      }
      state.window.recv.on('overflow', _onWindowOverflow);
      state.window.send.on('overflow', _onWindowOverflow);
      this.socket.allowHalfOpen = false;
    };
    Connection.prototype._onVersion = function _onVersion(version) {
      var state = this._spdyState;
      var prev = state.version;
      var parser = state.parser;
      var framer = state.framer;
      var pool = state.pool;
      state.version = version;
      state.debug('id=0 version=%d', version);
      if (!prev) {
        state.pair = pool.get(version);
        parser.setCompression(state.pair);
        framer.setCompression(state.pair);
      }
      framer.setVersion(version);
      if (!state.isServer) {
        framer.prefaceFrame();
        if (state.xForward !== null)
          framer.xForwardedFor({host: state.xForward});
      }
      framer.settingsFrame({
        max_header_list_size: state.constants.DEFAULT_MAX_HEADER_LIST_SIZE,
        max_concurrent_streams: state.maxStreams,
        enable_push: state.acceptPush ? 1 : 0,
        initial_window_size: state.window.recv.max
      });
      if (state.version >= 3.1 || (state.isServer && state.autoSpdy31))
        this._onSessionWindowDrain();
      this.emit('version', version);
    };
    Connection.prototype._onParserError = function _onParserError(err) {
      var state = this._spdyState;
      state.parser.kill();
      if (err instanceof transport.protocol.base.utils.ProtocolError) {
        this._goaway({
          lastId: state.stream.lastId.both,
          code: err.code,
          extra: err.message,
          send: true
        });
      }
      this.emit('error', err);
    };
    Connection.prototype._handleFrame = function _handleFrame(frame) {
      var state = this._spdyState;
      state.debug('id=0 frame', frame);
      state.timeout.reset();
      this.emit('frame', frame);
      var stream;
      if (frame.type === 'WINDOW_UPDATE' && frame.id === 0) {
        if (state.version < 3.1 && state.autoSpdy31) {
          state.debug('id=0 switch version to 3.1');
          state.version = 3.1;
          this.emit('version', 3.1);
        }
        state.window.send.update(frame.delta);
        return;
      }
      if (state.isServer && frame.type === 'PUSH_PROMISE') {
        state.debug('id=0 server PUSH_PROMISE');
        this._goaway({
          lastId: state.stream.lastId.both,
          code: 'PROTOCOL_ERROR',
          send: true
        });
        return;
      }
      if (!stream && frame.id !== undefined) {
        stream = state.stream.map[frame.id];
        if (!stream && frame.type !== 'HEADERS' && frame.type !== 'PRIORITY' && frame.type !== 'RST') {
          if (this._isGoaway(frame.id))
            return;
          state.debug('id=0 stream=%d not found', frame.id);
          state.framer.rstFrame({
            id: frame.id,
            code: 'INVALID_STREAM'
          });
          return;
        }
      }
      if (!stream && frame.type === 'HEADERS') {
        this._handleHeaders(frame);
        return;
      }
      if (stream) {
        stream._handleFrame(frame);
      } else if (frame.type === 'SETTINGS') {
        this._handleSettings(frame.settings);
      } else if (frame.type === 'ACK_SETTINGS') {} else if (frame.type === 'PING') {
        this._handlePing(frame);
      } else if (frame.type === 'GOAWAY') {
        this._handleGoaway(frame);
      } else if (frame.type === 'X_FORWARDED_FOR') {
        if (state.xForward === null)
          state.xForward = frame.host;
      } else if (frame.type === 'PRIORITY') {} else {
        state.debug('id=0 unknown frame type: %s', frame.type);
      }
    };
    Connection.prototype._onWindowOverflow = function _onWindowOverflow() {
      var state = this._spdyState;
      state.debug('id=0 window overflow');
      this._goaway({
        lastId: state.stream.lastId.both,
        code: 'FLOW_CONTROL_ERROR',
        send: true
      });
    };
    Connection.prototype._isGoaway = function _isGoaway(id) {
      var state = this._spdyState;
      if (state.goaway !== false && state.goaway < id)
        return true;
      return false;
    };
    Connection.prototype._getId = function _getId() {
      var state = this._spdyState;
      var id = state.stream.nextId;
      state.stream.nextId += 2;
      return id;
    };
    Connection.prototype._createStream = function _createStream(uri) {
      var state = this._spdyState;
      var id = uri.id;
      if (id === undefined)
        id = this._getId();
      var isGoaway = this._isGoaway(id);
      if (uri.push && !state.acceptPush) {
        state.debug('id=0 push disabled promisedId=%d', id);
        this._goaway({
          lastId: state.stream.lastId.both,
          code: 'PROTOCOL_ERROR',
          send: true
        });
        isGoaway = true;
      }
      var stream = new Stream(this, {
        id: id,
        request: uri.request !== false,
        method: uri.method,
        path: uri.path,
        host: uri.host,
        priority: uri.priority,
        headers: uri.headers,
        parent: uri.parent,
        readable: !isGoaway && uri.readable,
        writable: !isGoaway && uri.writable
      });
      var self = this;
      if (isGoaway)
        return stream;
      state.stream.lastId.both = Math.max(state.stream.lastId.both, id);
      state.debug('id=0 add stream=%d', stream.id);
      state.stream.map[stream.id] = stream;
      state.stream.count++;
      state.counters.stream++;
      if (stream.parent !== null)
        state.counters.push++;
      stream.once('close', function() {
        self._removeStream(stream);
      });
      return stream;
    };
    Connection.prototype._handleHeaders = function _handleHeaders(frame) {
      var state = this._spdyState;
      if (frame.id <= state.stream.lastId.received)
        return;
      if ((frame.id + state.stream.nextId) % 2 === 0) {
        state.framer.rstFrame({
          id: frame.id,
          code: 'PROTOCOL_ERROR'
        });
        return;
      }
      var stream = this._createStream({
        id: frame.id,
        request: false,
        method: frame.headers[':method'],
        path: frame.headers[':path'],
        host: frame.headers[':authority'],
        priority: frame.priority,
        headers: frame.headers,
        writable: frame.writable
      });
      if (this._isGoaway(stream.id))
        return;
      state.stream.lastId.received = Math.max(state.stream.lastId.received, stream.id);
      if (!this.emit('stream', stream)) {
        stream.abort();
        return;
      }
      if (frame.fin)
        stream._handleFrame({
          type: 'FIN',
          fin: true
        });
      return stream;
    };
    Connection.prototype._onSessionWindowDrain = function _onSessionWindowDrain() {
      var state = this._spdyState;
      if (state.version < 3.1 && (!state.isServer || !state.autoSpdy31))
        return;
      var delta = state.window.recv.getDelta();
      state.debug('id=0 session window drain, update by %d', delta);
      state.framer.windowUpdateFrame({
        id: 0,
        delta: delta
      });
      state.window.recv.update(delta);
    };
    Connection.prototype.start = function start(version) {
      this._spdyState.parser.setVersion(version);
    };
    Connection.prototype.getVersion = function getVersion() {
      return this._spdyState.version;
    };
    Connection.prototype._handleSettings = function _handleSettings(settings) {
      var state = this._spdyState;
      state.framer.ackSettingsFrame();
      this._setDefaultWindow(settings);
      if (settings.max_frame_size)
        state.framer.setMaxFrameSize(settings.max_frame_size);
      if (settings.header_table_size) {
        try {
          state.pair.decompress.updateTableSize(settings.header_table_size);
        } catch (e) {
          this._goaway({
            lastId: 0,
            code: 'PROTOCOL_ERROR',
            send: true
          });
          return;
        }
      }
      if (state.protocol.name !== 'spdy') {
        if (settings.enable_push === undefined)
          state.framer.enablePush(state.isServer);
        else
          state.framer.enablePush(settings.enable_push === 1);
      }
    };
    Connection.prototype._setDefaultWindow = function _setDefaultWindow(settings) {
      if (!settings.initial_window_size)
        return;
      var state = this._spdyState;
      var window = state.streamWindow;
      window.send.setMax(settings.initial_window_size);
      Object.keys(state.stream.map).forEach(function(id) {
        var stream = state.stream.map[id];
        var window = stream._spdyState.window;
        window.send.updateMax(settings.initial_window_size);
      });
    };
    Connection.prototype._handlePing = function handlePing(frame) {
      var self = this;
      var state = this._spdyState;
      if (!frame.ack) {
        state.framer.pingFrame({
          opaque: frame.opaque,
          ack: true
        });
        self.emit('ping', frame.opaque);
        return;
      }
      var hex = frame.opaque.toString('hex');
      if (!state.ping.map[hex])
        return;
      var ping = state.ping.map[hex];
      delete state.ping.map[hex];
      if (ping.cb)
        ping.cb(null);
    };
    Connection.prototype._handleGoaway = function handleGoaway(frame) {
      this._goaway({
        lastId: frame.lastId,
        code: frame.code,
        send: false
      });
    };
    Connection.prototype.ping = function ping(callback) {
      var state = this._spdyState;
      var opaque = new Buffer(state.constants.PING_OPAQUE_SIZE);
      opaque.fill(0);
      opaque.writeUInt32BE(state.ping.nextId, opaque.length - 4);
      state.ping.nextId += 2;
      state.ping.map[opaque.toString('hex')] = {cb: callback};
      state.framer.pingFrame({
        opaque: opaque,
        ack: false
      });
    };
    Connection.prototype.getCounter = function getCounter(name) {
      return this._spdyState.counters[name];
    };
    Connection.prototype.reserveStream = function reserveStream(uri, callback) {
      var stream = this._createStream(uri);
      if (this._isGoaway(stream.id)) {
        var err = new Error('Can\'t send request after GOAWAY');
        process.nextTick(function() {
          if (callback)
            callback(err);
          else
            stream.emit('error', err);
        });
        return stream;
      }
      if (callback) {
        process.nextTick(function() {
          callback(null, stream);
        });
      }
      return stream;
    };
    Connection.prototype.request = function request(uri, callback) {
      var stream = this.reserveStream(uri, function(err) {
        if (err) {
          if (callback)
            callback(err);
          else
            stream.emit('error', err);
          return;
        }
        if (stream._wasSent()) {
          if (callback)
            callback(null, stream);
          return;
        }
        stream.send(function(err) {
          if (err) {
            if (callback)
              return callback(err);
            else
              return stream.emit('error', err);
          }
          if (callback)
            callback(null, stream);
        });
      });
      return stream;
    };
    Connection.prototype._removeStream = function _removeStream(stream) {
      var state = this._spdyState;
      state.debug('id=0 remove stream=%d', stream.id);
      delete state.stream.map[stream.id];
      state.stream.count--;
      if (state.stream.count === 0)
        this.emit('_streamDrain');
    };
    Connection.prototype._goaway = function _goaway(params) {
      var state = this._spdyState;
      var self = this;
      state.goaway = params.lastId;
      state.debug('id=0 goaway from=%d', state.goaway);
      Object.keys(state.stream.map).forEach(function(id) {
        var stream = state.stream.map[id];
        if (stream.id <= params.lastId)
          return;
        stream.abort();
        stream.emit('error', new Error('New stream after GOAWAY'));
      });
      function finish() {
        if (state.stream.count === 0 || params.code !== 'OK') {
          state.parser.kill();
          process.nextTick(function() {
            var err = new Error('Fatal error: ' + params.code);
            self._onStreamDrain(err);
          });
          return;
        }
        self.on('_streamDrain', self._onStreamDrain);
      }
      if (params.send) {
        state.framer.goawayFrame({
          lastId: params.lastId,
          code: params.code,
          extra: params.extra
        }, finish);
      } else {
        finish();
      }
    };
    Connection.prototype._onStreamDrain = function _onStreamDrain(error) {
      var state = this._spdyState;
      state.debug('id=0 _onStreamDrain');
      state.framer.dump();
      state.framer.unpipe(this.socket);
      if (this.socket.destroySoon)
        this.socket.destroySoon();
      this.emit('close', error);
    };
    Connection.prototype.end = function end(callback) {
      var state = this._spdyState;
      if (callback)
        this.once('close', callback);
      this._goaway({
        lastId: state.stream.lastId.both,
        code: 'OK',
        send: true
      });
    };
    Connection.prototype.destroyStreams = function destroyStreams(err) {
      var state = this._spdyState;
      Object.keys(state.stream.map).forEach(function(id) {
        var stream = state.stream.map[id];
        stream.abort();
        stream.emit('error', err);
      });
    };
    Connection.prototype.isServer = function isServer() {
      return this._spdyState.isServer;
    };
    Connection.prototype.getXForwardedFor = function getXForwardFor() {
      return this._spdyState.xForward;
    };
    Connection.prototype.sendXForwardedFor = function sendXForwardedFor(host) {
      var state = this._spdyState;
      if (state.version !== null)
        state.framer.xForwardedFor({host: host});
      else
        state.xForward = host;
    };
    Connection.prototype.pushPromise = function pushPromise(parent, uri, callback) {
      var state = this._spdyState;
      var stream = this._createStream({
        request: false,
        parent: parent,
        method: uri.method,
        path: uri.path,
        host: uri.host,
        priority: uri.priority,
        headers: uri.headers,
        readable: false
      });
      if (this._isGoaway(stream.id)) {
        var err = new Error('Can\'t send PUSH_PROMISE after GOAWAY');
        process.nextTick(function() {
          if (callback)
            callback(err);
          else
            stream.emit('error', err);
        });
        return stream;
      }
      if (uri.push && !state.acceptPush) {
        var err = new Error('Can\'t send PUSH_PROMISE, other side won\'t accept it');
        process.nextTick(function() {
          if (callback)
            callback(err);
          else
            stream.emit('error', err);
        });
        return stream;
      }
      stream._sendPush(uri.status, uri.response, function(err) {
        if (!callback) {
          if (err)
            stream.emit('error', err);
          return;
        }
        if (err)
          return callback(err);
        callback(null, stream);
      });
      return stream;
    };
    Connection.prototype.setTimeout = function setTimeout(delay, callback) {
      var state = this._spdyState;
      state.timeout.set(delay, callback);
    };
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("93", ["8f", "96", "9d", "a3", "b4", "b5", "bd", "be"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var transport = exports;
  transport.utils = $__require('8f');
  transport.protocol = {};
  transport.protocol.base = $__require('96');
  transport.protocol.spdy = $__require('9d');
  transport.protocol.http2 = $__require('a3');
  transport.Window = $__require('b4');
  transport.Priority = $__require('b5');
  transport.Stream = $__require('bd').Stream;
  transport.Connection = $__require('be').Connection;
  transport.connection = transport.Connection;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7f", ["93"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('93');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bf", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    if ('string' == typeof val)
      return parse(val);
    return options.long ? long(val) : short(val);
  };
  function parse(str) {
    str = '' + str;
    if (str.length > 10000)
      return;
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match)
      return;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
    }
  }
  function short(ms) {
    if (ms >= d)
      return Math.round(ms / d) + 'd';
    if (ms >= h)
      return Math.round(ms / h) + 'h';
    if (ms >= m)
      return Math.round(ms / m) + 'm';
    if (ms >= s)
      return Math.round(ms / s) + 's';
    return ms + 'ms';
  }
  function long(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }
  function plural(ms, n, name) {
    if (ms < n)
      return;
    if (ms < n * 1.5)
      return Math.floor(ms / n) + ' ' + name;
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c0", ["bf"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('bf');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c1", ["c0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports = module.exports = debug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = $__require('c0');
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevColor = 0;
  var prevTime;
  function selectColor() {
    return exports.colors[prevColor++ % exports.colors.length];
  }
  function debug(namespace) {
    function disabled() {}
    disabled.enabled = false;
    function enabled() {
      var self = enabled;
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      if (null == self.useColors)
        self.useColors = exports.useColors();
      if (null == self.color && self.useColors)
        self.color = selectColor();
      var args = Array.prototype.slice.call(arguments);
      args[0] = exports.coerce(args[0]);
      if ('string' !== typeof args[0]) {
        args = ['%o'].concat(args);
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
        if (match === '%%')
          return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      if ('function' === typeof exports.formatArgs) {
        args = exports.formatArgs.apply(self, args);
      }
      var logFn = enabled.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    enabled.enabled = true;
    var fn = exports.enabled(namespace) ? enabled : disabled;
    fn.namespace = namespace;
    return fn;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    var split = (namespaces || '').split(/[\s,]+/);
    var len = split.length;
    for (var i = 0; i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  function disable() {
    exports.enable('');
  }
  function enabled(name) {
    var i,
        len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c2", ["c1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports = module.exports = $__require('c1');
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
  exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
  function useColors() {
    return ('WebkitAppearance' in document.documentElement.style) || (window.console && (console.firebug || (console.exception && console.table))) || (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
  }
  exports.formatters.j = function(v) {
    return JSON.stringify(v);
  };
  function formatArgs() {
    var args = arguments;
    var useColors = this.useColors;
    args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
    if (!useColors)
      return args;
    var c = 'color: ' + this.color;
    args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-z%]/g, function(match) {
      if ('%%' === match)
        return;
      index++;
      if ('%c' === match) {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
    return args;
  }
  function log() {
    return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("80", ["c2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('c2');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c3", ["71", "7e", "7d", "85", "7a", "59", "8e", "7f", "80", "1a", "7c", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var assert = $__require('71');
    var https = $__require('7e');
    var http = $__require('7d');
    var tls = $__require('85');
    var net = $__require('7a');
    var util = $__require('59');
    var selectHose = $__require('8e');
    var transport = $__require('7f');
    var debug = $__require('80')('spdy:server');
    var EventEmitter = $__require('1a').EventEmitter;
    var spdy = $__require('7c');
    var proto = {};
    function instantiate(base) {
      function Server(options, handler) {
        this._init(base, options, handler);
      }
      util.inherits(Server, base);
      Server.create = function create(options, handler) {
        return new Server(options, handler);
      };
      Object.keys(proto).forEach(function(key) {
        Server.prototype[key] = proto[key];
      });
      return Server;
    }
    proto._init = function _init(base, options, handler) {
      var state = {};
      this._spdyState = state;
      state.options = options.spdy || {};
      var protocols = state.options.protocols || ['h2', 'spdy/3.1', 'spdy/3', 'spdy/2', 'http/1.1', 'http/1.0'];
      var actualOptions = util._extend({
        NPNProtocols: protocols,
        ALPNProtocols: protocols
      }, options);
      state.secure = this instanceof tls.Server;
      if (state.secure)
        base.call(this, actualOptions);
      else
        base.call(this);
      this.httpAllowHalfOpen = true;
      var event = state.secure ? 'secureConnection' : 'connection';
      state.listeners = this.listeners(event).slice();
      assert(state.listeners.length > 0, 'Server does not have default listeners');
      this.removeAllListeners(event);
      if (state.options.plain)
        this.on(event, this._onPlainConnection);
      else
        this.on(event, this._onConnection);
      if (handler)
        this.on('request', handler);
      debug('server init secure=%d', state.secure);
    };
    proto._onConnection = function _onConnection(socket) {
      var state = this._spdyState;
      var protocol;
      if (state.secure)
        protocol = socket.npnProtocol || socket.alpnProtocol;
      this._handleConnection(socket, protocol);
    };
    proto._handleConnection = function _handleConnection(socket, protocol) {
      var state = this._spdyState;
      if (!protocol)
        protocol = state.options.protocol;
      debug('incoming socket protocol=%j', protocol);
      if (!protocol || protocol === 'http/1.1' || protocol === 'http/1.0') {
        debug('to default handler it goes');
        return this._invokeDefault(socket);
      }
      socket.setNoDelay(true);
      var connection = transport.connection.create(socket, util._extend({
        protocol: /spdy/.test(protocol) ? 'spdy' : 'http2',
        isServer: true
      }, state.options.connection || {}));
      if (protocol === 'http2')
        connection.start(4);
      else if (protocol === 'spdy/3.1')
        connection.start(3.1);
      else if (protocol === 'spdy/3')
        connection.start(3);
      else if (protocol === 'spdy/2')
        connection.start(2);
      connection.on('error', function() {
        socket.destroy();
      });
      var self = this;
      connection.on('stream', function(stream) {
        self._onStream(stream);
      });
    };
    var PREFACE = 'PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n';
    var PREFACE_BUFFER = new Buffer(PREFACE);
    function hoseFilter(data, callback) {
      if (data.length < 1)
        return callback(null, null);
      if (data[0] === 0x80)
        return callback(null, 'spdy');
      var avail = Math.min(data.length, PREFACE_BUFFER.length);
      for (var i = 0; i < avail; i++)
        if (data[i] !== PREFACE_BUFFER[i])
          return callback(null, 'http/1.1');
      if (avail !== PREFACE_BUFFER.length)
        return callback(null, null);
      return callback(null, 'h2');
    }
    proto._onPlainConnection = function _onPlainConnection(socket) {
      var hose = selectHose.create(socket, {}, hoseFilter);
      var self = this;
      hose.on('select', function(protocol, socket) {
        self._handleConnection(socket, protocol);
      });
      hose.on('error', function(err) {
        debug('hose error %j', err.message);
        socket.destroy();
      });
    };
    proto._invokeDefault = function _invokeDefault(socket) {
      var state = this._spdyState;
      for (var i = 0; i < state.listeners.length; i++)
        state.listeners[i].call(this, socket);
    };
    proto._onStream = function _onStream(stream) {
      var state = this._spdyState;
      var handle = spdy.handle.create(this._spdyState.options, stream);
      var socketOptions = {
        handle: handle,
        allowHalfOpen: true
      };
      var socket;
      if (state.secure)
        socket = new spdy.Socket(stream.connection.socket, socketOptions);
      else
        socket = new net.Socket(socketOptions);
      handle.assignSocket(socket);
      socket.readable = true;
      socket.writable = true;
      this._invokeDefault(socket);
      if (stream.headers.expect !== undefined && /100-continue/i.test(stream.headers.expect) && EventEmitter.listenerCount(this, 'checkContinue') === 0) {
        this.once('checkContinue', function(req, res) {
          res.writeContinue();
          this.emit('request', req, res);
        });
      }
      handle.emitRequest();
    };
    proto.emit = function emit(event, req, res) {
      if (event !== 'request' && event !== 'checkContinue')
        return EventEmitter.prototype.emit.apply(this, arguments);
      if (!(req.socket._handle instanceof spdy.handle)) {
        debug('not spdy req/res');
        req.isSpdy = false;
        req.spdyVersion = 1;
        return EventEmitter.prototype.emit.apply(this, arguments);
      }
      var handle = req.connection._handle;
      req.isSpdy = true;
      req.spdyVersion = handle.getStream().connection.getVersion();
      req.spdyStream = handle.getStream();
      debug('override req/res');
      res.writeHead = spdy.response.writeHead;
      res.end = spdy.response.end;
      res.push = spdy.response.push;
      res.writeContinue = spdy.response.writeContinue;
      res.spdyStream = handle.getStream();
      handle.assignRequest(req);
      handle.assignResponse(res);
      return EventEmitter.prototype.emit.apply(this, arguments);
    };
    exports.Server = instantiate(https.Server);
    exports.PlainServer = instantiate(http.Server);
    exports.create = function create(base, options, handler) {
      if (typeof base === 'object') {
        handler = options;
        options = base;
        base = null;
      }
      if (base)
        return instantiate(base).create(options, handler);
      if (options.spdy && options.spdy.plain)
        return exports.PlainServer.create(options, handler);
      else
        return exports.Server.create(options, handler);
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7c", ["76", "77", "78", "79", "7b", "c3"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var spdy = exports;
  spdy.handle = $__require('76');
  spdy.request = $__require('77');
  spdy.response = $__require('78');
  spdy.Socket = $__require('79');
  spdy.agent = $__require('7b');
  spdy.Agent = spdy.agent.Agent;
  spdy.createAgent = spdy.agent.create;
  spdy.server = $__require('c3');
  spdy.Server = spdy.server.Server;
  spdy.PlainServer = spdy.server.PlainServer;
  spdy.createServer = spdy.server.create;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c4", ["7c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('7c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c5", ["1a", "59", "5a", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    'use strict';
    var EventEmitter = $__require('1a').EventEmitter;
    var util = $__require('59');
    var assert = $__require('5a');
    function InvalidUpgradeStateError(msg) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, InvalidUpgradeStateError);
      }
      this.message = msg;
      this.name = 'InvalidUpgradeStateError';
    }
    util.inherits(InvalidUpgradeStateError, Error);
    function createServerUpgradeResponse(req, socket, head) {
      return (new ServerUpgradeResponse(socket, head));
    }
    function ServerUpgradeResponse(socket, head) {
      assert.object(socket, 'socket');
      assert.buffer(head, 'head');
      EventEmitter.call(this);
      this.sendDate = true;
      this.statusCode = 400;
      this._upgrade = {
        socket: socket,
        head: head
      };
      this._headWritten = false;
      this._upgradeClaimed = false;
    }
    util.inherits(ServerUpgradeResponse, EventEmitter);
    function notImplemented(method) {
      if (!method.throws) {
        return function() {
          return (method.returns);
        };
      } else {
        return function() {
          throw (new Error('Method ' + method.name + ' is not ' + 'implemented!'));
        };
      }
    }
    var NOT_IMPLEMENTED = [{
      name: 'writeContinue',
      throws: true
    }, {
      name: 'setHeader',
      throws: false,
      returns: null
    }, {
      name: 'getHeader',
      throws: false,
      returns: null
    }, {
      name: 'getHeaders',
      throws: false,
      returns: {}
    }, {
      name: 'removeHeader',
      throws: false,
      returns: null
    }, {
      name: 'addTrailer',
      throws: false,
      returns: null
    }, {
      name: 'cache',
      throws: false,
      returns: 'public'
    }, {
      name: 'format',
      throws: true
    }, {
      name: 'set',
      throws: false,
      returns: null
    }, {
      name: 'get',
      throws: false,
      returns: null
    }, {
      name: 'headers',
      throws: false,
      returns: {}
    }, {
      name: 'header',
      throws: false,
      returns: null
    }, {
      name: 'json',
      throws: false,
      returns: null
    }, {
      name: 'link',
      throws: false,
      returns: null
    }];
    NOT_IMPLEMENTED.forEach(function(method) {
      ServerUpgradeResponse.prototype[method.name] = notImplemented(method);
    });
    ServerUpgradeResponse.prototype._writeHeadImpl = function _writeHeadImpl(statusCode, reason) {
      if (this._headWritten) {
        return;
      }
      this._headWritten = true;
      if (this._upgradeClaimed) {
        throw new InvalidUpgradeStateError('Upgrade already claimed!');
      }
      var head = ['HTTP/1.1 ' + statusCode + ' ' + reason, 'Connection: close'];
      if (this.sendDate) {
        head.push('Date: ' + new Date().toUTCString());
      }
      this._upgrade.socket.write(head.join('\r\n') + '\r\n');
    };
    ServerUpgradeResponse.prototype.status = function status(code) {
      assert.number(code, 'code');
      this.statusCode = code;
      return (code);
    };
    ServerUpgradeResponse.prototype.send = function send(code, body) {
      if (typeof(code) === 'number') {
        this.statusCode = code;
      } else {
        body = code;
      }
      if (typeof(body) === 'object') {
        if (typeof(body.statusCode) === 'number') {
          this.statusCode = body.statusCode;
        }
        if (typeof(body.message) === 'string') {
          this.statusReason = body.message;
        }
      }
      return (this.end());
    };
    ServerUpgradeResponse.prototype.end = function end() {
      this._writeHeadImpl(this.statusCode, 'Connection Not Upgraded');
      this._upgrade.socket.end('\r\n');
      return (true);
    };
    ServerUpgradeResponse.prototype.write = function write() {
      this._writeHeadImpl(this.statusCode, 'Connection Not Upgraded');
      return (true);
    };
    ServerUpgradeResponse.prototype.writeHead = function writeHead(statusCode, reason) {
      assert.number(statusCode, 'statusCode');
      assert.optionalString(reason, 'reason');
      this.statusCode = statusCode;
      if (!reason) {
        reason = 'Connection Not Upgraded';
      }
      if (this._headWritten) {
        throw new Error('Head already written!');
      }
      return (this._writeHeadImpl(statusCode, reason));
    };
    ServerUpgradeResponse.prototype.claimUpgrade = function claimUpgrade() {
      if (this._upgradeClaimed) {
        throw new InvalidUpgradeStateError('Upgrade already claimed!');
      }
      if (this._headWritten) {
        throw new InvalidUpgradeStateError('Upgrade already aborted!');
      }
      this._upgradeClaimed = true;
      return (this._upgrade);
    };
    module.exports = {
      createResponse: createServerUpgradeResponse,
      InvalidUpgradeStateError: InvalidUpgradeStateError
    };
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c6", ["9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    exports = module.exports = SemVer;
    var debug;
    if (typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG))
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift('SEMVER');
        console.log.apply(console, args);
      };
    else
      debug = function() {};
    exports.SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var re = exports.re = [];
    var src = exports.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
    var MAINVERSION = R++;
    src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';
    var PRERELEASE = R++;
    src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
    var BUILD = R++;
    src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
    var FULL = R++;
    var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';
    src[FULL] = '^' + FULLPLAIN + '$';
    var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';
    var LOOSE = R++;
    src[LOOSE] = '^' + LOOSEPLAIN + '$';
    var GTLT = R++;
    src[GTLT] = '((?:<|>)?=?)';
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';
    var XRANGE = R++;
    src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
    var LONETILDE = R++;
    src[LONETILDE] = '(?:~>?)';
    var TILDETRIM = R++;
    src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
    re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    var TILDE = R++;
    src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
    var TILDELOOSE = R++;
    src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
    var LONECARET = R++;
    src[LONECARET] = '(?:\\^)';
    var CARETTRIM = R++;
    src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
    re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    var CARET = R++;
    src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
    var CARETLOOSE = R++;
    src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
    var COMPARATOR = R++;
    src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$';
    var STAR = R++;
    src[STAR] = '(<|>)?=?\\s*\\*';
    for (var i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i])
        re[i] = new RegExp(src[i]);
    }
    exports.parse = parse;
    function parse(version, loose) {
      if (version instanceof SemVer)
        return version;
      if (typeof version !== 'string')
        return null;
      if (version.length > MAX_LENGTH)
        return null;
      var r = loose ? re[LOOSE] : re[FULL];
      if (!r.test(version))
        return null;
      try {
        return new SemVer(version, loose);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version, loose) {
      var v = parse(version, loose);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version, loose) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version, loose) {
      if (version instanceof SemVer) {
        if (version.loose === loose)
          return version;
        else
          version = version.version;
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }
      if (version.length > MAX_LENGTH)
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
      if (!(this instanceof SemVer))
        return new SemVer(version, loose);
      debug('SemVer', version, loose);
      this.loose = loose;
      var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
      if (!m)
        throw new TypeError('Invalid Version: ' + version);
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0)
        throw new TypeError('Invalid major version');
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
        throw new TypeError('Invalid minor version');
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
        throw new TypeError('Invalid patch version');
      if (!m[4])
        this.prerelease = [];
      else
        this.prerelease = m[4].split('.').map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER)
              return num;
          }
          return id;
        });
      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + '.' + this.minor + '.' + this.patch;
      if (this.prerelease.length)
        this.version += '-' + this.prerelease.join('.');
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug('SemVer.compare', this.version, this.loose, other);
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
      if (this.prerelease.length && !other.prerelease.length)
        return -1;
      else if (!this.prerelease.length && other.prerelease.length)
        return 1;
      else if (!this.prerelease.length && !other.prerelease.length)
        return 0;
      var i = 0;
      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);
        if (a === undefined && b === undefined)
          return 0;
        else if (b === undefined)
          return 1;
        else if (a === undefined)
          return -1;
        else if (a === b)
          continue;
        else
          return compareIdentifiers(a, b);
      } while (++i);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;
        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;
        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
        case 'prerelease':
          if (this.prerelease.length === 0)
            this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
            this.major++;
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0)
            this.minor++;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'patch':
          if (this.prerelease.length === 0)
            this.patch++;
          this.prerelease = [];
          break;
        case 'pre':
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            var i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1)
              this.prerelease.push(0);
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1]))
                this.prerelease = [identifier, 0];
            } else
              this.prerelease = [identifier, 0];
          }
          break;
        default:
          throw new Error('invalid increment argument: ' + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof(loose) === 'string') {
        identifier = loose;
        loose = undefined;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        if (v1.prerelease.length || v2.prerelease.length) {
          for (var key in v1) {
            if (key === 'major' || key === 'minor' || key === 'patch') {
              if (v1[key] !== v2[key]) {
                return 'pre' + key;
              }
            }
          }
          return 'prerelease';
        }
        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return key;
            }
          }
        }
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return (anum && !bnum) ? -1 : (bnum && !anum) ? 1 : a < b ? -1 : a > b ? 1 : 0;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(b);
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compare(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.rcompare(a, b, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      var ret;
      switch (op) {
        case '===':
          if (typeof a === 'object')
            a = a.version;
          if (typeof b === 'object')
            b = b.version;
          ret = a === b;
          break;
        case '!==':
          if (typeof a === 'object')
            a = a.version;
          if (typeof b === 'object')
            b = b.version;
          ret = a !== b;
          break;
        case '':
        case '=':
        case '==':
          ret = eq(a, b, loose);
          break;
        case '!=':
          ret = neq(a, b, loose);
          break;
        case '>':
          ret = gt(a, b, loose);
          break;
        case '>=':
          ret = gte(a, b, loose);
          break;
        case '<':
          ret = lt(a, b, loose);
          break;
        case '<=':
          ret = lte(a, b, loose);
          break;
        default:
          throw new TypeError('Invalid operator: ' + op);
      }
      return ret;
    }
    exports.Comparator = Comparator;
    function Comparator(comp, loose) {
      if (comp instanceof Comparator) {
        if (comp.loose === loose)
          return comp;
        else
          comp = comp.value;
      }
      if (!(this instanceof Comparator))
        return new Comparator(comp, loose);
      debug('comparator', comp, loose);
      this.loose = loose;
      this.parse(comp);
      if (this.semver === ANY)
        this.value = '';
      else
        this.value = this.operator + this.semver.version;
      debug('comp', this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m)
        throw new TypeError('Invalid comparator: ' + comp);
      this.operator = m[1];
      if (this.operator === '=')
        this.operator = '';
      if (!m[2])
        this.semver = ANY;
      else
        this.semver = new SemVer(m[2], this.loose);
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug('Comparator.test', version, this.loose);
      if (this.semver === ANY)
        return true;
      if (typeof version === 'string')
        version = new SemVer(version, this.loose);
      return cmp(version, this.operator, this.semver, this.loose);
    };
    exports.Range = Range;
    function Range(range, loose) {
      if ((range instanceof Range) && range.loose === loose)
        return range;
      if (!(this instanceof Range))
        return new Range(range, loose);
      this.loose = loose;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range) {
        return this.parseRange(range.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.loose;
      range = range.trim();
      debug('range', range, loose);
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(' ');
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(' ').map(function(comp) {
        return parseComparator(comp, loose);
      }).join(' ').split(/\s+/);
      if (this.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, loose);
      });
      return set;
    };
    exports.toComparators = toComparators;
    function toComparators(range, loose) {
      return new Range(range, loose).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }
    function parseComparator(comp, loose) {
      debug('comp', comp);
      comp = replaceCarets(comp, loose);
      debug('caret', comp);
      comp = replaceTildes(comp, loose);
      debug('tildes', comp);
      comp = replaceXRanges(comp, loose);
      debug('xrange', comp);
      comp = replaceStars(comp, loose);
      debug('stars', comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }
    function replaceTildes(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp) {
        return replaceTilde(comp, loose);
      }).join(' ');
    }
    function replaceTilde(comp, loose) {
      var r = loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;
        if (isX(M))
          ret = '';
        else if (isX(m))
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        else if (isX(p))
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        else if (pr) {
          debug('replaceTilde pr', pr);
          if (pr.charAt(0) !== '-')
            pr = '-' + pr;
          ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
        } else
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        debug('tilde return', ret);
        return ret;
      });
    }
    function replaceCarets(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp) {
        return replaceCaret(comp, loose);
      }).join(' ');
    }
    function replaceCaret(comp, loose) {
      debug('caret', comp, loose);
      var r = loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;
        if (isX(M))
          ret = '';
        else if (isX(m))
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        else if (isX(p)) {
          if (M === '0')
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          else
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
        } else if (pr) {
          debug('replaceCaret pr', pr);
          if (pr.charAt(0) !== '-')
            pr = '-' + pr;
          if (M === '0') {
            if (m === '0')
              ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + m + '.' + (+p + 1);
            else
              ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
          } else
            ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + (+M + 1) + '.0.0';
        } else {
          debug('no pr');
          if (M === '0') {
            if (m === '0')
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
            else
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
          } else
            ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
        }
        debug('caret return', ret);
        return ret;
      });
    }
    function replaceXRanges(comp, loose) {
      debug('replaceXRanges', comp, loose);
      return comp.split(/\s+/).map(function(comp) {
        return replaceXRange(comp, loose);
      }).join(' ');
    }
    function replaceXRange(comp, loose) {
      comp = comp.trim();
      var r = loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === '=' && anyX)
          gtlt = '';
        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            ret = '<0.0.0';
          } else {
            ret = '*';
          }
        } else if (gtlt && anyX) {
          if (xm)
            m = 0;
          if (xp)
            p = 0;
          if (gtlt === '>') {
            gtlt = '>=';
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else if (xp) {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            gtlt = '<';
            if (xm)
              M = +M + 1;
            else
              m = +m + 1;
          }
          ret = gtlt + M + '.' + m + '.' + p;
        } else if (xm) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        }
        debug('xRange return', ret);
        return ret;
      });
    }
    function replaceStars(comp, loose) {
      debug('replaceStars', comp, loose);
      return comp.trim().replace(re[STAR], '');
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM))
        from = '';
      else if (isX(fm))
        from = '>=' + fM + '.0.0';
      else if (isX(fp))
        from = '>=' + fM + '.' + fm + '.0';
      else
        from = '>=' + from;
      if (isX(tM))
        to = '';
      else if (isX(tm))
        to = '<' + (+tM + 1) + '.0.0';
      else if (isX(tp))
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      else if (tpr)
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      else
        to = '<=' + to;
      return (from + ' ' + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version)
        return false;
      if (typeof version === 'string')
        version = new SemVer(version, this.loose);
      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version))
          return true;
      }
      return false;
    };
    function testSet(set, version) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version))
          return false;
      }
      if (version.prerelease.length) {
        for (var i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === ANY)
            continue;
          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch)
              return true;
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version, range, loose) {
      try {
        range = new Range(range, loose);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, loose) {
      return versions.filter(function(version) {
        return satisfies(version, range, loose);
      }).sort(function(a, b) {
        return rcompare(a, b, loose);
      })[0] || null;
    }
    exports.validRange = validRange;
    function validRange(range, loose) {
      try {
        return new Range(range, loose).range || '*';
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version, range, loose) {
      return outside(version, range, '<', loose);
    }
    exports.gtr = gtr;
    function gtr(version, range, loose) {
      return outside(version, range, '>', loose);
    }
    exports.outside = outside;
    function outside(version, range, hilo, loose) {
      version = new SemVer(version, loose);
      range = new Range(range, loose);
      var gtfn,
          ltefn,
          ltfn,
          comp,
          ecomp;
      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;
        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, loose)) {
        return false;
      }
      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, loose)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, loose)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6a", ["c6"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('c6');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c7", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = preferredCharsets;
  preferredCharsets.preferredCharsets = preferredCharsets;
  function parseAcceptCharset(accept) {
    var accepts = accept.split(',');
    for (var i = 0,
        j = 0; i < accepts.length; i++) {
      var charset = parseCharset(accepts[i].trim(), i);
      if (charset) {
        accepts[j++] = charset;
      }
    }
    accepts.length = j;
    return accepts;
  }
  function parseCharset(s, i) {
    var match = s.match(/^\s*(\S+?)\s*(?:;(.*))?$/);
    if (!match)
      return null;
    var charset = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(';');
      for (var i = 0; i < params.length; i++) {
        var p = params[i].trim().split('=');
        if (p[0] === 'q') {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset: charset,
      q: q,
      i: i
    };
  }
  function getCharsetPriority(charset, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(charset, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(charset, spec, index) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== '*') {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }
  function preferredCharsets(accept, provided) {
    var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(function getCharset(spec) {
        return spec.charset;
      });
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getCharsetPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c8", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = preferredEncodings;
  preferredEncodings.preferredEncodings = preferredEncodings;
  function parseAcceptEncoding(accept) {
    var accepts = accept.split(',');
    var hasIdentity = false;
    var minQuality = 1;
    for (var i = 0,
        j = 0; i < accepts.length; i++) {
      var encoding = parseEncoding(accepts[i].trim(), i);
      if (encoding) {
        accepts[j++] = encoding;
        hasIdentity = hasIdentity || specify('identity', encoding);
        minQuality = Math.min(minQuality, encoding.q || 1);
      }
    }
    if (!hasIdentity) {
      accepts[j++] = {
        encoding: 'identity',
        q: minQuality,
        i: i
      };
    }
    accepts.length = j;
    return accepts;
  }
  function parseEncoding(s, i) {
    var match = s.match(/^\s*(\S+?)\s*(?:;(.*))?$/);
    if (!match)
      return null;
    var encoding = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(';');
      for (var i = 0; i < params.length; i++) {
        var p = params[i].trim().split('=');
        if (p[0] === 'q') {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding: encoding,
      q: q,
      i: i
    };
  }
  function getEncodingPriority(encoding, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(encoding, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(encoding, spec, index) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== '*') {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }
  ;
  function preferredEncodings(accept, provided) {
    var accepts = parseAcceptEncoding(accept || '');
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(function getEncoding(spec) {
        return spec.encoding;
      });
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getEncodingPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c9", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = preferredLanguages;
  preferredLanguages.preferredLanguages = preferredLanguages;
  function parseAcceptLanguage(accept) {
    var accepts = accept.split(',');
    for (var i = 0,
        j = 0; i < accepts.length; i++) {
      var langauge = parseLanguage(accepts[i].trim(), i);
      if (langauge) {
        accepts[j++] = langauge;
      }
    }
    accepts.length = j;
    return accepts;
  }
  function parseLanguage(s, i) {
    var match = s.match(/^\s*(\S+?)(?:-(\S+?))?\s*(?:;(.*))?$/);
    if (!match)
      return null;
    var prefix = match[1],
        suffix = match[2],
        full = prefix;
    if (suffix)
      full += "-" + suffix;
    var q = 1;
    if (match[3]) {
      var params = match[3].split(';');
      for (var i = 0; i < params.length; i++) {
        var p = params[i].split('=');
        if (p[0] === 'q')
          q = parseFloat(p[1]);
      }
    }
    return {
      prefix: prefix,
      suffix: suffix,
      q: q,
      i: i,
      full: full
    };
  }
  function getLanguagePriority(language, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(language, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(language, spec, index) {
    var p = parseLanguage(language);
    if (!p)
      return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== '*') {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }
  ;
  function preferredLanguages(accept, provided) {
    var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(function getLanguage(spec) {
        return spec.full;
      });
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getLanguagePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ca", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = preferredMediaTypes;
  preferredMediaTypes.preferredMediaTypes = preferredMediaTypes;
  function parseAccept(accept) {
    var accepts = splitMediaTypes(accept);
    for (var i = 0,
        j = 0; i < accepts.length; i++) {
      var mediaType = parseMediaType(accepts[i].trim(), i);
      if (mediaType) {
        accepts[j++] = mediaType;
      }
    }
    accepts.length = j;
    return accepts;
  }
  ;
  function parseMediaType(s, i) {
    var match = s.match(/\s*(\S+?)\/([^;\s]+)\s*(?:;(.*))?/);
    if (!match)
      return null;
    var type = match[1],
        subtype = match[2],
        full = "" + type + "/" + subtype,
        params = {},
        q = 1;
    if (match[3]) {
      params = match[3].split(';').map(function(s) {
        return s.trim().split('=');
      }).reduce(function(set, p) {
        var name = p[0].toLowerCase();
        var value = p[1];
        set[name] = value && value[0] === '"' && value[value.length - 1] === '"' ? value.substr(1, value.length - 2) : value;
        return set;
      }, params);
      if (params.q != null) {
        q = parseFloat(params.q);
        delete params.q;
      }
    }
    return {
      type: type,
      subtype: subtype,
      params: params,
      q: q,
      i: i,
      full: full
    };
  }
  function getMediaTypePriority(type, accepted, index) {
    var priority = {
      o: -1,
      q: 0,
      s: 0
    };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(type, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(type, spec, index) {
    var p = parseMediaType(type);
    var s = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != '*') {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != '*') {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function(k) {
        return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }
  function preferredMediaTypes(accept, provided) {
    var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(function getType(spec) {
        return spec.full;
      });
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getMediaTypePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  function quoteCount(string) {
    var count = 0;
    var index = 0;
    while ((index = string.indexOf('"', index)) !== -1) {
      count++;
      index++;
    }
    return count;
  }
  function splitMediaTypes(accept) {
    var accepts = accept.split(',');
    for (var i = 1,
        j = 0; i < accepts.length; i++) {
      if (quoteCount(accepts[j]) % 2 == 0) {
        accepts[++j] = accepts[i];
      } else {
        accepts[j] += ',' + accepts[i];
      }
    }
    accepts.length = j + 1;
    return accepts;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cb", ["c7", "c8", "c9", "ca"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var preferredCharsets = $__require('c7');
  var preferredEncodings = $__require('c8');
  var preferredLanguages = $__require('c9');
  var preferredMediaTypes = $__require('ca');
  module.exports = Negotiator;
  Negotiator.Negotiator = Negotiator;
  function Negotiator(request) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request);
    }
    this.request = request;
  }
  Negotiator.prototype.charset = function charset(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers['accept-charset'], available);
  };
  Negotiator.prototype.encoding = function encoding(available) {
    var set = this.encodings(available);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings(available) {
    return preferredEncodings(this.request.headers['accept-encoding'], available);
  };
  Negotiator.prototype.language = function language(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers['accept-language'], available);
  };
  Negotiator.prototype.mediaType = function mediaType(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("67", ["cb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('cb');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cc", ["cd", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(Buffer) {
    (function(_window) {
      'use strict';
      var _rng,
          _mathRNG,
          _nodeRNG,
          _whatwgRNG,
          _previousRoot;
      function setupBrowser() {
        var _crypto = _window.crypto || _window.msCrypto;
        if (!_rng && _crypto && _crypto.getRandomValues) {
          try {
            var _rnds8 = new Uint8Array(16);
            _whatwgRNG = _rng = function whatwgRNG() {
              _crypto.getRandomValues(_rnds8);
              return _rnds8;
            };
            _rng();
          } catch (e) {}
        }
        if (!_rng) {
          var _rnds = new Array(16);
          _mathRNG = _rng = function() {
            for (var i = 0,
                r; i < 16; i++) {
              if ((i & 0x03) === 0) {
                r = Math.random() * 0x100000000;
              }
              _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
            }
            return _rnds;
          };
          if ('undefined' !== typeof console && console.warn) {
            console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
          }
        }
      }
      function setupNode() {
        if ('function' === typeof $__require) {
          try {
            var _rb = $__require('cd').randomBytes;
            _nodeRNG = _rng = _rb && function() {
              return _rb(16);
            };
            _rng();
          } catch (e) {}
        }
      }
      if (_window) {
        setupBrowser();
      } else {
        setupNode();
      }
      var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;
      var _byteToHex = [];
      var _hexToByte = {};
      for (var i = 0; i < 256; i++) {
        _byteToHex[i] = (i + 0x100).toString(16).substr(1);
        _hexToByte[_byteToHex[i]] = i;
      }
      function parse(s, buf, offset) {
        var i = (buf && offset) || 0,
            ii = 0;
        buf = buf || [];
        s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
          if (ii < 16) {
            buf[i + ii++] = _hexToByte[oct];
          }
        });
        while (ii < 16) {
          buf[i + ii++] = 0;
        }
        return buf;
      }
      function unparse(buf, offset) {
        var i = offset || 0,
            bth = _byteToHex;
        return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
      }
      var _seedBytes = _rng();
      var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];
      var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
      var _lastMSecs = 0,
          _lastNSecs = 0;
      function v1(options, buf, offset) {
        var i = buf && offset || 0;
        var b = buf || [];
        options = options || {};
        var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;
        var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();
        var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;
        var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs) / 10000;
        if (dt < 0 && options.clockseq == null) {
          clockseq = clockseq + 1 & 0x3fff;
        }
        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
          nsecs = 0;
        }
        if (nsecs >= 10000) {
          throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
        }
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
        msecs += 12219292800000;
        var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
        b[i++] = tl >>> 24 & 0xff;
        b[i++] = tl >>> 16 & 0xff;
        b[i++] = tl >>> 8 & 0xff;
        b[i++] = tl & 0xff;
        var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
        b[i++] = tmh >>> 8 & 0xff;
        b[i++] = tmh & 0xff;
        b[i++] = tmh >>> 24 & 0xf | 0x10;
        b[i++] = tmh >>> 16 & 0xff;
        b[i++] = clockseq >>> 8 | 0x80;
        b[i++] = clockseq & 0xff;
        var node = options.node || _nodeId;
        for (var n = 0; n < 6; n++) {
          b[i + n] = node[n];
        }
        return buf ? buf : unparse(b);
      }
      function v4(options, buf, offset) {
        var i = buf && offset || 0;
        if (typeof(options) === 'string') {
          buf = (options === 'binary') ? new BufferClass(16) : null;
          options = null;
        }
        options = options || {};
        var rnds = options.random || (options.rng || _rng)();
        rnds[6] = (rnds[6] & 0x0f) | 0x40;
        rnds[8] = (rnds[8] & 0x3f) | 0x80;
        if (buf) {
          for (var ii = 0; ii < 16; ii++) {
            buf[i + ii] = rnds[ii];
          }
        }
        return buf || unparse(rnds);
      }
      var uuid = v4;
      uuid.v1 = v1;
      uuid.v4 = v4;
      uuid.parse = parse;
      uuid.unparse = unparse;
      uuid.BufferClass = BufferClass;
      uuid._rng = _rng;
      uuid._mathRNG = _mathRNG;
      uuid._nodeRNG = _nodeRNG;
      uuid._whatwgRNG = _whatwgRNG;
      if (('undefined' !== typeof module) && module.exports) {
        module.exports = uuid;
      } else if (typeof define === 'function' && define.amd) {
        define(function() {
          return uuid;
        });
      } else {
        _previousRoot = _window.uuid;
        uuid.noConflict = function() {
          _window.uuid = _previousRoot;
          return uuid;
        };
        _window.uuid = uuid;
      }
    })('undefined' !== typeof window ? window : null);
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5d", ["cc"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('cc');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ce", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ID = 0;
  var MAX_INT = Math.pow(2, 32) - 1;
  var PROBES = {
    'route-start': ['char *', 'char *', 'int', 'char *', 'char *', 'json'],
    'handler-start': ['char *', 'char *', 'char *', 'int'],
    'handler-done': ['char *', 'char *', 'char *', 'int'],
    'route-done': ['char *', 'char *', 'int', 'int', 'json'],
    'client-request': ['char *', 'char *', 'json', 'int'],
    'client-response': ['int', 'int', 'json'],
    'client-error': ['id', 'char *']
  };
  var PROVIDER;
  module.exports = (function exportStaticProvider() {
    if (!PROVIDER) {
      PROVIDER = {
        fire: function() {},
        enable: function() {},
        addProbe: function() {
          var p = {fire: function() {}};
          return (p);
        },
        removeProbe: function() {},
        disable: function() {}
      };
      PROVIDER._rstfy_probes = {};
      Object.keys(PROBES).forEach(function(p) {
        var args = PROBES[p].splice(0);
        args.unshift(p);
        var probe = PROVIDER.addProbe.apply(PROVIDER, args);
        PROVIDER._rstfy_probes[p] = probe;
      });
      PROVIDER.enable();
      PROVIDER.nextId = function nextId() {
        if (++ID >= MAX_INT) {
          ID = 1;
        }
        return (ID);
      };
    }
    return (PROVIDER);
  }());
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cf", ["7d", "68", "59", "5a", "d0", "67", "5d", "ce", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var http = $__require('7d');
    var url = $__require('68');
    var sprintf = $__require('59').format;
    var assert = $__require('5a');
    var mime = $__require('d0');
    var Negotatior = $__require('67');
    var uuid = $__require('5d');
    var dtrace = $__require('ce');
    var Request = http.IncomingMessage;
    function negotiator(req) {
      var h = req.headers;
      if (!req._negotatiator) {
        req._negotiator = new Negotatior({headers: {
            accept: h.accept || '*/*',
            'accept-encoding': h['accept-encoding'] || 'identity'
          }});
      }
      return (req._negotiator);
    }
    Request.prototype.absoluteUri = function absoluteUri(path) {
      assert.string(path, 'path');
      var protocol = this.secure ? 'https://' : 'http://';
      var hostname = this.headers.host;
      return (url.resolve(protocol + hostname + this.path() + '/', path));
    };
    Request.prototype.accepts = function accepts(types) {
      if (typeof(types) === 'string') {
        types = [types];
      }
      types = types.map(function(t) {
        assert.string(t, 'type');
        if (t.indexOf('/') === -1) {
          t = mime.lookup(t);
        }
        return (t);
      });
      negotiator(this);
      return (this._negotiator.preferredMediaType(types));
    };
    Request.prototype.acceptsEncoding = function acceptsEncoding(types) {
      if (typeof(types) === 'string') {
        types = [types];
      }
      assert.arrayOfString(types, 'types');
      negotiator(this);
      return (this._negotiator.preferredEncoding(types));
    };
    Request.prototype.getContentLength = function getContentLength() {
      if (this._clen !== undefined) {
        return (this._clen === false ? undefined : this._clen);
      }
      if (this.isUpgradeRequest()) {
        return (0);
      }
      var len = this.header('content-length');
      if (!len) {
        this._clen = false;
      } else {
        this._clen = parseInt(len, 10);
      }
      return (this._clen === false ? undefined : this._clen);
    };
    Request.prototype.contentLength = Request.prototype.getContentLength;
    Request.prototype.getContentType = function getContentType() {
      if (this._contentType !== undefined) {
        return (this._contentType);
      }
      var index;
      var type = this.headers['content-type'];
      if (!type) {
        this._contentType = 'application/octet-stream';
      } else {
        if ((index = type.indexOf(';')) === -1) {
          this._contentType = type;
        } else {
          this._contentType = type.substring(0, index);
        }
      }
      this._contentType = this._contentType.toLowerCase();
      return (this._contentType);
    };
    Request.prototype.contentType = Request.prototype.getContentType;
    Request.prototype.date = function date() {
      if (this._date !== undefined) {
        return (this._date);
      }
      this._date = new Date(this._time);
      return (this._date);
    };
    Request.prototype.getHref = function getHref() {
      return (this.getUrl().href);
    };
    Request.prototype.href = Request.prototype.getHref;
    Request.prototype.getId = function getId() {
      if (this._id !== undefined) {
        return (this._id);
      }
      this._id = this.headers['request-id'] || this.headers['x-request-id'] || uuid.v4();
      return (this._id);
    };
    Request.prototype.id = Request.prototype.getId;
    Request.prototype.getPath = function getPath() {
      return (this.getUrl().pathname);
    };
    Request.prototype.path = Request.prototype.getPath;
    Request.prototype.getQuery = function getQuery() {
      return (this.getUrl().query || '');
    };
    Request.prototype.query = Request.prototype.getQuery;
    Request.prototype.time = function time() {
      return (this._time);
    };
    Request.prototype.getUrl = function getUrl() {
      if (this._cacheURL !== this.url) {
        this._url = url.parse(this.url);
        this._cacheURL = this.url;
      }
      return (this._url);
    };
    Request.prototype.getVersion = function getVersion() {
      if (this._version !== undefined) {
        return (this._version);
      }
      this._version = this.headers['accept-version'] || this.headers['x-api-version'] || '*';
      return (this._version);
    };
    Request.prototype.version = Request.prototype.getVersion;
    Request.prototype.matchedVersion = function matchedVersion() {
      if (this._matchedVersion !== undefined) {
        return (this._matchedVersion);
      } else {
        return (this.version());
      }
    };
    Request.prototype.header = function header(name, value) {
      assert.string(name, 'name');
      name = name.toLowerCase();
      if (name === 'referer' || name === 'referrer') {
        name = 'referer';
      }
      return (this.headers[name] || value);
    };
    Request.prototype.trailer = function trailer(name, value) {
      assert.string(name, 'name');
      name = name.toLowerCase();
      if (name === 'referer' || name === 'referrer') {
        name = 'referer';
      }
      return ((this.trailers || {})[name] || value);
    };
    Request.prototype.is = function is(type) {
      assert.string(type, 'type');
      var contentType = this.getContentType();
      var matches = true;
      if (!contentType) {
        return (false);
      }
      if (type.indexOf('/') === -1) {
        type = mime.lookup(type);
      }
      if (type.indexOf('*') !== -1) {
        type = type.split('/');
        contentType = contentType.split('/');
        matches &= (type[0] === '*' || type[0] === contentType[0]);
        matches &= (type[1] === '*' || type[1] === contentType[1]);
      } else {
        matches = (contentType === type);
      }
      return (matches);
    };
    Request.prototype.isChunked = function isChunked() {
      return (this.headers['transfer-encoding'] === 'chunked');
    };
    Request.prototype.isKeepAlive = function isKeepAlive() {
      if (this._keepAlive !== undefined) {
        return (this._keepAlive);
      }
      if (this.headers.connection) {
        this._keepAlive = /keep-alive/i.test(this.headers.connection);
      } else {
        this._keepAlive = this.httpVersion === '1.0' ? false : true;
      }
      return (this._keepAlive);
    };
    Request.prototype.isSecure = function isSecure() {
      if (this._secure !== undefined) {
        return (this._secure);
      }
      this._secure = this.connection.encrypted ? true : false;
      return (this._secure);
    };
    Request.prototype.isUpgradeRequest = function isUpgradeRequest() {
      if (this._upgradeRequest !== undefined) {
        return (this._upgradeRequest);
      } else {
        return (false);
      }
    };
    Request.prototype.isUpload = function isUpload() {
      var m = this.method;
      return (m === 'PATCH' || m === 'POST' || m === 'PUT');
    };
    Request.prototype.toString = function toString() {
      var headers = '';
      var self = this;
      var str;
      Object.keys(this.headers).forEach(function(k) {
        headers += sprintf('%s: %s\n', k, self.headers[k]);
      });
      str = sprintf('%s %s HTTP/%s\n%s', this.method, this.url, this.httpVersion, headers);
      return (str);
    };
    Request.prototype.userAgent = function userAgent() {
      return (this.headers['user-agent']);
    };
    Request.prototype.startHandlerTimer = function startHandlerTimer(handlerName) {
      var self = this;
      var name = (self._currentHandler === handlerName ? handlerName : self._currentHandler + '-' + handlerName);
      if (!self._timerMap) {
        self._timerMap = {};
      }
      self._timerMap[name] = process.hrtime();
      dtrace._rstfy_probes['handler-start'].fire(function() {
        return ([self.serverName, self._currentRoute, name, self._dtraceId]);
      });
    };
    Request.prototype.endHandlerTimer = function endHandlerTimer(handlerName) {
      var self = this;
      var name = (self._currentHandler === handlerName ? handlerName : self._currentHandler + '-' + handlerName);
      if (!self.timers) {
        self.timers = [];
      }
      self._timerMap[name] = process.hrtime(self._timerMap[name]);
      self.timers.push({
        name: name,
        time: self._timerMap[name]
      });
      dtrace._rstfy_probes['handler-done'].fire(function() {
        return ([self.serverName, self._currentRoute, name, self._dtraceId]);
      });
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d1", ["7d", "59", "68", "5a", "d0", "69", "d2", "66", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    'use strict';
    var http = $__require('7d');
    var sprintf = $__require('59').format;
    var url = $__require('68');
    var assert = $__require('5a');
    var mime = $__require('d0');
    var errors = $__require('69');
    var httpDate = $__require('d2');
    var utils = $__require('66');
    var InternalServerError = errors.InternalServerError;
    var Response = http.ServerResponse;
    var HEADER_ARRAY_BLACKLIST = {
      'set-cookie': true,
      'content-type': true
    };
    Response.prototype.cache = function cache(type, options) {
      if (typeof(type) !== 'string') {
        options = type;
        type = 'public';
      }
      if (options && options.maxAge !== undefined) {
        assert.number(options.maxAge, 'options.maxAge');
        type += ', max-age=' + options.maxAge;
      }
      return (this.header('Cache-Control', type));
    };
    Response.prototype.noCache = function noCache() {
      this.header('Cache-Control', 'no-cache, no-store, must-revalidate');
      this.header('Pragma', 'no-cache');
      this.header('Expires', '0');
      return (this);
    };
    Response.prototype.charSet = function charSet(type) {
      assert.string(type, 'charset');
      this._charSet = type;
      return (this);
    };
    Response.prototype.format = function format(body, cb) {
      var log = this.log;
      var formatter;
      var type = this.contentType || this.getHeader('Content-Type');
      var self = this;
      if (!type) {
        if (this.req.accepts(this.acceptable)) {
          type = this.req.accepts(this.acceptable);
        }
        if (!type) {
          if (this.statusCode >= 200 && this.statusCode < 300) {
            this.statusCode = 406;
          }
          return cb(null);
        }
      } else if (type.indexOf(';') !== '-1') {
        type = type.split(';')[0];
      }
      if (!(formatter = this.formatters[type])) {
        if (type.indexOf('/') === -1) {
          type = mime.lookup(type);
        }
        if (this.acceptable.indexOf(type) === -1) {
          type = 'application/octet-stream';
        }
        formatter = this.formatters[type] || this.formatters['*/*'];
        if (!formatter) {
          log.warn({req: self.req}, 'no formatter found. Returning 500.');
          this.statusCode = 500;
          return cb(null);
        }
      }
      if (this._charSet) {
        type = type + '; charset=' + this._charSet;
      }
      this.setHeader('Content-Type', type);
      if (body instanceof Error && body.statusCode !== undefined) {
        this.statusCode = body.statusCode;
      }
      return (formatter.call(this, this.req, this, body, cb));
    };
    Response.prototype.get = function get(name) {
      assert.string(name, 'name');
      return (this.getHeader(name));
    };
    Response.prototype.getHeaders = function getHeaders() {
      return (this._headers || {});
    };
    Response.prototype.headers = Response.prototype.getHeaders;
    Response.prototype.header = function header(name, value) {
      assert.string(name, 'name');
      if (value === undefined) {
        return (this.getHeader(name));
      }
      if (value instanceof Date) {
        value = httpDate(value);
      } else if (arguments.length > 2) {
        var arg = Array.prototype.slice.call(arguments).slice(2);
        value = sprintf(value, arg);
      }
      var current = this.getHeader(name);
      var nameLc = name.toLowerCase();
      if (current && !(nameLc in HEADER_ARRAY_BLACKLIST)) {
        if (Array.isArray(current)) {
          current.push(value);
          value = current;
        } else {
          value = [current, value];
        }
      }
      this.setHeader(name, value);
      return (value);
    };
    Response.prototype.json = function json(code, object, headers) {
      if (!/application\/json/.test(this.header('content-type'))) {
        this.header('Content-Type', 'application/json');
      }
      return (this.send(code, object, headers));
    };
    Response.prototype.link = function link(l, rel) {
      assert.string(l, 'link');
      assert.string(rel, 'rel');
      var _link = sprintf('<%s>; rel="%s"', l, rel);
      return (this.header('Link', _link));
    };
    Response.prototype.send = function send(code, body, headers) {
      var isHead = (this.req.method === 'HEAD');
      var log = this.log;
      var self = this;
      if (code === undefined) {
        this.statusCode = 200;
      } else if (typeof code === 'number') {
        this.statusCode = code;
        if (body instanceof Error) {
          body.statusCode = this.statusCode;
        }
      } else {
        headers = body;
        body = code;
        code = null;
      }
      headers = headers || {};
      if (log.trace()) {
        var _props = {
          code: self.statusCode,
          headers: headers
        };
        if (body instanceof Error) {
          _props.err = body;
        } else {
          _props.body = body;
        }
        log.trace(_props, 'response::send entered');
      }
      this._body = body;
      function _cb(err, _body) {
        if (err) {
          self._data = null;
          self.statusCode = 500;
          log.error(err, 'unable to format response');
        } else {
          self._data = _body;
        }
        Object.keys(headers).forEach(function(k) {
          self.setHeader(k, headers[k]);
        });
        self.writeHead(self.statusCode);
        if (self._data && !(isHead || code === 204 || code === 304)) {
          self.write(self._data);
        }
        self.end();
        if (log.trace()) {
          log.trace({res: self}, 'response sent');
        }
      }
      if (body !== undefined) {
        this.format(body, _cb);
      } else {
        _cb(null, null);
      }
      return (this);
    };
    Response.prototype.set = function set(name, val) {
      var self = this;
      if (arguments.length === 2) {
        assert.string(name, 'res.set(name, val) requires name to be a string');
        this.header(name, val);
      } else {
        assert.object(name, 'res.set(headers) requires headers to be an object');
        Object.keys(name).forEach(function(k) {
          self.set(k, name[k]);
        });
      }
      return (this);
    };
    Response.prototype.status = function status(code) {
      assert.number(code, 'code');
      this.statusCode = code;
      return (code);
    };
    Response.prototype.toString = function toString() {
      var headers = this.getHeaders();
      var headerString = '';
      var str;
      Object.keys(headers).forEach(function(k) {
        headerString += k + ': ' + headers[k] + '\n';
      });
      str = sprintf('HTTP/1.1 %s %s\n%s', this.statusCode, http.STATUS_CODES[this.statusCode], headerString);
      return (str);
    };
    if (!Response.prototype.hasOwnProperty('_writeHead')) {
      Response.prototype._writeHead = Response.prototype.writeHead;
    }
    Response.prototype.writeHead = function restifyWriteHead() {
      this.emit('header');
      if (this.statusCode === 204 || this.statusCode === 304) {
        this.removeHeader('Content-Length');
        this.removeHeader('Content-MD5');
        this.removeHeader('Content-Type');
        this.removeHeader('Content-Encoding');
      }
      this._writeHead.apply(this, arguments);
    };
    Response.prototype.redirect = function redirect(arg1, arg2, arg3) {
      var self = this;
      var statusCode = 302;
      var finalUri;
      var redirectLocation;
      var next;
      if (arg1 && !isNaN(arg1)) {
        statusCode = arg1;
        finalUri = arg2;
        next = arg3;
      } else if (typeof(arg1) === 'string') {
        finalUri = arg1;
        next = arg2;
      } else if (typeof(arg1) === 'object') {
        next = arg2;
        var req = self.req;
        var opt = arg1 || {};
        var currentFullPath = req.href();
        var secure = (opt.hasOwnProperty('secure')) ? opt.secure : req.isSecure();
        var parsedUri = url.parse(opt.hostname || currentFullPath, true);
        finalUri = {
          port: parsedUri.port,
          hostname: parsedUri.hostname,
          query: parsedUri.query,
          pathname: parsedUri.pathname
        };
        finalUri.protocol = (secure === true) ? 'https' : 'http';
        if (opt.hostname) {
          finalUri.hostname = opt.hostname;
        }
        if (opt.pathname) {
          finalUri.pathname = opt.pathname;
        }
        if (opt.query) {
          if (opt.overrideQuery === true) {
            finalUri.query = opt.query;
          } else {
            finalUri.query = utils.mergeQs(opt.query, finalUri.query);
          }
        }
        if (opt.permanent) {
          statusCode = 301;
        }
      }
      assert.func(next, 'res.redirect() requires a next param');
      if (!finalUri) {
        return (next(new InternalServerError('could not construct url')));
      }
      redirectLocation = url.format(finalUri);
      self.emit('redirect', redirectLocation);
      self.send(statusCode, null, {Location: redirectLocation});
      return (next(false));
    };
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d3", ["6e", "1a", "7d", "7e", "59", "69", "5a", "d0", "d5", "c4", "5d", "d6", "ce", "d4", "66", "c5", "6a", "cf", "d1", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var domain = $__require('6e');
    var EventEmitter = $__require('1a').EventEmitter;
    var http = $__require('7d');
    var https = $__require('7e');
    var util = $__require('59');
    var errors = $__require('69');
    var assert = $__require('5a');
    var mime = $__require('d0');
    var once = $__require('d5');
    var spdy = $__require('c4');
    var uuid = $__require('5d');
    var vasync = $__require('d6');
    var dtrace = $__require('ce');
    var formatters = $__require('d4');
    var shallowCopy = $__require('66').shallowCopy;
    var upgrade = $__require('c5');
    var semver = $__require('6a');
    var maxSatisfying = semver.maxSatisfying;
    $__require('cf');
    $__require('d1');
    var sprintf = util.format;
    var ResourceNotFoundError = errors.ResourceNotFoundError;
    var PROXY_EVENTS = ['clientError', 'close', 'connection', 'error', 'listening', 'secureConnection'];
    function argumentsToChain(args, start) {
      assert.ok(args);
      args = Array.prototype.slice.call(args, start);
      if (args.length < 0) {
        throw new TypeError('handler (function) required');
      }
      var chain = [];
      function process(handlers) {
        for (var i = 0; i < handlers.length; i++) {
          if (Array.isArray(handlers[i])) {
            process(handlers[i], 0);
          } else {
            assert.func(handlers[i], 'handler');
            chain.push(handlers[i]);
          }
        }
        return (chain);
      }
      return (process(args));
    }
    function mergeFormatters(fmt) {
      var arr = [];
      var obj = {};
      function addFormatter(src, k) {
        assert.func(src[k], 'formatter');
        var q = 1.0;
        var t = k;
        if (k.indexOf(';') !== -1) {
          var tmp = k.split(/\s*;\s*/);
          t = tmp[0];
          if (tmp[1].indexOf('q=') !== -1) {
            q = parseFloat(tmp[1].split('=')[1]);
          }
        }
        if (k.indexOf('/') === -1) {
          k = mime.lookup(k);
        }
        obj[t] = src[k];
        arr.push({
          q: q,
          t: t
        });
      }
      Object.keys(formatters).forEach(addFormatter.bind(this, formatters));
      Object.keys(fmt || {}).forEach(addFormatter.bind(this, fmt || {}));
      arr = arr.sort(function(a, b) {
        return (b.q - a.q);
      }).map(function(a) {
        return (a.t);
      });
      return ({
        formatters: obj,
        acceptable: arr
      });
    }
    function ifError(n) {
      function _ifError(err) {
        if (err) {
          err._restify_next = n;
          throw err;
        }
      }
      return (_ifError);
    }
    function emitRouteError(server, req, res, err) {
      var name;
      if (err.name === 'ResourceNotFoundError') {
        name = 'NotFound';
      } else if (err.name === 'InvalidVersionError') {
        name = 'VersionNotAllowed';
      } else {
        name = err.name.replace(/Error$/, '');
      }
      req.log.trace({
        name: name,
        err: err
      }, 'entering emitRouteError');
      if (server.listeners(name).length > 0) {
        server.emit(name, req, res, err, once(function() {
          server.emit('after', req, res, null);
        }));
      } else {
        res.send(err);
        server.emit('after', req, res, null);
      }
    }
    function optionsError(err, req, res) {
      var code = err.statusCode;
      var ok = false;
      if (code === 404 && req.method === 'OPTIONS' && req.url === '*') {
        res.send(200);
        ok = true;
      }
      return (ok);
    }
    function Server(options) {
      assert.object(options, 'options');
      assert.object(options.log, 'options.log');
      assert.object(options.router, 'options.router');
      var self = this;
      EventEmitter.call(this);
      this.before = [];
      this.chain = [];
      this.log = options.log;
      this.name = options.name || 'restify';
      this.router = options.router;
      this.routes = {};
      this.secure = false;
      this.versions = options.versions || options.version || [];
      this.socketio = options.socketio || false;
      var fmt = mergeFormatters(options.formatters);
      this.acceptable = fmt.acceptable;
      this.formatters = fmt.formatters;
      if (options.spdy) {
        this.spdy = true;
        this.server = spdy.createServer(options.spdy);
      } else if ((options.cert || options.certificate) && options.key) {
        this.ca = options.ca;
        this.certificate = options.certificate || options.cert;
        this.key = options.key;
        this.passphrase = options.passphrase || null;
        this.secure = true;
        this.server = https.createServer({
          ca: self.ca,
          cert: self.certificate,
          key: self.key,
          passphrase: self.passphrase,
          rejectUnauthorized: options.rejectUnauthorized,
          requestCert: options.requestCert,
          ciphers: options.ciphers
        });
      } else if (options.httpsServerOptions) {
        this.server = https.createServer(options.httpsServerOptions);
      } else {
        this.server = http.createServer();
      }
      this.router.on('mount', this.emit.bind(this, 'mount'));
      if (!options.handleUpgrades && PROXY_EVENTS.indexOf('upgrade') === -1) {
        PROXY_EVENTS.push('upgrade');
      }
      PROXY_EVENTS.forEach(function(e) {
        self.server.on(e, self.emit.bind(self, e));
      });
      this.server.on('checkContinue', function onCheckContinue(req, res) {
        if (self.listeners('checkContinue').length > 0) {
          self.emit('checkContinue', req, res);
          return;
        }
        if (!options.noWriteContinue) {
          res.writeContinue();
        }
        self._setupRequest(req, res);
        self._handle(req, res, true);
      });
      if (options.handleUpgrades) {
        this.server.on('upgrade', function onUpgrade(req, socket, head) {
          req._upgradeRequest = true;
          var res = upgrade.createResponse(req, socket, head);
          self._setupRequest(req, res);
          self._handle(req, res);
        });
      }
      this.server.on('request', function onRequest(req, res) {
        self.emit('request', req, res);
        if (options.socketio && (/^\/socket\.io.*/).test(req.url)) {
          return;
        }
        self._setupRequest(req, res);
        self._handle(req, res);
      });
      this.__defineGetter__('maxHeadersCount', function() {
        return (self.server.maxHeadersCount);
      });
      this.__defineSetter__('maxHeadersCount', function(c) {
        self.server.maxHeadersCount = c;
        return (c);
      });
      this.__defineGetter__('url', function() {
        if (self.socketPath) {
          return ('http://' + self.socketPath);
        }
        var addr = self.address();
        var str = '';
        if (self.spdy) {
          str += 'spdy://';
        } else if (self.secure) {
          str += 'https://';
        } else {
          str += 'http://';
        }
        if (addr) {
          str += addr.family === 'IPv6' ? '[' + addr.address + ']' : addr.address;
          str += ':';
          str += addr.port;
        } else {
          str += '169.254.0.1:0000';
        }
        return (str);
      });
    }
    util.inherits(Server, EventEmitter);
    module.exports = Server;
    Server.prototype.address = function address() {
      return (this.server.address());
    };
    Server.prototype.listen = function listen() {
      var args = Array.prototype.slice.call(arguments);
      return (this.server.listen.apply(this.server, args));
    };
    Server.prototype.close = function close(callback) {
      if (callback) {
        assert.func(callback, 'callback');
      }
      this.server.once('close', function onClose() {
        return (callback ? callback() : false);
      });
      return (this.server.close());
    };
    ['del', 'get', 'head', 'opts', 'post', 'put', 'patch'].forEach(function(method) {
      Server.prototype[method] = function(opts) {
        if (opts instanceof RegExp || typeof(opts) === 'string') {
          opts = {path: opts};
        } else if (typeof(opts) === 'object') {
          opts = shallowCopy(opts);
        } else {
          throw new TypeError('path (string) required');
        }
        if (arguments.length < 2) {
          throw new TypeError('handler (function) required');
        }
        var chain = [];
        var route;
        var self = this;
        function addHandler(h) {
          assert.func(h, 'handler');
          chain.push(h);
        }
        if (method === 'del') {
          method = 'DELETE';
        }
        if (method === 'opts') {
          method = 'OPTIONS';
        }
        opts.method = method.toUpperCase();
        opts.versions = opts.versions || opts.version || self.versions;
        if (!Array.isArray(opts.versions)) {
          opts.versions = [opts.versions];
        }
        if (!opts.name) {
          opts.name = method + '-' + (opts.path || opts.url);
          if (opts.versions.length > 0) {
            opts.name += '-' + opts.versions.join('--');
          }
          opts.name = opts.name.replace(/\W/g, '').toLowerCase();
          if (this.router.mounts[opts.name]) {
            opts.name += uuid.v4().substr(0, 7);
          }
        }
        if (!(route = this.router.mount(opts))) {
          return (false);
        }
        this.chain.forEach(addHandler);
        argumentsToChain(arguments, 1).forEach(addHandler);
        this.routes[route] = chain;
        return (route);
      };
    });
    Server.prototype.param = function param(name, fn) {
      this.use(function _param(req, res, next) {
        if (req.params && req.params[name]) {
          fn.call(this, req, res, next, req.params[name], name);
        } else {
          next();
        }
      });
      return (this);
    };
    Server.prototype.versionedUse = function versionedUse(versions, fn) {
      if (!Array.isArray(versions)) {
        versions = [versions];
      }
      assert.arrayOfString(versions, 'versions');
      versions.forEach(function(v) {
        if (!semver.valid(v)) {
          throw new TypeError('%s is not a valid semver', v);
        }
      });
      this.use(function _versionedUse(req, res, next) {
        var ver;
        if (req.version() === '*' || (ver = maxSatisfying(versions, req.version()) || false)) {
          fn.call(this, req, res, next, ver);
        } else {
          next();
        }
      });
      return (this);
    };
    Server.prototype.rm = function rm(route) {
      var r = this.router.unmount(route);
      if (r && this.routes[r]) {
        delete this.routes[r];
      }
      return (r);
    };
    Server.prototype.use = function use() {
      var self = this;
      (argumentsToChain(arguments) || []).forEach(function(h) {
        self.chain.push(h);
      });
      return (this);
    };
    Server.prototype.pre = function pre() {
      var self = this;
      argumentsToChain(arguments).forEach(function(h) {
        self.before.push(h);
      });
      return (this);
    };
    Server.prototype.toString = function toString() {
      var LINE_FMT = '\t%s: %s\n';
      var SUB_LINE_FMT = '\t\t%s: %s\n';
      var self = this;
      var str = '';
      function handlersToString(arr) {
        var s = '[' + arr.map(function(b) {
          return (b.name || 'function');
        }).join(', ') + ']';
        return (s);
      }
      str += sprintf(LINE_FMT, 'Accepts', this.acceptable.join(', '));
      str += sprintf(LINE_FMT, 'Name', this.name);
      str += sprintf(LINE_FMT, 'Pre', handlersToString(this.before));
      str += sprintf(LINE_FMT, 'Router', this.router.toString());
      str += sprintf(LINE_FMT, 'Routes', '');
      Object.keys(this.routes).forEach(function(k) {
        var handlers = handlersToString(self.routes[k]);
        str += sprintf(SUB_LINE_FMT, k, handlers);
      });
      str += sprintf(LINE_FMT, 'Secure', this.secure);
      str += sprintf(LINE_FMT, 'Url', this.url);
      str += sprintf(LINE_FMT, 'Version', Array.isArray(this.versions) ? this.versions.join() : this.versions);
      return (str);
    };
    Server.prototype._handle = function _handle(req, res) {
      var self = this;
      function routeAndRun() {
        self._route(req, res, function(route, context) {
          req.context = req.params = context;
          req.route = route.spec;
          var r = route ? route.name : null;
          var chain = self.routes[r];
          self._run(req, res, route, chain, function done(e) {
            self.emit('after', req, res, route, e);
          });
        });
      }
      if (this.before.length > 0) {
        this._run(req, res, null, this.before, function(err) {
          if (!err) {
            routeAndRun();
          }
        });
      } else {
        routeAndRun();
      }
    };
    Server.prototype._route = function _route(req, res, name, cb) {
      var self = this;
      if (typeof(name) === 'function') {
        cb = name;
        name = null;
        this.router.find(req, res, function onRoute(err, route, ctx) {
          var r = route ? route.name : null;
          if (err) {
            if (optionsError(err, req, res)) {
              self.emit('after', req, res, err);
            } else {
              emitRouteError(self, req, res, err);
            }
          } else if (r === 'preflight') {
            res.writeHead(200);
            res.end();
            self.emit('after', req, res, null);
          } else if (!r || !self.routes[r]) {
            err = new ResourceNotFoundError(req.path());
            emitRouteError(self, res, res, err);
          } else {
            cb(route, ctx);
          }
        });
      } else {
        this.router.get(name, req, function(err, route, ctx) {
          if (err) {
            emitRouteError(self, req, res, err);
          } else {
            cb(route, ctx);
          }
        });
      }
    };
    Server.prototype._run = function _run(req, res, route, chain, cb) {
      var d;
      var i = -1;
      var id = dtrace.nextId();
      req._dtraceId = id;
      if (!req._anonFuncCount) {
        req._anonFuncCount = 0;
      }
      var log = this.log;
      var self = this;
      var handlerName = null;
      var emittedError = false;
      var reqClosed = false;
      if (cb) {
        cb = once(cb);
      }
      function _requestClose() {
        reqClosed = true;
        req.clientClosed = true;
      }
      req.once('close', _requestClose);
      res.on('redirect', function(redirectLocation) {
        self.emit('redirect', redirectLocation);
      });
      function next(arg) {
        var done = false;
        if (arg) {
          if (arg instanceof Error) {
            var errName = arg.name.replace(/Error$/, '');
            log.trace({
              err: arg,
              errName: errName
            }, 'next(err=%s)', (arg.name || 'Error'));
            var hasErrListeners = false;
            var errEvtNames = [];
            if (self.listeners(errName).length > 0) {
              hasErrListeners = true;
              errEvtNames.push(errName);
            }
            if (self.listeners('restifyError').length > 0) {
              hasErrListeners = true;
              errEvtNames.push('restifyError');
            }
            if (hasErrListeners) {
              vasync.forEachPipeline({
                func: function emitError(errEvtName, vasyncCb) {
                  self.emit(errEvtName, req, res, arg, function errEvtHandlerDone() {
                    return vasyncCb();
                  });
                },
                inputs: errEvtNames
              }, function(err, results) {
                res.send(err || arg);
                return (cb ? cb(err || arg) : true);
              });
              emittedError = true;
            } else {
              res.send(arg);
            }
            done = true;
          } else if (typeof(arg) === 'string') {
            if (req._rstfy_chained_route) {
              var _e = new errors.InternalError();
              log.error({err: _e}, 'Multiple next("chain") calls not ' + 'supported');
              res.send(_e);
              return (false);
            }
            return self._route(req, res, arg, function(r, ctx) {
              req.context = req.params = ctx;
              req.route = r.spec;
              var _c = chain.slice(0, i + 1);
              function _uniq(fn) {
                return (_c.indexOf(fn) === -1);
              }
              var _routes = self.routes[r.name] || [];
              var _chain = _routes.filter(_uniq);
              req._rstfy_chained_route = true;
              if ((i + 1) > 0 && chain[i] && !chain[i]._skip) {
                req.endHandlerTimer(handlerName);
              }
              self._run(req, res, r, _chain, cb);
            });
          }
        }
        if (arg === false) {
          done = true;
        }
        if ((i + 1) > 0 && chain[i] && !chain[i]._skip) {
          req.endHandlerTimer(handlerName);
        }
        if (!done && chain[++i] && !reqClosed) {
          if (chain[i]._skip) {
            return (next());
          }
          if (log.trace()) {
            log.trace('running %s', chain[i].name || '?');
          }
          req._currentRoute = (route !== null ? route.name : 'pre');
          handlerName = (chain[i].name || ('handler-' + req._anonFuncCount++));
          req._currentHandler = handlerName;
          req.startHandlerTimer(handlerName);
          var n = once(next);
          n.ifError = ifError(n);
          return (chain[i].call(self, req, res, n));
        }
        dtrace._rstfy_probes['route-done'].fire(function() {
          return ([self.name, route !== null ? route.name : 'pre', id, res.statusCode || 200, res.headers()]);
        });
        if (route === null) {
          self.emit('preDone', req, res);
        } else {
          req.removeListener('close', _requestClose);
          self.emit('done', req, res, route);
        }
        if (!emittedError) {
          return (cb ? cb(arg) : true);
        } else {
          return (true);
        }
      }
      var n1 = once(next);
      n1.ifError = ifError(n1);
      dtrace._rstfy_probes['route-start'].fire(function() {
        return ([self.name, route !== null ? route.name : 'pre', id, req.method, req.href(), req.headers]);
      });
      d = domain.create();
      d.add(req);
      d.add(res);
      d.on('error', function onError(err) {
        if (err._restify_next) {
          err._restify_next(err);
        } else {
          log.trace({err: err}, 'uncaughtException');
          self.emit('uncaughtException', req, res, route, err);
        }
      });
      d.run(n1);
    };
    Server.prototype._setupRequest = function _setupRequest(req, res) {
      req.log = res.log = this.log;
      req._time = res._time = Date.now();
      req.serverName = this.name;
      res.acceptable = this.acceptable;
      res.formatters = this.formatters;
      res.req = req;
      res.serverName = this.name;
      res.version = this.router.versions[this.router.versions.length - 1];
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("66", ["5a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('5a');
  function sanitizePath(path) {
    assert.ok(path);
    path = path.replace(/\/\/+/g, '/');
    if (path.lastIndexOf('/') === (path.length - 1) && path.length > 1) {
      path = path.substr(0, path.length - 1);
    }
    return (path);
  }
  function shallowCopy(obj) {
    if (!obj) {
      return (obj);
    }
    var copy = {};
    Object.keys(obj).forEach(function(k) {
      copy[k] = obj[k];
    });
    return (copy);
  }
  function mergeQs(obj1, obj2) {
    var merged = shallowCopy(obj1) || {};
    if (obj2 && typeof(obj2) === 'object') {
      Object.keys(obj2).forEach(function(key) {
        if (merged.hasOwnProperty(key) && !(merged[key] instanceof Array)) {
          merged[key] = [merged[key]];
          merged[key].push(obj2[key]);
        } else {
          merged[key] = obj2[key];
        }
      });
    }
    return (merged);
  }
  module.exports = {
    sanitizePath: sanitizePath,
    shallowCopy: shallowCopy,
    mergeQs: mergeQs
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("65", ["5a", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var assert = $__require('5a');
    var ALLOW_HEADERS = ['accept', 'accept-version', 'content-type', 'request-id', 'origin', 'x-api-version', 'x-request-id'];
    var EXPOSE_HEADERS = ['api-version', 'content-length', 'content-md5', 'content-type', 'date', 'request-id', 'response-time'];
    var AC_ALLOW_ORIGIN = 'Access-Control-Allow-Origin';
    var AC_ALLOW_CREDS = 'Access-Control-Allow-Credentials';
    var AC_EXPOSE_HEADERS = 'Access-Control-Expose-Headers';
    function matchOrigin(req, origins) {
      var origin = req.headers.origin;
      function belongs(o) {
        if (origin === o || o === '*') {
          origin = o;
          return (true);
        }
        return (false);
      }
      return ((origin && origins.some(belongs)) ? origin : false);
    }
    function cors(opts) {
      assert.optionalObject(opts, 'options');
      opts = opts || {};
      assert.optionalArrayOfString(opts.origins, 'options.origins');
      assert.optionalBool(opts.credentials, 'options.credentials');
      assert.optionalArrayOfString(opts.headers, 'options.headers');
      cors.credentials = opts.credentials;
      cors.origins = opts.origins || ['*'];
      var headers = (opts.headers || []).slice(0);
      var origins = opts.origins || ['*'];
      EXPOSE_HEADERS.forEach(function(h) {
        if (headers.indexOf(h) === -1) {
          headers.push(h);
        }
      });
      function restifyCORSSimple(req, res, next) {
        var origin;
        if (!(origin = matchOrigin(req, origins))) {
          next();
          return;
        }
        function corsOnHeader() {
          origin = req.headers.origin;
          if (opts.credentials) {
            res.setHeader(AC_ALLOW_ORIGIN, origin);
            res.setHeader(AC_ALLOW_CREDS, 'true');
          } else {
            res.setHeader(AC_ALLOW_ORIGIN, origin);
          }
          res.setHeader(AC_EXPOSE_HEADERS, headers.join(', '));
        }
        res.once('header', corsOnHeader);
        next();
      }
      return (restifyCORSSimple);
    }
    module.exports = cors;
    cors.ALLOW_HEADERS = ALLOW_HEADERS;
    cors.EXPOSE_HEADERS = EXPOSE_HEADERS;
    cors.credentials = false;
    cors.origins = [];
    cors.matchOrigin = matchOrigin;
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d2", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function httpDate(now) {
    if (!now) {
      now = new Date();
    }
    return (now.toUTCString());
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d7", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    function formatJSONP(req, res, body, cb) {
      if (!body) {
        res.setHeader('Content-Length', 0);
        return (null);
      }
      if (body instanceof Error) {
        if ((body.restCode || body.httpCode) && body.body) {
          body = body.body;
        } else {
          body = {message: body.message};
        }
      }
      if (Buffer.isBuffer(body)) {
        body = body.toString('base64');
      }
      var _cb = req.query.callback || req.query.jsonp;
      var data;
      if (_cb) {
        data = 'typeof ' + _cb + ' === \'function\' && ' + _cb + '(' + JSON.stringify(body) + ');';
      } else {
        data = JSON.stringify(body);
      }
      res.setHeader('Content-Length', Buffer.byteLength(data));
      return cb(null, data);
    }
    module.exports = formatJSONP;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d8", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    function formatJSON(req, res, body, cb) {
      if (body instanceof Error) {
        res.statusCode = body.statusCode || 500;
        if (body.body) {
          body = body.body;
        } else {
          body = {message: body.message};
        }
      } else if (Buffer.isBuffer(body)) {
        body = body.toString('base64');
      }
      var data = JSON.stringify(body);
      res.setHeader('Content-Length', Buffer.byteLength(data));
      return cb(null, data);
    }
    module.exports = formatJSON;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d9", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    function formatText(req, res, body, cb) {
      if (body instanceof Error) {
        res.statusCode = body.statusCode || 500;
        body = body.message;
      } else if (typeof(body) === 'object') {
        body = JSON.stringify(body);
      } else {
        body = body.toString();
      }
      res.setHeader('Content-Length', Buffer.byteLength(body));
      return cb(null, body);
    }
    module.exports = formatText;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("da", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    function formatBinary(req, res, body, cb) {
      if (body instanceof Error) {
        res.statusCode = body.statusCode || 500;
      }
      if (!Buffer.isBuffer(body)) {
        body = new Buffer(body.toString());
      }
      res.setHeader('Content-Length', body.length);
      return cb(null, body);
    }
    module.exports = formatBinary;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d4", ["d7", "d8", "d9", "da"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    'application/javascript; q=0.1': $__require('d7'),
    'application/json; q=0.4': $__require('d8'),
    'text/plain; q=0.3': $__require('d9'),
    'application/octet-stream; q=0.2': $__require('da')
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("db", ["69", "57", "64", "d3", "66", "65", "d2", "d4", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var errors = $__require('69');
    var bunyan = $__require('57');
    var Router = $__require('64');
    var Server = $__require('d3');
    var shallowCopy = $__require('66').shallowCopy;
    var InternalError = errors.InternalError;
    function createServer(options) {
      var opts = shallowCopy(options || {});
      var server;
      opts.name = opts.name || 'restify';
      opts.log = opts.log || bunyan.createLogger(opts.name);
      opts.router = opts.router || new Router(opts);
      server = new Server(opts);
      server.on('uncaughtException', function(req, res, route, e) {
        if (this.listeners('uncaughtException').length > 1 || res.headersSent) {
          return (false);
        }
        res.send(new InternalError(e, e.message || 'unexpected error'));
        return (true);
      });
      return (server);
    }
    function realizeUrl(pattern, params) {
      var p = pattern.replace(/\/:([^/]+)/g, function(match, k) {
        return (params.hasOwnProperty(k) ? '/' + params[k] : match);
      });
      return ($__require('66').sanitizePath(p));
    }
    module.exports = {
      get bunyan() {
        return ($__require('57'));
      },
      errors: {}
    };
    if (!process.env.RESTIFY_CLIENT_ONLY) {
      var cors = $__require('65');
      module.exports.createServer = createServer;
      module.exports.httpDate = $__require('d2');
      module.exports.realizeUrl = realizeUrl;
      module.exports.formatters = $__require('d4');
      module.exports.CORS = cors;
      module.exports.plugins = {cors: cors};
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("dc", ["db"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('db');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("dd", ["5a", "d0", "69"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('5a');
  var mime = $__require('d0');
  var NotAcceptableError = $__require('69').NotAcceptableError;
  function acceptParser(accepts) {
    var acceptable = accepts;
    if (!Array.isArray(acceptable)) {
      acceptable = [acceptable];
    }
    assert.arrayOfString(acceptable, 'acceptable');
    acceptable = acceptable.filter(function(a) {
      return (a);
    }).map(function(a) {
      return ((a.indexOf('/') === -1) ? mime.lookup(a) : a);
    }).filter(function(a) {
      return (a);
    });
    var e = new NotAcceptableError('Server accepts: ' + acceptable.join());
    function parseAccept(req, res, next) {
      if (req.accepts(acceptable)) {
        next();
        return;
      }
      res.json(e);
      next(false);
    }
    return (parseAccept);
  }
  module.exports = acceptParser;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("de", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasProp = Object.prototype.hasOwnProperty;
  function throwsMessage(err) {
    return '[Throws: ' + (err ? err.message : '?') + ']';
  }
  function safeGetValueFromPropertyOnObject(obj, property) {
    if (hasProp.call(obj, property)) {
      try {
        return obj[property];
      } catch (err) {
        return throwsMessage(err);
      }
    }
    return obj[property];
  }
  function ensureProperties(obj) {
    var seen = [];
    function visit(obj) {
      if (obj === null || typeof obj !== 'object') {
        return obj;
      }
      if (seen.indexOf(obj) !== -1) {
        return '[Circular]';
      }
      seen.push(obj);
      if (typeof obj.toJSON === 'function') {
        try {
          return visit(obj.toJSON());
        } catch (err) {
          return throwsMessage(err);
        }
      }
      if (Array.isArray(obj)) {
        return obj.map(visit);
      }
      return Object.keys(obj).reduce(function(result, prop) {
        result[prop] = visit(safeGetValueFromPropertyOnObject(obj, prop));
        return result;
      }, {});
    }
    ;
    return visit(obj);
  }
  module.exports = function(data) {
    return JSON.stringify(ensureProperties(data));
  };
  module.exports.ensureProperties = ensureProperties;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("df", ["de"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('de');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e0", ["e2", "e1", "59", "71", "1a", "58", "df", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var VERSION = '1.8.0';
    var LOG_VERSION = 0;
    var xxx = function xxx(s) {
      var args = ['XX' + 'X: ' + s].concat(Array.prototype.slice.call(arguments, 1));
      console.error.apply(this, args);
    };
    var xxx = function xxx() {};
    var runtimeEnv;
    if (typeof(process) !== 'undefined' && process.versions) {
      if (process.versions.nw) {
        runtimeEnv = 'nw';
      } else if (process.versions.node) {
        runtimeEnv = 'node';
      }
    }
    if (!runtimeEnv && typeof(window) !== 'undefined' && window.window === window) {
      runtimeEnv = 'browser';
    }
    if (!runtimeEnv) {
      throw new Error('unknown runtime environment');
    }
    var os,
        fs,
        dtrace;
    if (runtimeEnv === 'browser') {
      os = {hostname: function() {
          return window.location.host;
        }};
      fs = {};
      dtrace = null;
    } else {
      os = $__require('e2');
      fs = $__require('e1');
      try {
        dtrace = $__require('dtrace-provider' + '');
      } catch (e) {
        dtrace = null;
      }
    }
    var util = $__require('59');
    var assert = $__require('71');
    var EventEmitter = $__require('1a').EventEmitter;
    var stream = $__require('58');
    try {
      var safeJsonStringify = $__require('df');
    } catch (e) {
      safeJsonStringify = null;
    }
    if (process.env.BUNYAN_TEST_NO_SAFE_JSON_STRINGIFY) {
      safeJsonStringify = null;
    }
    try {
      var mv = $__require('mv' + '');
    } catch (e) {
      mv = null;
    }
    try {
      var sourceMapSupport = $__require('source-map-support' + '');
    } catch (_) {
      sourceMapSupport = null;
    }
    function objCopy(obj) {
      if (obj == null) {
        return obj;
      } else if (Array.isArray(obj)) {
        return obj.slice();
      } else if (typeof(obj) === 'object') {
        var copy = {};
        Object.keys(obj).forEach(function(k) {
          copy[k] = obj[k];
        });
        return copy;
      } else {
        return obj;
      }
    }
    var format = util.format;
    if (!format) {
      var inspect = util.inspect;
      var formatRegExp = /%[sdj%]/g;
      format = function format(f) {
        if (typeof(f) !== 'string') {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(' ');
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x) {
          if (i >= len)
            return x;
          switch (x) {
            case '%s':
              return String(args[i++]);
            case '%d':
              return Number(args[i++]);
            case '%j':
              return JSON.stringify(args[i++], safeCycles());
            case '%%':
              return '%';
            default:
              return x;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (x === null || typeof(x) !== 'object') {
            str += ' ' + x;
          } else {
            str += ' ' + inspect(x);
          }
        }
        return str;
      };
    }
    function getCaller3Info() {
      if (this === undefined) {
        return;
      }
      var obj = {};
      var saveLimit = Error.stackTraceLimit;
      var savePrepare = Error.prepareStackTrace;
      Error.stackTraceLimit = 3;
      Error.captureStackTrace(this, getCaller3Info);
      Error.prepareStackTrace = function(_, stack) {
        var caller = stack[2];
        if (sourceMapSupport) {
          caller = sourceMapSupport.wrapCallSite(caller);
        }
        obj.file = caller.getFileName();
        obj.line = caller.getLineNumber();
        var func = caller.getFunctionName();
        if (func)
          obj.func = func;
      };
      this.stack;
      Error.stackTraceLimit = saveLimit;
      Error.prepareStackTrace = savePrepare;
      return obj;
    }
    function _indent(s, indent) {
      if (!indent)
        indent = '    ';
      var lines = s.split(/\r?\n/g);
      return indent + lines.join('\n' + indent);
    }
    function _warn(msg, dedupKey) {
      assert.ok(msg);
      if (dedupKey) {
        if (_warned[dedupKey]) {
          return;
        }
        _warned[dedupKey] = true;
      }
      process.stderr.write(msg + '\n');
    }
    function _haveWarned(dedupKey) {
      return _warned[dedupKey];
    }
    var _warned = {};
    function ConsoleRawStream() {}
    ConsoleRawStream.prototype.write = function(rec) {
      if (rec.level < INFO) {
        console.log(rec);
      } else if (rec.level < WARN) {
        console.info(rec);
      } else if (rec.level < ERROR) {
        console.warn(rec);
      } else {
        console.error(rec);
      }
    };
    var TRACE = 10;
    var DEBUG = 20;
    var INFO = 30;
    var WARN = 40;
    var ERROR = 50;
    var FATAL = 60;
    var levelFromName = {
      'trace': TRACE,
      'debug': DEBUG,
      'info': INFO,
      'warn': WARN,
      'error': ERROR,
      'fatal': FATAL
    };
    var nameFromLevel = {};
    Object.keys(levelFromName).forEach(function(name) {
      nameFromLevel[levelFromName[name]] = name;
    });
    var dtp = undefined;
    var probes = dtrace && {};
    function resolveLevel(nameOrNum) {
      var level;
      var type = typeof(nameOrNum);
      if (type === 'string') {
        level = levelFromName[nameOrNum.toLowerCase()];
        if (!level) {
          throw new Error(format('unknown level name: "%s"', nameOrNum));
        }
      } else if (type !== 'number') {
        throw new TypeError(format('cannot resolve level: invalid arg (%s):', type, nameOrNum));
      } else if (nameOrNum < 0 || Math.floor(nameOrNum) !== nameOrNum) {
        throw new TypeError(format('level is not a positive integer: %s', nameOrNum));
      } else {
        level = nameOrNum;
      }
      return level;
    }
    function isWritable(obj) {
      if (obj instanceof stream.Writable) {
        return true;
      }
      return typeof(obj.write) === 'function';
    }
    function Logger(options, _childOptions, _childSimple) {
      xxx('Logger start:', options);
      if (!(this instanceof Logger)) {
        return new Logger(options, _childOptions);
      }
      var parent;
      if (_childOptions !== undefined) {
        parent = options;
        options = _childOptions;
        if (!(parent instanceof Logger)) {
          throw new TypeError('invalid Logger creation: do not pass a second arg');
        }
      }
      if (!options) {
        throw new TypeError('options (object) is required');
      }
      if (!parent) {
        if (!options.name) {
          throw new TypeError('options.name (string) is required');
        }
      } else {
        if (options.name) {
          throw new TypeError('invalid options.name: child cannot set logger name');
        }
      }
      if (options.stream && options.streams) {
        throw new TypeError('cannot mix "streams" and "stream" options');
      }
      if (options.streams && !Array.isArray(options.streams)) {
        throw new TypeError('invalid options.streams: must be an array');
      }
      if (options.serializers && (typeof(options.serializers) !== 'object' || Array.isArray(options.serializers))) {
        throw new TypeError('invalid options.serializers: must be an object');
      }
      EventEmitter.call(this);
      if (parent && _childSimple) {
        this._isSimpleChild = true;
        this._level = parent._level;
        this.streams = parent.streams;
        this.serializers = parent.serializers;
        this.src = parent.src;
        var fields = this.fields = {};
        var parentFieldNames = Object.keys(parent.fields);
        for (var i = 0; i < parentFieldNames.length; i++) {
          var name = parentFieldNames[i];
          fields[name] = parent.fields[name];
        }
        var names = Object.keys(options);
        for (var i = 0; i < names.length; i++) {
          var name = names[i];
          fields[name] = options[name];
        }
        return;
      }
      var self = this;
      if (parent) {
        this._level = parent._level;
        this.streams = [];
        for (var i = 0; i < parent.streams.length; i++) {
          var s = objCopy(parent.streams[i]);
          s.closeOnExit = false;
          this.streams.push(s);
        }
        this.serializers = objCopy(parent.serializers);
        this.src = parent.src;
        this.fields = objCopy(parent.fields);
        if (options.level) {
          this.level(options.level);
        }
      } else {
        this._level = Number.POSITIVE_INFINITY;
        this.streams = [];
        this.serializers = null;
        this.src = false;
        this.fields = {};
      }
      if (!dtp && dtrace) {
        dtp = dtrace.createDTraceProvider('bunyan');
        for (var level in levelFromName) {
          var probe;
          probes[levelFromName[level]] = probe = dtp.addProbe('log-' + level, 'char *');
          probe.dtp = dtp;
        }
        dtp.enable();
      }
      if (options.stream) {
        self.addStream({
          type: 'stream',
          stream: options.stream,
          closeOnExit: false,
          level: options.level
        });
      } else if (options.streams) {
        options.streams.forEach(function(s) {
          self.addStream(s, options.level);
        });
      } else if (parent && options.level) {
        this.level(options.level);
      } else if (!parent) {
        if (runtimeEnv === 'browser') {
          self.addStream({
            type: 'raw',
            stream: new ConsoleRawStream(),
            closeOnExit: false,
            level: options.level
          });
        } else {
          self.addStream({
            type: 'stream',
            stream: process.stdout,
            closeOnExit: false,
            level: options.level
          });
        }
      }
      if (options.serializers) {
        self.addSerializers(options.serializers);
      }
      if (options.src) {
        this.src = true;
      }
      xxx('Logger: ', self);
      var fields = objCopy(options);
      delete fields.stream;
      delete fields.level;
      delete fields.streams;
      delete fields.serializers;
      delete fields.src;
      if (this.serializers) {
        this._applySerializers(fields);
      }
      if (!fields.hostname && !self.fields.hostname) {
        fields.hostname = os.hostname();
      }
      if (!fields.pid) {
        fields.pid = process.pid;
      }
      Object.keys(fields).forEach(function(k) {
        self.fields[k] = fields[k];
      });
    }
    util.inherits(Logger, EventEmitter);
    Logger.prototype.addStream = function addStream(s, defaultLevel) {
      var self = this;
      if (defaultLevel === null || defaultLevel === undefined) {
        defaultLevel = INFO;
      }
      s = objCopy(s);
      if (!s.type) {
        if (s.stream) {
          s.type = 'stream';
        } else if (s.path) {
          s.type = 'file';
        }
      }
      s.raw = (s.type === 'raw');
      if (s.level !== undefined) {
        s.level = resolveLevel(s.level);
      } else {
        s.level = resolveLevel(defaultLevel);
      }
      if (s.level < self._level) {
        self._level = s.level;
      }
      switch (s.type) {
        case 'stream':
          assert.ok(isWritable(s.stream), '"stream" stream is not writable: ' + util.inspect(s.stream));
          if (!s.closeOnExit) {
            s.closeOnExit = false;
          }
          break;
        case 'file':
          if (s.reemitErrorEvents === undefined) {
            s.reemitErrorEvents = true;
          }
          if (!s.stream) {
            s.stream = fs.createWriteStream(s.path, {
              flags: 'a',
              encoding: 'utf8'
            });
            if (!s.closeOnExit) {
              s.closeOnExit = true;
            }
          } else {
            if (!s.closeOnExit) {
              s.closeOnExit = false;
            }
          }
          break;
        case 'rotating-file':
          assert.ok(!s.stream, '"rotating-file" stream should not give a "stream"');
          assert.ok(s.path);
          assert.ok(mv, '"rotating-file" stream type is not supported: ' + 'missing "mv" module');
          s.stream = new RotatingFileStream(s);
          if (!s.closeOnExit) {
            s.closeOnExit = true;
          }
          break;
        case 'raw':
          if (!s.closeOnExit) {
            s.closeOnExit = false;
          }
          break;
        default:
          throw new TypeError('unknown stream type "' + s.type + '"');
      }
      if (s.reemitErrorEvents && typeof(s.stream.on) === 'function') {
        s.stream.on('error', function onStreamError(err) {
          self.emit('error', err, s);
        });
      }
      self.streams.push(s);
      delete self.haveNonRawStreams;
    };
    Logger.prototype.addSerializers = function addSerializers(serializers) {
      var self = this;
      if (!self.serializers) {
        self.serializers = {};
      }
      Object.keys(serializers).forEach(function(field) {
        var serializer = serializers[field];
        if (typeof(serializer) !== 'function') {
          throw new TypeError(format('invalid serializer for "%s" field: must be a function', field));
        } else {
          self.serializers[field] = serializer;
        }
      });
    };
    Logger.prototype.child = function(options, simple) {
      return new (this.constructor)(this, options || {}, simple);
    };
    Logger.prototype.reopenFileStreams = function() {
      var self = this;
      self.streams.forEach(function(s) {
        if (s.type === 'file') {
          if (s.stream) {
            s.stream.end();
            s.stream.destroySoon();
            delete s.stream;
          }
          s.stream = fs.createWriteStream(s.path, {
            flags: 'a',
            encoding: 'utf8'
          });
          s.stream.on('error', function(err) {
            self.emit('error', err, s);
          });
        }
      });
    };
    Logger.prototype.level = function level(value) {
      if (value === undefined) {
        return this._level;
      }
      var newLevel = resolveLevel(value);
      var len = this.streams.length;
      for (var i = 0; i < len; i++) {
        this.streams[i].level = newLevel;
      }
      this._level = newLevel;
    };
    Logger.prototype.levels = function levels(name, value) {
      if (name === undefined) {
        assert.equal(value, undefined);
        return this.streams.map(function(s) {
          return s.level;
        });
      }
      var stream;
      if (typeof(name) === 'number') {
        stream = this.streams[name];
        if (stream === undefined) {
          throw new Error('invalid stream index: ' + name);
        }
      } else {
        var len = this.streams.length;
        for (var i = 0; i < len; i++) {
          var s = this.streams[i];
          if (s.name === name) {
            stream = s;
            break;
          }
        }
        if (!stream) {
          throw new Error(format('no stream with name "%s"', name));
        }
      }
      if (value === undefined) {
        return stream.level;
      } else {
        var newLevel = resolveLevel(value);
        stream.level = newLevel;
        if (newLevel < this._level) {
          this._level = newLevel;
        }
      }
    };
    Logger.prototype._applySerializers = function(fields, excludeFields) {
      var self = this;
      xxx('_applySerializers: excludeFields', excludeFields);
      Object.keys(this.serializers).forEach(function(name) {
        if (fields[name] === undefined || (excludeFields && excludeFields[name])) {
          return;
        }
        xxx('_applySerializers; apply to "%s" key', name);
        try {
          fields[name] = self.serializers[name](fields[name]);
        } catch (err) {
          _warn(format('bunyan: ERROR: Exception thrown from the "%s" ' + 'Bunyan serializer. This should never happen. This is a bug' + 'in that serializer function.\n%s', name, err.stack || err));
          fields[name] = format('(Error in Bunyan log "%s" serializer ' + 'broke field. See stderr for details.)', name);
        }
      });
    };
    Logger.prototype._emit = function(rec, noemit) {
      var i;
      if (this.haveNonRawStreams === undefined) {
        this.haveNonRawStreams = false;
        for (i = 0; i < this.streams.length; i++) {
          if (!this.streams[i].raw) {
            this.haveNonRawStreams = true;
            break;
          }
        }
      }
      var str;
      if (noemit || this.haveNonRawStreams) {
        try {
          str = JSON.stringify(rec, safeCycles()) + '\n';
        } catch (e) {
          if (safeJsonStringify) {
            str = safeJsonStringify(rec) + '\n';
          } else {
            var dedupKey = e.stack.split(/\n/g, 2).join('\n');
            _warn('bunyan: ERROR: Exception in ' + '`JSON.stringify(rec)`. You can install the ' + '"safe-json-stringify" module to have Bunyan fallback ' + 'to safer stringification. Record:\n' + _indent(format('%s\n%s', util.inspect(rec), e.stack)), dedupKey);
            str = format('(Exception in JSON.stringify(rec): %j. ' + 'See stderr for details.)\n', e.message);
          }
        }
      }
      if (noemit)
        return str;
      var level = rec.level;
      for (i = 0; i < this.streams.length; i++) {
        var s = this.streams[i];
        if (s.level <= level) {
          xxx('writing log rec "%s" to "%s" stream (%d <= %d): %j', rec.msg, s.type, s.level, level, rec);
          s.stream.write(s.raw ? rec : str);
        }
      }
      ;
      return str;
    };
    function mkLogEmitter(minLevel) {
      return function() {
        var log = this;
        function mkRecord(args) {
          var excludeFields;
          if (args[0] instanceof Error) {
            fields = {err: (log.serializers && log.serializers.err ? log.serializers.err(args[0]) : Logger.stdSerializers.err(args[0]))};
            excludeFields = {err: true};
            if (args.length === 1) {
              msgArgs = [fields.err.message];
            } else {
              msgArgs = Array.prototype.slice.call(args, 1);
            }
          } else if (typeof(args[0]) !== 'object' && args[0] !== null || Array.isArray(args[0])) {
            fields = null;
            msgArgs = Array.prototype.slice.call(args);
          } else if (Buffer.isBuffer(args[0])) {
            fields = null;
            msgArgs = Array.prototype.slice.call(args);
            msgArgs[0] = util.inspect(msgArgs[0]);
          } else {
            fields = args[0];
            msgArgs = Array.prototype.slice.call(args, 1);
          }
          var rec = objCopy(log.fields);
          var level = rec.level = minLevel;
          var recFields = (fields ? objCopy(fields) : null);
          if (recFields) {
            if (log.serializers) {
              log._applySerializers(recFields, excludeFields);
            }
            Object.keys(recFields).forEach(function(k) {
              rec[k] = recFields[k];
            });
          }
          rec.msg = format.apply(log, msgArgs);
          if (!rec.time) {
            rec.time = (new Date());
          }
          if (log.src && !rec.src) {
            rec.src = getCaller3Info();
          }
          rec.v = LOG_VERSION;
          return rec;
        }
        ;
        var fields = null;
        var msgArgs = arguments;
        var str = null;
        var rec = null;
        if (!this._emit) {
          var dedupKey = 'unbound';
          if (!_haveWarned[dedupKey]) {
            var caller = getCaller3Info();
            _warn(format('bunyan usage error: %s:%s: attempt to log ' + 'with an unbound log method: `this` is: %s', caller.file, caller.line, util.inspect(this)), dedupKey);
          }
          return;
        } else if (arguments.length === 0) {
          return (this._level <= minLevel);
        } else if (this._level > minLevel) {} else {
          rec = mkRecord(msgArgs);
          str = this._emit(rec);
        }
        probes && probes[minLevel].fire(function() {
          return [str || (rec && log._emit(rec, true)) || log._emit(mkRecord(msgArgs), true)];
        });
      };
    }
    Logger.prototype.trace = mkLogEmitter(TRACE);
    Logger.prototype.debug = mkLogEmitter(DEBUG);
    Logger.prototype.info = mkLogEmitter(INFO);
    Logger.prototype.warn = mkLogEmitter(WARN);
    Logger.prototype.error = mkLogEmitter(ERROR);
    Logger.prototype.fatal = mkLogEmitter(FATAL);
    Logger.stdSerializers = {};
    Logger.stdSerializers.req = function req(req) {
      if (!req || !req.connection)
        return req;
      return {
        method: req.method,
        url: req.url,
        headers: req.headers,
        remoteAddress: req.connection.remoteAddress,
        remotePort: req.connection.remotePort
      };
    };
    Logger.stdSerializers.res = function res(res) {
      if (!res || !res.statusCode)
        return res;
      return {
        statusCode: res.statusCode,
        header: res._header
      };
    };
    function getFullErrorStack(ex) {
      var ret = ex.stack || ex.toString();
      if (ex.cause && typeof(ex.cause) === 'function') {
        var cex = ex.cause();
        if (cex) {
          ret += '\nCaused by: ' + getFullErrorStack(cex);
        }
      }
      return (ret);
    }
    var errSerializer = Logger.stdSerializers.err = function err(err) {
      if (!err || !err.stack)
        return err;
      var obj = {
        message: err.message,
        name: err.name,
        stack: getFullErrorStack(err),
        code: err.code,
        signal: err.signal
      };
      return obj;
    };
    function safeCycles() {
      var seen = [];
      return function(key, val) {
        if (!val || typeof(val) !== 'object') {
          return val;
        }
        if (seen.indexOf(val) !== -1) {
          return '[Circular]';
        }
        seen.push(val);
        return val;
      };
    }
    var RotatingFileStream = null;
    if (mv) {
      RotatingFileStream = function RotatingFileStream(options) {
        this.path = options.path;
        this.count = (options.count == null ? 10 : options.count);
        assert.equal(typeof(this.count), 'number', format('rotating-file stream "count" is not a number: %j (%s) in %j', this.count, typeof(this.count), this));
        assert.ok(this.count >= 0, format('rotating-file stream "count" is not >= 0: %j in %j', this.count, this));
        if (options.period) {
          var period = {
            'hourly': '1h',
            'daily': '1d',
            'weekly': '1w',
            'monthly': '1m',
            'yearly': '1y'
          }[options.period] || options.period;
          var m = /^([1-9][0-9]*)([hdwmy]|ms)$/.exec(period);
          if (!m) {
            throw new Error(format('invalid period: "%s"', options.period));
          }
          this.periodNum = Number(m[1]);
          this.periodScope = m[2];
        } else {
          this.periodNum = 1;
          this.periodScope = 'd';
        }
        var lastModified = null;
        try {
          var fileInfo = fs.statSync(this.path);
          lastModified = fileInfo.mtime.getTime();
        } catch (err) {}
        var rotateAfterOpen = false;
        if (lastModified) {
          var lastRotTime = this._calcRotTime(0);
          if (lastModified < lastRotTime) {
            rotateAfterOpen = true;
          }
        }
        this.stream = fs.createWriteStream(this.path, {
          flags: 'a',
          encoding: 'utf8'
        });
        this.rotQueue = [];
        this.rotating = false;
        if (rotateAfterOpen) {
          this.rotate();
        }
        this._setupNextRot();
      };
      util.inherits(RotatingFileStream, EventEmitter);
      RotatingFileStream.prototype._setupNextRot = function() {
        this.rotAt = this._calcRotTime(1);
        this._setRotationTimer();
      };
      RotatingFileStream.prototype._setRotationTimer = function() {
        var self = this;
        var delay = this.rotAt - Date.now();
        var TIMEOUT_MAX = 2147483647;
        if (delay > TIMEOUT_MAX) {
          delay = TIMEOUT_MAX;
        }
        this.timeout = setTimeout(function() {
          self.rotate();
        }, delay);
        if (typeof(this.timeout.unref) === 'function') {
          this.timeout.unref();
        }
      };
      RotatingFileStream.prototype._calcRotTime = function _calcRotTime(periodOffset) {
        var _DEBUG = false;
        if (_DEBUG)
          console.log('-- _calcRotTime: %s%s', this.periodNum, this.periodScope);
        var d = new Date();
        if (_DEBUG)
          console.log('  now local: %s', d);
        if (_DEBUG)
          console.log('    now utc: %s', d.toISOString());
        var rotAt;
        switch (this.periodScope) {
          case 'ms':
            if (this.rotAt) {
              rotAt = this.rotAt + this.periodNum * periodOffset;
            } else {
              rotAt = Date.now() + this.periodNum * periodOffset;
            }
            break;
          case 'h':
            if (this.rotAt) {
              rotAt = this.rotAt + this.periodNum * 60 * 60 * 1000 * periodOffset;
            } else {
              rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours() + periodOffset);
            }
            break;
          case 'd':
            if (this.rotAt) {
              rotAt = this.rotAt + this.periodNum * 24 * 60 * 60 * 1000 * periodOffset;
            } else {
              rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + periodOffset);
            }
            break;
          case 'w':
            if (this.rotAt) {
              rotAt = this.rotAt + this.periodNum * 7 * 24 * 60 * 60 * 1000 * periodOffset;
            } else {
              var dayOffset = (7 - d.getUTCDay());
              if (periodOffset < 1) {
                dayOffset = -d.getUTCDay();
              }
              if (periodOffset > 1 || periodOffset < -1) {
                dayOffset += 7 * periodOffset;
              }
              rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + dayOffset);
            }
            break;
          case 'm':
            if (this.rotAt) {
              rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + this.periodNum * periodOffset, 1);
            } else {
              rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + periodOffset, 1);
            }
            break;
          case 'y':
            if (this.rotAt) {
              rotAt = Date.UTC(d.getUTCFullYear() + this.periodNum * periodOffset, 0, 1);
            } else {
              rotAt = Date.UTC(d.getUTCFullYear() + periodOffset, 0, 1);
            }
            break;
          default:
            assert.fail(format('invalid period scope: "%s"', this.periodScope));
        }
        if (_DEBUG) {
          console.log('  **rotAt**: %s (utc: %s)', rotAt, new Date(rotAt).toUTCString());
          var now = Date.now();
          console.log('        now: %s (%sms == %smin == %sh to go)', now, rotAt - now, (rotAt - now) / 1000 / 60, (rotAt - now) / 1000 / 60 / 60);
        }
        return rotAt;
      };
      RotatingFileStream.prototype.rotate = function rotate() {
        var self = this;
        var _DEBUG = false;
        if (self.rotAt && self.rotAt > Date.now()) {
          return self._setRotationTimer();
        }
        if (_DEBUG) {
          console.log('-- [%s, pid=%s] rotating %s', new Date(), process.pid, self.path);
        }
        if (self.rotating) {
          throw new TypeError('cannot start a rotation when already rotating');
        }
        self.rotating = true;
        self.stream.end();
        function del() {
          var toDel = self.path + '.' + String(n - 1);
          if (n === 0) {
            toDel = self.path;
          }
          n -= 1;
          if (_DEBUG)
            console.log('rm %s', toDel);
          fs.unlink(toDel, function(delErr) {
            moves();
          });
        }
        function moves() {
          if (self.count === 0 || n < 0) {
            return finish();
          }
          var before = self.path;
          var after = self.path + '.' + String(n);
          if (n > 0) {
            before += '.' + String(n - 1);
          }
          n -= 1;
          fs.exists(before, function(exists) {
            if (!exists) {
              moves();
            } else {
              if (_DEBUG) {
                console.log('[pid %s] mv %s %s', process.pid, before, after);
              }
              mv(before, after, function(mvErr) {
                if (mvErr) {
                  self.emit('error', mvErr);
                  finish();
                } else {
                  moves();
                }
              });
            }
          });
        }
        function finish() {
          if (_DEBUG)
            console.log('[pid %s] open %s', process.pid, self.path);
          self.stream = fs.createWriteStream(self.path, {
            flags: 'a',
            encoding: 'utf8'
          });
          var q = self.rotQueue,
              len = q.length;
          for (var i = 0; i < len; i++) {
            self.stream.write(q[i]);
          }
          self.rotQueue = [];
          self.rotating = false;
          self.emit('drain');
          self._setupNextRot();
        }
        var n = this.count;
        del();
      };
      RotatingFileStream.prototype.write = function write(s) {
        if (this.rotating) {
          this.rotQueue.push(s);
          return false;
        } else {
          return this.stream.write(s);
        }
      };
      RotatingFileStream.prototype.end = function end(s) {
        this.stream.end();
      };
      RotatingFileStream.prototype.destroy = function destroy(s) {
        this.stream.destroy();
      };
      RotatingFileStream.prototype.destroySoon = function destroySoon(s) {
        this.stream.destroySoon();
      };
    }
    function RingBuffer(options) {
      this.limit = options && options.limit ? options.limit : 100;
      this.writable = true;
      this.records = [];
      EventEmitter.call(this);
    }
    util.inherits(RingBuffer, EventEmitter);
    RingBuffer.prototype.write = function(record) {
      if (!this.writable)
        throw (new Error('RingBuffer has been ended already'));
      this.records.push(record);
      if (this.records.length > this.limit)
        this.records.shift();
      return (true);
    };
    RingBuffer.prototype.end = function() {
      if (arguments.length > 0)
        this.write.apply(this, Array.prototype.slice.call(arguments));
      this.writable = false;
    };
    RingBuffer.prototype.destroy = function() {
      this.writable = false;
      this.emit('close');
    };
    RingBuffer.prototype.destroySoon = function() {
      this.destroy();
    };
    module.exports = Logger;
    module.exports.TRACE = TRACE;
    module.exports.DEBUG = DEBUG;
    module.exports.INFO = INFO;
    module.exports.WARN = WARN;
    module.exports.ERROR = ERROR;
    module.exports.FATAL = FATAL;
    module.exports.resolveLevel = resolveLevel;
    module.exports.levelFromName = levelFromName;
    module.exports.nameFromLevel = nameFromLevel;
    module.exports.VERSION = VERSION;
    module.exports.LOG_VERSION = LOG_VERSION;
    module.exports.createLogger = function createLogger(options) {
      return new Logger(options);
    };
    module.exports.RingBuffer = RingBuffer;
    module.exports.RotatingFileStream = RotatingFileStream;
    module.exports.safeCycles = safeCycles;
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5b", ["e0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('e0');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e3", ["5a", "5b", "69"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('5a');
  var bunyan = $__require('5b');
  var HttpError = $__require('69').HttpError;
  function auditLogger(options) {
    assert.object(options, 'options');
    assert.object(options.log, 'options.log');
    assert.optionalObject(options.server, 'options.server');
    assert.optionalObject(options.logBuffer, 'options.logBuffer');
    assert.optionalBool(options.printLog, 'options.printLog');
    var server = options.server;
    var logMetrics = options.logBuffer;
    var printLog = options.printLog;
    if (typeof printLog === 'undefined') {
      printLog = true;
    }
    var errSerializer = bunyan.stdSerializers.err;
    if (options.log.serializers && options.log.serializers.err) {
      errSerializer = options.log.serializers.err;
    }
    var log = options.log.child({
      audit: true,
      serializers: {
        err: errSerializer,
        req: function auditRequestSerializer(req) {
          if (!req) {
            return (false);
          }
          var timers = {};
          (req.timers || []).forEach(function(time) {
            var t = time.time;
            var _t = Math.floor((1000000 * t[0]) + (t[1] / 1000));
            timers[time.name] = _t;
          });
          return ({
            query: (typeof req.query === 'function') ? req.query() : req.query,
            method: req.method,
            url: req.url,
            headers: req.headers,
            httpVersion: req.httpVersion,
            trailers: req.trailers,
            version: req.version(),
            body: options.body === true ? req.body : undefined,
            timers: timers,
            clientClosed: req.clientClosed
          });
        },
        res: function auditResponseSerializer(res) {
          if (!res) {
            return (false);
          }
          var body;
          if (options.body === true) {
            if (res._body instanceof HttpError) {
              body = res._body.body;
            } else {
              body = res._body;
            }
          }
          return ({
            statusCode: res.statusCode,
            headers: res._headers,
            trailer: res._trailer || false,
            body: body
          });
        }
      }
    });
    function audit(req, res, route, err) {
      var latency = res.get('Response-Time');
      var timestamp = new Date().getTime();
      if (typeof(latency) !== 'number') {
        latency = Date.now() - req._time;
      }
      var obj = {
        remoteAddress: req.connection.remoteAddress,
        remotePort: req.connection.remotePort,
        req_id: req.getId(),
        req: req,
        res: res,
        err: err,
        latency: latency,
        secure: req.secure,
        _audit: true
      };
      if (printLog) {
        log.info(obj, 'handled: %d', res.statusCode);
      }
      if (logMetrics && logMetrics instanceof bunyan.RingBuffer) {
        obj.timestamp = timestamp;
        logMetrics.write(obj);
      }
      if (server) {
        server.emit('auditlog', obj);
      }
      return (true);
    }
    return (audit);
  }
  module.exports = auditLogger;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e4", ["e5", "59"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('e5');
  var util = $__require('59');
  var Algorithms = {
    'rsa-sha1': true,
    'rsa-sha256': true,
    'rsa-sha512': true,
    'dsa-sha1': true,
    'hmac-sha1': true,
    'hmac-sha256': true,
    'hmac-sha512': true
  };
  var State = {
    New: 0,
    Params: 1
  };
  var ParamsState = {
    Name: 0,
    Quote: 1,
    Value: 2,
    Comma: 3
  };
  function HttpSignatureError(message, caller) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, caller || HttpSignatureError);
    this.message = message;
    this.name = caller.name;
  }
  util.inherits(HttpSignatureError, Error);
  function ExpiredRequestError(message) {
    HttpSignatureError.call(this, message, ExpiredRequestError);
  }
  util.inherits(ExpiredRequestError, HttpSignatureError);
  function InvalidHeaderError(message) {
    HttpSignatureError.call(this, message, InvalidHeaderError);
  }
  util.inherits(InvalidHeaderError, HttpSignatureError);
  function InvalidParamsError(message) {
    HttpSignatureError.call(this, message, InvalidParamsError);
  }
  util.inherits(InvalidParamsError, HttpSignatureError);
  function MissingHeaderError(message) {
    HttpSignatureError.call(this, message, MissingHeaderError);
  }
  util.inherits(MissingHeaderError, HttpSignatureError);
  module.exports = {parseRequest: function parseRequest(request, options) {
      assert.object(request, 'request');
      assert.object(request.headers, 'request.headers');
      if (options === undefined) {
        options = {};
      }
      if (options.headers === undefined) {
        options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
      }
      assert.object(options, 'options');
      assert.arrayOfString(options.headers, 'options.headers');
      assert.optionalNumber(options.clockSkew, 'options.clockSkew');
      if (!request.headers.authorization)
        throw new MissingHeaderError('no authorization header present in ' + 'the request');
      options.clockSkew = options.clockSkew || 300;
      var i = 0;
      var state = State.New;
      var substate = ParamsState.Name;
      var tmpName = '';
      var tmpValue = '';
      var parsed = {
        scheme: '',
        params: {},
        signingString: '',
        get algorithm() {
          return this.params.algorithm.toUpperCase();
        },
        get keyId() {
          return this.params.keyId;
        }
      };
      var authz = request.headers.authorization;
      for (i = 0; i < authz.length; i++) {
        var c = authz.charAt(i);
        switch (Number(state)) {
          case State.New:
            if (c !== ' ')
              parsed.scheme += c;
            else
              state = State.Params;
            break;
          case State.Params:
            switch (Number(substate)) {
              case ParamsState.Name:
                var code = c.charCodeAt(0);
                if ((code >= 0x41 && code <= 0x5a) || (code >= 0x61 && code <= 0x7a)) {
                  tmpName += c;
                } else if (c === '=') {
                  if (tmpName.length === 0)
                    throw new InvalidHeaderError('bad param format');
                  substate = ParamsState.Quote;
                } else {
                  throw new InvalidHeaderError('bad param format');
                }
                break;
              case ParamsState.Quote:
                if (c === '"') {
                  tmpValue = '';
                  substate = ParamsState.Value;
                } else {
                  throw new InvalidHeaderError('bad param format');
                }
                break;
              case ParamsState.Value:
                if (c === '"') {
                  parsed.params[tmpName] = tmpValue;
                  substate = ParamsState.Comma;
                } else {
                  tmpValue += c;
                }
                break;
              case ParamsState.Comma:
                if (c === ',') {
                  tmpName = '';
                  substate = ParamsState.Name;
                } else {
                  throw new InvalidHeaderError('bad param format');
                }
                break;
              default:
                throw new Error('Invalid substate');
            }
            break;
          default:
            throw new Error('Invalid substate');
        }
      }
      if (!parsed.params.headers || parsed.params.headers === '') {
        if (request.headers['x-date']) {
          parsed.params.headers = ['x-date'];
        } else {
          parsed.params.headers = ['date'];
        }
      } else {
        parsed.params.headers = parsed.params.headers.split(' ');
      }
      if (!parsed.scheme || parsed.scheme !== 'Signature')
        throw new InvalidHeaderError('scheme was not "Signature"');
      if (!parsed.params.keyId)
        throw new InvalidHeaderError('keyId was not specified');
      if (!parsed.params.algorithm)
        throw new InvalidHeaderError('algorithm was not specified');
      if (!parsed.params.signature)
        throw new InvalidHeaderError('signature was not specified');
      parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
      if (!Algorithms[parsed.params.algorithm])
        throw new InvalidParamsError(parsed.params.algorithm + ' is not supported');
      for (i = 0; i < parsed.params.headers.length; i++) {
        var h = parsed.params.headers[i].toLowerCase();
        parsed.params.headers[i] = h;
        if (h !== 'request-line') {
          var value = request.headers[h];
          if (!value)
            throw new MissingHeaderError(h + ' was not in the request');
          parsed.signingString += h + ': ' + value;
        } else {
          parsed.signingString += request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
        }
        if ((i + 1) < parsed.params.headers.length)
          parsed.signingString += '\n';
      }
      var date;
      if (request.headers.date || request.headers['x-date']) {
        if (request.headers['x-date']) {
          date = new Date(request.headers['x-date']);
        } else {
          date = new Date(request.headers.date);
        }
        var now = new Date();
        var skew = Math.abs(now.getTime() - date.getTime());
        if (skew > options.clockSkew * 1000) {
          throw new ExpiredRequestError('clock skew of ' + (skew / 1000) + 's was greater than ' + options.clockSkew + 's');
        }
      }
      options.headers.forEach(function(hdr) {
        if (parsed.params.headers.indexOf(hdr) < 0)
          throw new MissingHeaderError(hdr + ' was not a signed header');
      });
      if (options.algorithms) {
        if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
          throw new InvalidParamsError(parsed.params.algorithm + ' is not a supported algorithm');
      }
      return parsed;
    }};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e6", ["e5", "cd", "7d", "59"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('e5');
  var crypto = $__require('cd');
  var http = $__require('7d');
  var sprintf = $__require('59').format;
  var Algorithms = {
    'rsa-sha1': true,
    'rsa-sha256': true,
    'rsa-sha512': true,
    'dsa-sha1': true,
    'hmac-sha1': true,
    'hmac-sha256': true,
    'hmac-sha512': true
  };
  var Authorization = 'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
  function MissingHeaderError(message) {
    this.name = 'MissingHeaderError';
    this.message = message;
    this.stack = (new Error()).stack;
  }
  MissingHeaderError.prototype = new Error();
  function InvalidAlgorithmError(message) {
    this.name = 'InvalidAlgorithmError';
    this.message = message;
    this.stack = (new Error()).stack;
  }
  InvalidAlgorithmError.prototype = new Error();
  function _pad(val) {
    if (parseInt(val, 10) < 10) {
      val = '0' + val;
    }
    return val;
  }
  function _rfc1123() {
    var date = new Date();
    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    return days[date.getUTCDay()] + ', ' + _pad(date.getUTCDate()) + ' ' + months[date.getUTCMonth()] + ' ' + date.getUTCFullYear() + ' ' + _pad(date.getUTCHours()) + ':' + _pad(date.getUTCMinutes()) + ':' + _pad(date.getUTCSeconds()) + ' GMT';
  }
  module.exports = {signRequest: function signRequest(request, options) {
      assert.object(request, 'request');
      assert.object(options, 'options');
      assert.optionalString(options.algorithm, 'options.algorithm');
      assert.string(options.keyId, 'options.keyId');
      assert.optionalArrayOfString(options.headers, 'options.headers');
      assert.optionalString(options.httpVersion, 'options.httpVersion');
      if (!request.getHeader('Date'))
        request.setHeader('Date', _rfc1123());
      if (!options.headers)
        options.headers = ['date'];
      if (!options.algorithm)
        options.algorithm = 'rsa-sha256';
      if (!options.httpVersion)
        options.httpVersion = '1.1';
      options.algorithm = options.algorithm.toLowerCase();
      if (!Algorithms[options.algorithm])
        throw new InvalidAlgorithmError(options.algorithm + ' is not supported');
      var i;
      var stringToSign = '';
      for (i = 0; i < options.headers.length; i++) {
        if (typeof(options.headers[i]) !== 'string')
          throw new TypeError('options.headers must be an array of Strings');
        var h = options.headers[i].toLowerCase();
        if (h !== 'request-line') {
          var value = request.getHeader(h);
          if (!value) {
            throw new MissingHeaderError(h + ' was not in the request');
          }
          stringToSign += h + ': ' + value;
        } else {
          stringToSign += request.method + ' ' + request.path + ' HTTP/' + options.httpVersion;
        }
        if ((i + 1) < options.headers.length)
          stringToSign += '\n';
      }
      var alg = options.algorithm.match(/(hmac|rsa)-(\w+)/);
      var signature;
      if (alg[1] === 'hmac') {
        var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);
        hmac.update(stringToSign);
        signature = hmac.digest('base64');
      } else {
        var signer = crypto.createSign(options.algorithm.toUpperCase());
        signer.update(stringToSign);
        signature = signer.sign(options.key, 'base64');
      }
      request.setHeader('Authorization', sprintf(Authorization, options.keyId, options.algorithm, options.headers.join(' '), signature));
      return true;
    }};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e7", ["e5", "cd"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('e5');
  var crypto = $__require('cd');
  module.exports = {
    verifySignature: function verifySignature(parsedSignature, pubkey) {
      assert.object(parsedSignature, 'parsedSignature');
      assert.string(pubkey, 'pubkey');
      var alg = parsedSignature.algorithm.match(/^(RSA|DSA)-(\w+)/);
      if (!alg || alg.length !== 3)
        throw new TypeError('parsedSignature: unsupported algorithm ' + parsedSignature.algorithm);
      var verify = crypto.createVerify(alg[0]);
      verify.update(parsedSignature.signingString);
      return verify.verify(pubkey, parsedSignature.params.signature, 'base64');
    },
    verifyHMAC: function verifyHMAC(parsedSignature, secret) {
      assert.object(parsedSignature, 'parsedHMAC');
      assert.string(secret, 'secret');
      var alg = parsedSignature.algorithm.match(/^HMAC-(\w+)/);
      if (!alg || alg.length !== 2)
        throw new TypeError('parsedSignature: unsupported algorithm ' + parsedSignature.algorithm);
      var hmac = crypto.createHmac(alg[1].toUpperCase(), secret);
      hmac.update(parsedSignature.signingString);
      return (hmac.digest('base64') === parsedSignature.params.signature);
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e8", ["71", "58", "59", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var assert = $__require('71');
    var Stream = $__require('58').Stream;
    var util = $__require('59');
    var NDEBUG = process.env.NODE_NDEBUG || false;
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
    var TYPE_REQUIRED = '%s (%s) is required';
    function capitalize(str) {
      return (str.charAt(0).toUpperCase() + str.slice(1));
    }
    function uncapitalize(str) {
      return (str.charAt(0).toLowerCase() + str.slice(1));
    }
    function _() {
      return (util.format.apply(util, arguments));
    }
    function _assert(arg, type, name, stackFunc) {
      if (!NDEBUG) {
        name = name || type;
        stackFunc = stackFunc || _assert.caller;
        var t = typeof(arg);
        if (t !== type) {
          throw new assert.AssertionError({
            message: _(TYPE_REQUIRED, name, type),
            actual: t,
            expected: type,
            operator: '===',
            stackStartFunction: stackFunc
          });
        }
      }
    }
    function _instanceof(arg, type, name, stackFunc) {
      if (!NDEBUG) {
        name = name || type;
        stackFunc = stackFunc || _instanceof.caller;
        if (!(arg instanceof type)) {
          throw new assert.AssertionError({
            message: _(TYPE_REQUIRED, name, type.name),
            actual: _getClass(arg),
            expected: type.name,
            operator: 'instanceof',
            stackStartFunction: stackFunc
          });
        }
      }
    }
    function _getClass(object) {
      return (Object.prototype.toString.call(object).slice(8, -1));
    }
    ;
    function array(arr, type, name) {
      if (!NDEBUG) {
        name = name || type;
        if (!Array.isArray(arr)) {
          throw new assert.AssertionError({
            message: _(ARRAY_TYPE_REQUIRED, name, type),
            actual: typeof(arr),
            expected: 'array',
            operator: 'Array.isArray',
            stackStartFunction: array.caller
          });
        }
        for (var i = 0; i < arr.length; i++) {
          _assert(arr[i], type, name, array);
        }
      }
    }
    function bool(arg, name) {
      _assert(arg, 'boolean', name, bool);
    }
    function buffer(arg, name) {
      if (!Buffer.isBuffer(arg)) {
        throw new assert.AssertionError({
          message: _(TYPE_REQUIRED, name || '', 'Buffer'),
          actual: typeof(arg),
          expected: 'buffer',
          operator: 'Buffer.isBuffer',
          stackStartFunction: buffer
        });
      }
    }
    function func(arg, name) {
      _assert(arg, 'function', name);
    }
    function number(arg, name) {
      _assert(arg, 'number', name);
      if (!NDEBUG && (isNaN(arg) || !isFinite(arg))) {
        throw new assert.AssertionError({
          message: _(TYPE_REQUIRED, name, 'number'),
          actual: arg,
          expected: 'number',
          operator: 'isNaN',
          stackStartFunction: number
        });
      }
    }
    function object(arg, name) {
      _assert(arg, 'object', name);
    }
    function stream(arg, name) {
      _instanceof(arg, Stream, name);
    }
    function date(arg, name) {
      _instanceof(arg, Date, name);
    }
    function regexp(arg, name) {
      _instanceof(arg, RegExp, name);
    }
    function string(arg, name) {
      _assert(arg, 'string', name);
    }
    function uuid(arg, name) {
      string(arg, name);
      if (!NDEBUG && !UUID_REGEXP.test(arg)) {
        throw new assert.AssertionError({
          message: _(TYPE_REQUIRED, name, 'uuid'),
          actual: 'string',
          expected: 'uuid',
          operator: 'test',
          stackStartFunction: uuid
        });
      }
    }
    module.exports = {
      bool: bool,
      buffer: buffer,
      date: date,
      func: func,
      number: number,
      object: object,
      regexp: regexp,
      stream: stream,
      string: string,
      uuid: uuid
    };
    Object.keys(module.exports).forEach(function(k) {
      if (k === 'buffer')
        return;
      var name = 'arrayOf' + capitalize(k);
      if (k === 'bool')
        k = 'boolean';
      if (k === 'func')
        k = 'function';
      module.exports[name] = function(arg, name) {
        array(arg, k, name);
      };
    });
    Object.keys(module.exports).forEach(function(k) {
      var _name = 'optional' + capitalize(k);
      var s = uncapitalize(k.replace('arrayOf', ''));
      if (s === 'bool')
        s = 'boolean';
      if (s === 'func')
        s = 'function';
      if (k.indexOf('arrayOf') !== -1) {
        module.exports[_name] = function(arg, name) {
          if (!NDEBUG && arg !== undefined) {
            array(arg, s, name);
          }
        };
      } else {
        module.exports[_name] = function(arg, name) {
          if (!NDEBUG && arg !== undefined) {
            _assert(arg, s, name);
          }
        };
      }
    });
    Object.keys(assert).forEach(function(k) {
      if (k === 'AssertionError') {
        module.exports[k] = assert[k];
        return;
      }
      module.exports[k] = function() {
        if (!NDEBUG) {
          assert[k].apply(assert[k], arguments);
        }
      };
    });
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e5", ["e8"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('e8');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e9", ["71", "ea", "eb", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var assert = $__require('71');
    var ASN1 = $__require('ea');
    var errors = $__require('eb');
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    function Reader(data) {
      if (!data || !Buffer.isBuffer(data))
        throw new TypeError('data must be a node Buffer');
      this._buf = data;
      this._size = data.length;
      this._len = 0;
      this._offset = 0;
      var self = this;
      this.__defineGetter__('length', function() {
        return self._len;
      });
      this.__defineGetter__('offset', function() {
        return self._offset;
      });
      this.__defineGetter__('remain', function() {
        return self._size - self._offset;
      });
      this.__defineGetter__('buffer', function() {
        return self._buf.slice(self._offset);
      });
    }
    Reader.prototype.readByte = function(peek) {
      if (this._size - this._offset < 1)
        return null;
      var b = this._buf[this._offset] & 0xff;
      if (!peek)
        this._offset += 1;
      return b;
    };
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    Reader.prototype.readLength = function(offset) {
      if (offset === undefined)
        offset = this._offset;
      if (offset >= this._size)
        return null;
      var lenB = this._buf[offset++] & 0xff;
      if (lenB === null)
        return null;
      if ((lenB & 0x80) == 0x80) {
        lenB &= 0x7f;
        if (lenB == 0)
          throw newInvalidAsn1Error('Indefinite length not supported');
        if (lenB > 4)
          throw newInvalidAsn1Error('encoding too long');
        if (this._size - offset < lenB)
          return null;
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 0xff);
      } else {
        this._len = lenB;
      }
      return offset;
    };
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null)
        return null;
      if (tag !== undefined && tag !== seq)
        throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + seq.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      this._offset = o;
      return seq;
    };
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    Reader.prototype.readBoolean = function() {
      return (this._readTag(ASN1.Boolean) === 0 ? false : true);
    };
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag)
        tag = ASN1.OctetString;
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      if (this.length === 0)
        return '';
      var str = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
      return retbuf ? str : str.toString('utf8');
    };
    Reader.prototype.readOID = function(tag) {
      if (!tag)
        tag = ASN1.OID;
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      var values = [];
      var value = 0;
      for (var i = 0; i < this.length; i++) {
        var byte = this._buf[this._offset++] & 0xff;
        value <<= 7;
        value += byte & 0x7f;
        if ((byte & 0x80) == 0) {
          values.push(value);
          value = 0;
        }
      }
      value = values.shift();
      values.unshift(value % 40);
      values.unshift((value / 40) >> 0);
      return values.join('.');
    };
    Reader.prototype._readTag = function(tag) {
      assert.ok(tag !== undefined);
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > 4)
        throw newInvalidAsn1Error('Integer too long: ' + this.length);
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      var fb = this._buf[this._offset++];
      var value = 0;
      value = fb & 0x7F;
      for (var i = 1; i < this.length; i++) {
        value <<= 8;
        value |= (this._buf[this._offset++] & 0xff);
      }
      if ((fb & 0x80) == 0x80)
        value = -value;
      return value;
    };
    module.exports = Reader;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ea", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    EOC: 0,
    Boolean: 1,
    Integer: 2,
    BitString: 3,
    OctetString: 4,
    Null: 5,
    OID: 6,
    ObjectDescriptor: 7,
    External: 8,
    Real: 9,
    Enumeration: 10,
    PDV: 11,
    Utf8String: 12,
    RelativeOID: 13,
    Sequence: 16,
    Set: 17,
    NumericString: 18,
    PrintableString: 19,
    T61String: 20,
    VideotexString: 21,
    IA5String: 22,
    UTCTime: 23,
    GeneralizedTime: 24,
    GraphicString: 25,
    VisibleString: 26,
    GeneralString: 28,
    UniversalString: 29,
    CharacterString: 30,
    BMPString: 31,
    Constructor: 32,
    Context: 128
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("eb", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {newInvalidAsn1Error: function(msg) {
      var e = new Error();
      e.name = 'InvalidAsn1Error';
      e.message = msg || '';
      return e;
    }};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ec", ["71", "ea", "eb", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var assert = $__require('71');
    var ASN1 = $__require('ea');
    var errors = $__require('eb');
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    function merge(from, to) {
      assert.ok(from);
      assert.equal(typeof(from), 'object');
      assert.ok(to);
      assert.equal(typeof(to), 'object');
      var keys = Object.getOwnPropertyNames(from);
      keys.forEach(function(key) {
        if (to[key])
          return;
        var value = Object.getOwnPropertyDescriptor(from, key);
        Object.defineProperty(to, key, value);
      });
      return to;
    }
    function Writer(options) {
      options = merge(DEFAULT_OPTS, options || {});
      this._buf = new Buffer(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
      this._seq = [];
      var self = this;
      this.__defineGetter__('buffer', function() {
        if (self._seq.length)
          throw new InvalidAsn1Error(self._seq.length + ' unended sequence(s)');
        return self._buf.slice(0, self._offset);
      });
    }
    Writer.prototype.writeByte = function(b) {
      if (typeof(b) !== 'number')
        throw new TypeError('argument must be a Number');
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof(i) !== 'number')
        throw new TypeError('argument must be a Number');
      if (typeof(tag) !== 'number')
        tag = ASN1.Integer;
      var sz = 4;
      while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000)) && (sz > 1)) {
        sz--;
        i <<= 8;
      }
      if (sz > 4)
        throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
      while (sz-- > 0) {
        this._buf[this._offset++] = ((i & 0xff000000) >> 24);
        i <<= 8;
      }
    };
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0x00);
    };
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof(i) !== 'number')
        throw new TypeError('argument must be a Number');
      if (typeof(tag) !== 'number')
        tag = ASN1.Enumeration;
      return this.writeInt(i, tag);
    };
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof(b) !== 'boolean')
        throw new TypeError('argument must be a Boolean');
      if (typeof(tag) !== 'number')
        tag = ASN1.Boolean;
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 0x01;
      this._buf[this._offset++] = b ? 0xff : 0x00;
    };
    Writer.prototype.writeString = function(s, tag) {
      if (typeof(s) !== 'string')
        throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');
      if (typeof(tag) !== 'number')
        tag = ASN1.OctetString;
      var len = Buffer.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof(tag) !== 'number')
        throw new TypeError('tag must be a number');
      if (!Buffer.isBuffer(buf))
        throw new TypeError('argument must be a buffer');
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    Writer.prototype.writeStringArray = function(strings) {
      if ((!strings instanceof Array))
        throw new TypeError('argument must be an Array[String]');
      var self = this;
      strings.forEach(function(s) {
        self.writeString(s);
      });
    };
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof(s) !== 'string')
        throw new TypeError('argument must be a string');
      if (typeof(tag) !== 'number')
        tag = ASN1.OID;
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error('argument is not a valid OID string');
      function encodeOctet(bytes, octet) {
        if (octet < 128) {
          bytes.push(octet);
        } else if (octet < 16384) {
          bytes.push((octet >>> 7) | 0x80);
          bytes.push(octet & 0x7F);
        } else if (octet < 2097152) {
          bytes.push((octet >>> 14) | 0x80);
          bytes.push(((octet >>> 7) | 0x80) & 0xFF);
          bytes.push(octet & 0x7F);
        } else if (octet < 268435456) {
          bytes.push((octet >>> 21) | 0x80);
          bytes.push(((octet >>> 14) | 0x80) & 0xFF);
          bytes.push(((octet >>> 7) | 0x80) & 0xFF);
          bytes.push(octet & 0x7F);
        } else {
          bytes.push(((octet >>> 28) | 0x80) & 0xFF);
          bytes.push(((octet >>> 21) | 0x80) & 0xFF);
          bytes.push(((octet >>> 14) | 0x80) & 0xFF);
          bytes.push(((octet >>> 7) | 0x80) & 0xFF);
          bytes.push(octet & 0x7F);
        }
      }
      var tmp = s.split('.');
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
      var self = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self.writeByte(b);
      });
    };
    Writer.prototype.writeLength = function(len) {
      if (typeof(len) !== 'number')
        throw new TypeError('argument must be a Number');
      this._ensure(4);
      if (len <= 0x7f) {
        this._buf[this._offset++] = len;
      } else if (len <= 0xff) {
        this._buf[this._offset++] = 0x81;
        this._buf[this._offset++] = len;
      } else if (len <= 0xffff) {
        this._buf[this._offset++] = 0x82;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 0xffffff) {
        this._shift(start, len, 1);
        this._buf[this._offset++] = 0x83;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw new InvalidAsn1ERror('Length too long (> 4 bytes)');
      }
    };
    Writer.prototype.startSequence = function(tag) {
      if (typeof(tag) !== 'number')
        tag = ASN1.Sequence | ASN1.Constructor;
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop();
      var start = seq + 3;
      var len = this._offset - start;
      if (len <= 0x7f) {
        this._shift(start, len, -2);
        this._buf[seq] = len;
      } else if (len <= 0xff) {
        this._shift(start, len, -1);
        this._buf[seq] = 0x81;
        this._buf[seq + 1] = len;
      } else if (len <= 0xffff) {
        this._buf[seq] = 0x82;
        this._buf[seq + 1] = len >> 8;
        this._buf[seq + 2] = len;
      } else if (len <= 0xffffff) {
        this._shift(start, len, 1);
        this._buf[seq] = 0x83;
        this._buf[seq + 1] = len >> 16;
        this._buf[seq + 2] = len >> 8;
        this._buf[seq + 3] = len;
      } else {
        throw new InvalidAsn1Error('Sequence too long');
      }
    };
    Writer.prototype._shift = function(start, len, shift) {
      assert.ok(start !== undefined);
      assert.ok(len !== undefined);
      assert.ok(shift);
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    Writer.prototype._ensure = function(len) {
      assert.ok(len);
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len)
          sz += len;
        var buf = new Buffer(sz);
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    module.exports = Writer;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ed", ["eb", "ea", "e9", "ec"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var errors = $__require('eb');
  var types = $__require('ea');
  var Reader = $__require('e9');
  var Writer = $__require('ec');
  module.exports = {
    Reader: Reader,
    Writer: Writer
  };
  for (var t in types) {
    if (types.hasOwnProperty(t))
      module.exports[t] = types[t];
  }
  for (var e in errors) {
    if (errors.hasOwnProperty(e))
      module.exports[e] = errors[e];
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ee", ["ed"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Ber = $__require('ed');
  module.exports = {
    Ber: Ber,
    BerReader: Ber.Reader,
    BerWriter: Ber.Writer
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ef", ["ee"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('ee');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f0", ["71"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var mod_assert = $__require('71');
  var ASSERT = mod_assert.ok;
  var ctf_versions = ['1.0'];
  var ctf_entries = ['integer', 'float', 'typedef', 'struct'];
  var ctf_deftypes = ['int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t', 'uint32_t', 'float', 'double'];
  function ctfParseInteger(entry, ctype) {
    var name,
        sign,
        len,
        type;
    name = entry['name'];
    if (!('signed' in entry['integer']))
      throw (new Error('Malformed CTF JSON: integer missing ' + 'signed value'));
    if (!('length' in entry['integer']))
      throw (new Error('Malformed CTF JSON: integer missing ' + 'length value'));
    sign = entry['integer']['signed'];
    len = entry['integer']['length'];
    type = null;
    if (sign && len == 1)
      type = 'int8_t';
    else if (len == 1)
      type = 'uint8_t';
    else if (sign && len == 2)
      type = 'int16_t';
    else if (len == 2)
      type = 'uint16_t';
    else if (sign && len == 4)
      type = 'int32_t';
    else if (len == 4)
      type = 'uint32_t';
    else if (sign && len == 8)
      type = 'int64_t';
    else if (len == 8)
      type = 'uint64_t';
    if (type === null)
      throw (new Error('Malformed CTF JSON: integer has ' + 'unsupported length and sign - ' + len + '/' + sign));
    if (name == type)
      return;
    if (name == 'char') {
      ASSERT(type == 'int8_t');
      return;
    }
    ctype.typedef(name, type);
  }
  function ctfParseFloat(entry, ctype) {
    var name,
        len;
    name = entry['name'];
    if (!('length' in entry['float']))
      throw (new Error('Malformed CTF JSON: float missing ' + 'length value'));
    len = entry['float']['length'];
    if (len != 4 && len != 8)
      throw (new Error('Malformed CTF JSON: float has invalid ' + 'length value'));
    if (len == 4) {
      if (name == 'float')
        return;
      ctype.typedef(name, 'float');
    } else if (len == 8) {
      if (name == 'double')
        return;
      ctype.typedef(name, 'double');
    }
  }
  function ctfParseTypedef(entry, ctype) {
    var name,
        type,
        ii;
    name = entry['name'];
    if (typeof(entry['typedef']) != 'string')
      throw (new Error('Malformed CTF JSON: typedef value in not ' + 'a string'));
    type = entry['typedef'];
    for (ii = 0; ii < ctf_deftypes.length; ii++) {
      if (name == ctf_deftypes[ii])
        return;
    }
    ctype.typedef(name, type);
  }
  function ctfParseStruct(entry, ctype) {
    var name,
        type,
        ii,
        val,
        index,
        member,
        push;
    member = [];
    if (!Array.isArray(entry['struct']))
      throw (new Error('Malformed CTF JSON: struct value is not ' + 'an array'));
    for (ii = 0; ii < entry['struct'].length; ii++) {
      val = entry['struct'][ii];
      if (!('name' in val))
        throw (new Error('Malformed CTF JSON: struct member ' + 'missing name'));
      if (!('type' in val))
        throw (new Error('Malformed CTF JSON: struct member ' + 'missing type'));
      if (typeof(val['name']) != 'string')
        throw (new Error('Malformed CTF JSON: struct member ' + 'name isn\'t a string'));
      if (typeof(val['type']) != 'string')
        throw (new Error('Malformed CTF JSON: struct member ' + 'type isn\'t a string'));
      name = val['name'];
      type = val['type'];
      index = type.indexOf(' [');
      if (index != -1) {
        type = type.substring(0, index) + type.substring(index + 1, type.length);
      }
      push = {};
      push[name] = {'type': type};
      member.push(push);
    }
    name = entry['name'];
    ctype.typedef(name, member);
  }
  function ctfParseEntry(entry, ctype) {
    var ii,
        found;
    if (!('name' in entry))
      throw (new Error('Malformed CTF JSON: entry missing "name" ' + 'section'));
    for (ii = 0; ii < ctf_entries.length; ii++) {
      if (ctf_entries[ii] in entry)
        found++;
    }
    if (found === 0)
      throw (new Error('Malformed CTF JSON: found no entries'));
    if (found >= 2)
      throw (new Error('Malformed CTF JSON: found more than one ' + 'entry'));
    if ('integer' in entry) {
      ctfParseInteger(entry, ctype);
      return;
    }
    if ('float' in entry) {
      ctfParseFloat(entry, ctype);
      return;
    }
    if ('typedef' in entry) {
      ctfParseTypedef(entry, ctype);
      return;
    }
    if ('struct' in entry) {
      ctfParseStruct(entry, ctype);
      return;
    }
    ASSERT(false, 'shouldn\'t reach here');
  }
  function ctfParseJson(json, ctype) {
    var version,
        ii;
    ASSERT(json);
    ASSERT(ctype);
    if (!('metadata' in json))
      throw (new Error('Invalid CTF JSON: missing metadata section'));
    if (!('ctf2json_version' in json['metadata']))
      throw (new Error('Invalid CTF JSON: missing ctf2json_version'));
    version = json['metadata']['ctf2json_version'];
    for (ii = 0; ii < ctf_versions.length; ii++) {
      if (ctf_versions[ii] == version)
        break;
    }
    if (ii == ctf_versions.length)
      throw (new Error('Unsuported ctf2json_version: ' + version));
    if (!('data' in json))
      throw (new Error('Invalid CTF JSON: missing data section'));
    if (!Array.isArray(json['data']))
      throw (new Error('Malformed CTF JSON: data section is not ' + 'an array'));
    for (ii = 0; ii < json['data'].length; ii++)
      ctfParseEntry(json['data'][ii], ctype);
  }
  exports.ctfParseJson = ctfParseJson;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f1", ["71", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var mod_assert = $__require('71');
    function ruint8(buffer, endian, offset) {
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      return (buffer[offset]);
    }
    function rgint16(buffer, endian, offset) {
      var val = 0;
      if (endian == 'big') {
        val = buffer[offset] << 8;
        val |= buffer[offset + 1];
      } else {
        val = buffer[offset];
        val |= buffer[offset + 1] << 8;
      }
      return (val);
    }
    function ruint16(buffer, endian, offset) {
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 1 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      return (rgint16(buffer, endian, offset));
    }
    function rgint32(buffer, endian, offset) {
      var val = 0;
      if (endian == 'big') {
        val = buffer[offset + 1] << 16;
        val |= buffer[offset + 2] << 8;
        val |= buffer[offset + 3];
        val = val + (buffer[offset] << 24 >>> 0);
      } else {
        val = buffer[offset + 2] << 16;
        val |= buffer[offset + 1] << 8;
        val |= buffer[offset];
        val = val + (buffer[offset + 3] << 24 >>> 0);
      }
      return (val);
    }
    function ruint32(buffer, endian, offset) {
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 3 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      return (rgint32(buffer, endian, offset));
    }
    function rgint64(buffer, endian, offset) {
      var val = new Array(2);
      if (endian == 'big') {
        val[0] = ruint32(buffer, endian, offset);
        val[1] = ruint32(buffer, endian, offset + 4);
      } else {
        val[0] = ruint32(buffer, endian, offset + 4);
        val[1] = ruint32(buffer, endian, offset);
      }
      return (val);
    }
    function ruint64(buffer, endian, offset) {
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 7 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      return (rgint64(buffer, endian, offset));
    }
    function rsint8(buffer, endian, offset) {
      var neg;
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      neg = buffer[offset] & 0x80;
      if (!neg)
        return (buffer[offset]);
      return ((0xff - buffer[offset] + 1) * -1);
    }
    function rsint16(buffer, endian, offset) {
      var neg,
          val;
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 1 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      val = rgint16(buffer, endian, offset);
      neg = val & 0x8000;
      if (!neg)
        return (val);
      return ((0xffff - val + 1) * -1);
    }
    function rsint32(buffer, endian, offset) {
      var neg,
          val;
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 3 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      val = rgint32(buffer, endian, offset);
      neg = val & 0x80000000;
      if (!neg)
        return (val);
      return ((0xffffffff - val + 1) * -1);
    }
    function rsint64(buffer, endian, offset) {
      var neg,
          val;
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 3 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      val = rgint64(buffer, endian, offset);
      neg = val[0] & 0x80000000;
      if (!neg)
        return (val);
      val[0] = (0xffffffff - val[0]) * -1;
      val[1] = (0xffffffff - val[1] + 1) * -1;
      mod_assert.ok(val[1] <= 0x100000000);
      if (val[1] == -0x100000000) {
        val[1] = 0;
        val[0]--;
      }
      return (val);
    }
    function rfloat(buffer, endian, offset) {
      var bytes = [];
      var sign,
          exponent,
          mantissa,
          val;
      var bias = 127;
      var maxexp = 0xff;
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 3 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      if (endian == 'big') {
        bytes[0] = buffer[offset];
        bytes[1] = buffer[offset + 1];
        bytes[2] = buffer[offset + 2];
        bytes[3] = buffer[offset + 3];
      } else {
        bytes[3] = buffer[offset];
        bytes[2] = buffer[offset + 1];
        bytes[1] = buffer[offset + 2];
        bytes[0] = buffer[offset + 3];
      }
      sign = bytes[0] & 0x80;
      exponent = (bytes[0] & 0x7f) << 1;
      exponent |= (bytes[1] & 0x80) >>> 7;
      mantissa = (bytes[1] & 0x7f) << 16;
      mantissa |= bytes[2] << 8;
      mantissa |= bytes[3];
      if (!sign && exponent == maxexp && mantissa === 0)
        return (Number.POSITIVE_INFINITY);
      if (sign && exponent == maxexp && mantissa === 0)
        return (Number.NEGATIVE_INFINITY);
      if (exponent == maxexp && mantissa !== 0)
        return (Number.NaN);
      if (exponent === 0 && mantissa === 0)
        return (0);
      exponent -= bias;
      if (exponent == -bias) {
        exponent++;
        val = 0;
      } else {
        val = 1;
      }
      val = (val + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);
      if (sign)
        val *= -1;
      return (val);
    }
    function rdouble(buffer, endian, offset) {
      var bytes = [];
      var sign,
          exponent,
          mantissa,
          val,
          lowmant;
      var bias = 1023;
      var maxexp = 0x7ff;
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 7 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      if (endian == 'big') {
        bytes[0] = buffer[offset];
        bytes[1] = buffer[offset + 1];
        bytes[2] = buffer[offset + 2];
        bytes[3] = buffer[offset + 3];
        bytes[4] = buffer[offset + 4];
        bytes[5] = buffer[offset + 5];
        bytes[6] = buffer[offset + 6];
        bytes[7] = buffer[offset + 7];
      } else {
        bytes[7] = buffer[offset];
        bytes[6] = buffer[offset + 1];
        bytes[5] = buffer[offset + 2];
        bytes[4] = buffer[offset + 3];
        bytes[3] = buffer[offset + 4];
        bytes[2] = buffer[offset + 5];
        bytes[1] = buffer[offset + 6];
        bytes[0] = buffer[offset + 7];
      }
      sign = bytes[0] & 0x80;
      exponent = (bytes[0] & 0x7f) << 4;
      exponent |= (bytes[1] & 0xf0) >>> 4;
      lowmant = bytes[7];
      lowmant |= bytes[6] << 8;
      lowmant |= bytes[5] << 16;
      mantissa = bytes[4];
      mantissa |= bytes[3] << 8;
      mantissa |= bytes[2] << 16;
      mantissa |= (bytes[1] & 0x0f) << 24;
      mantissa *= Math.pow(2, 24);
      mantissa += lowmant;
      if (!sign && exponent == maxexp && mantissa === 0)
        return (Number.POSITIVE_INFINITY);
      if (sign && exponent == maxexp && mantissa === 0)
        return (Number.NEGATIVE_INFINITY);
      if (exponent == maxexp && mantissa !== 0)
        return (Number.NaN);
      if (exponent === 0 && mantissa === 0)
        return (0);
      exponent -= bias;
      if (exponent == -bias) {
        exponent++;
        val = 0;
      } else {
        val = 1;
      }
      val = (val + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);
      if (sign)
        val *= -1;
      return (val);
    }
    function prepuint(value, max) {
      if (typeof(value) != 'number')
        throw (new (Error('cannot write a non-number as a number')));
      if (value < 0)
        throw (new Error('specified a negative value for writing an ' + 'unsigned value'));
      if (value > max)
        throw (new Error('value is larger than maximum value for ' + 'type'));
      if (Math.floor(value) !== value)
        throw (new Error('value has a fractional component'));
      return (value);
    }
    function wuint8(value, endian, buffer, offset) {
      var val;
      if (value === undefined)
        throw (new Error('missing value'));
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      val = prepuint(value, 0xff);
      buffer[offset] = val;
    }
    function wgint16(val, endian, buffer, offset) {
      if (endian == 'big') {
        buffer[offset] = (val & 0xff00) >>> 8;
        buffer[offset + 1] = val & 0x00ff;
      } else {
        buffer[offset + 1] = (val & 0xff00) >>> 8;
        buffer[offset] = val & 0x00ff;
      }
    }
    function wuint16(value, endian, buffer, offset) {
      var val;
      if (value === undefined)
        throw (new Error('missing value'));
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 1 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      val = prepuint(value, 0xffff);
      wgint16(val, endian, buffer, offset);
    }
    function wgint32(val, endian, buffer, offset) {
      if (endian == 'big') {
        buffer[offset] = (val - (val & 0x00ffffff)) / Math.pow(2, 24);
        buffer[offset + 1] = (val >>> 16) & 0xff;
        buffer[offset + 2] = (val >>> 8) & 0xff;
        buffer[offset + 3] = val & 0xff;
      } else {
        buffer[offset + 3] = (val - (val & 0x00ffffff)) / Math.pow(2, 24);
        buffer[offset + 2] = (val >>> 16) & 0xff;
        buffer[offset + 1] = (val >>> 8) & 0xff;
        buffer[offset] = val & 0xff;
      }
    }
    function wuint32(value, endian, buffer, offset) {
      var val;
      if (value === undefined)
        throw (new Error('missing value'));
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 3 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      val = prepuint(value, 0xffffffff);
      wgint32(val, endian, buffer, offset);
    }
    function wgint64(value, endian, buffer, offset) {
      if (endian == 'big') {
        wgint32(value[0], endian, buffer, offset);
        wgint32(value[1], endian, buffer, offset + 4);
      } else {
        wgint32(value[0], endian, buffer, offset + 4);
        wgint32(value[1], endian, buffer, offset);
      }
    }
    function wuint64(value, endian, buffer, offset) {
      if (value === undefined)
        throw (new Error('missing value'));
      if (!(value instanceof Array))
        throw (new Error('value must be an array'));
      if (value.length != 2)
        throw (new Error('value must be an array of length 2'));
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 7 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      prepuint(value[0], 0xffffffff);
      prepuint(value[1], 0xffffffff);
      wgint64(value, endian, buffer, offset);
    }
    function prepsint(value, max, min) {
      if (typeof(value) != 'number')
        throw (new (Error('cannot write a non-number as a number')));
      if (value > max)
        throw (new Error('value larger than maximum allowed value'));
      if (value < min)
        throw (new Error('value smaller than minimum allowed value'));
      if (Math.floor(value) !== value)
        throw (new Error('value has a fractional component'));
      return (value);
    }
    function wsint8(value, endian, buffer, offset) {
      var val;
      if (value === undefined)
        throw (new Error('missing value'));
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      val = prepsint(value, 0x7f, -0x80);
      if (val >= 0)
        wuint8(val, endian, buffer, offset);
      else
        wuint8(0xff + val + 1, endian, buffer, offset);
    }
    function wsint16(value, endian, buffer, offset) {
      var val;
      if (value === undefined)
        throw (new Error('missing value'));
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 1 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      val = prepsint(value, 0x7fff, -0x8000);
      if (val >= 0)
        wgint16(val, endian, buffer, offset);
      else
        wgint16(0xffff + val + 1, endian, buffer, offset);
    }
    function wsint32(value, endian, buffer, offset) {
      var val;
      if (value === undefined)
        throw (new Error('missing value'));
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 3 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      val = prepsint(value, 0x7fffffff, -0x80000000);
      if (val >= 0)
        wgint32(val, endian, buffer, offset);
      else
        wgint32(0xffffffff + val + 1, endian, buffer, offset);
    }
    function wsint64(value, endian, buffer, offset) {
      var vzpos,
          vopos;
      var vals = new Array(2);
      if (value === undefined)
        throw (new Error('missing value'));
      if (!(value instanceof Array))
        throw (new Error('value must be an array'));
      if (value.length != 2)
        throw (new Error('value must be an array of length 2'));
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 7 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      vzpos = (value[0] * Number.POSITIVE_INFINITY) == Number.POSITIVE_INFINITY;
      vopos = (value[1] * Number.POSITIVE_INFINITY) == Number.POSITIVE_INFINITY;
      if (value[0] != 0 && value[1] != 0 && vzpos != vopos)
        throw (new Error('Both entries in the array must have ' + 'the same sign'));
      if (vzpos) {
        prepuint(value[0], 0x7fffffff);
        prepuint(value[1], 0xffffffff);
      } else {
        prepsint(value[0], 0, -0x80000000);
        prepsint(value[1], 0, -0xffffffff);
        if (value[0] == -0x80000000 && value[1] != 0)
          throw (new Error('value smaller than minimum ' + 'allowed value'));
      }
      if (value[0] < 0 || value[1] < 0) {
        vals[0] = 0xffffffff - Math.abs(value[0]);
        vals[1] = 0x100000000 - Math.abs(value[1]);
        if (vals[1] == 0x100000000) {
          vals[1] = 0;
          vals[0]++;
        }
      } else {
        vals[0] = value[0];
        vals[1] = value[1];
      }
      wgint64(vals, endian, buffer, offset);
    }
    function log2(value) {
      return (Math.log(value) / Math.log(2));
    }
    function intexp(value) {
      return (Math.floor(log2(value)));
    }
    function fracexp(value) {
      return (Math.floor(log2(value)));
    }
    function wfloat(value, endian, buffer, offset) {
      var sign,
          exponent,
          mantissa,
          ebits;
      var bytes = [];
      if (value === undefined)
        throw (new Error('missing value'));
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 3 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      if (isNaN(value)) {
        sign = 0;
        exponent = 0xff;
        mantissa = 23;
      } else if (value == Number.POSITIVE_INFINITY) {
        sign = 0;
        exponent = 0xff;
        mantissa = 0;
      } else if (value == Number.NEGATIVE_INFINITY) {
        sign = 1;
        exponent = 0xff;
        mantissa = 0;
      } else {
        if (value < 0) {
          sign = 1;
          value = Math.abs(value);
        } else {
          sign = 0;
        }
        if (value < 1)
          ebits = fracexp(value);
        else
          ebits = intexp(value);
        if (ebits <= -127) {
          exponent = 0;
          mantissa = (value * Math.pow(2, 149)) & 0x7fffff;
        } else {
          exponent = 127 + ebits;
          mantissa = value * Math.pow(2, 23 - ebits);
          mantissa &= 0x7fffff;
        }
      }
      bytes[0] = sign << 7 | (exponent & 0xfe) >>> 1;
      bytes[1] = (exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16;
      bytes[2] = (mantissa & 0x00ff00) >>> 8;
      bytes[3] = mantissa & 0x0000ff;
      if (endian == 'big') {
        buffer[offset] = bytes[0];
        buffer[offset + 1] = bytes[1];
        buffer[offset + 2] = bytes[2];
        buffer[offset + 3] = bytes[3];
      } else {
        buffer[offset] = bytes[3];
        buffer[offset + 1] = bytes[2];
        buffer[offset + 2] = bytes[1];
        buffer[offset + 3] = bytes[0];
      }
    }
    function wdouble(value, endian, buffer, offset) {
      var sign,
          exponent,
          mantissa,
          ebits;
      var bytes = [];
      if (value === undefined)
        throw (new Error('missing value'));
      if (endian === undefined)
        throw (new Error('missing endian'));
      if (buffer === undefined)
        throw (new Error('missing buffer'));
      if (offset === undefined)
        throw (new Error('missing offset'));
      if (offset + 7 >= buffer.length)
        throw (new Error('Trying to read beyond buffer length'));
      if (isNaN(value)) {
        sign = 0;
        exponent = 0x7ff;
        mantissa = 23;
      } else if (value == Number.POSITIVE_INFINITY) {
        sign = 0;
        exponent = 0x7ff;
        mantissa = 0;
      } else if (value == Number.NEGATIVE_INFINITY) {
        sign = 1;
        exponent = 0x7ff;
        mantissa = 0;
      } else {
        if (value < 0) {
          sign = 1;
          value = Math.abs(value);
        } else {
          sign = 0;
        }
        if (value < 1)
          ebits = fracexp(value);
        else
          ebits = intexp(value);
        if (value <= 2.225073858507201e-308 || ebits <= -1023) {
          exponent = 0;
          mantissa = value * Math.pow(2, 1023) * Math.pow(2, 51);
          mantissa %= Math.pow(2, 52);
        } else {
          if (ebits > 1023)
            ebits = 1023;
          exponent = 1023 + ebits;
          mantissa = value * Math.pow(2, -ebits);
          mantissa *= Math.pow(2, 52);
          mantissa %= Math.pow(2, 52);
        }
      }
      bytes[7] = mantissa & 0xff;
      bytes[6] = (mantissa >>> 8) & 0xff;
      bytes[5] = (mantissa >>> 16) & 0xff;
      mantissa = (mantissa - (mantissa & 0xffffff)) / Math.pow(2, 24);
      bytes[4] = mantissa & 0xff;
      bytes[3] = (mantissa >>> 8) & 0xff;
      bytes[2] = (mantissa >>> 16) & 0xff;
      bytes[1] = (exponent & 0x00f) << 4 | mantissa >>> 24;
      bytes[0] = (sign << 7) | (exponent & 0x7f0) >>> 4;
      if (endian == 'big') {
        buffer[offset] = bytes[0];
        buffer[offset + 1] = bytes[1];
        buffer[offset + 2] = bytes[2];
        buffer[offset + 3] = bytes[3];
        buffer[offset + 4] = bytes[4];
        buffer[offset + 5] = bytes[5];
        buffer[offset + 6] = bytes[6];
        buffer[offset + 7] = bytes[7];
      } else {
        buffer[offset + 7] = bytes[0];
        buffer[offset + 6] = bytes[1];
        buffer[offset + 5] = bytes[2];
        buffer[offset + 4] = bytes[3];
        buffer[offset + 3] = bytes[4];
        buffer[offset + 2] = bytes[5];
        buffer[offset + 1] = bytes[6];
        buffer[offset] = bytes[7];
      }
    }
    exports.ruint8 = ruint8;
    exports.ruint16 = ruint16;
    exports.ruint32 = ruint32;
    exports.ruint64 = ruint64;
    exports.wuint8 = wuint8;
    exports.wuint16 = wuint16;
    exports.wuint32 = wuint32;
    exports.wuint64 = wuint64;
    exports.rsint8 = rsint8;
    exports.rsint16 = rsint16;
    exports.rsint32 = rsint32;
    exports.rsint64 = rsint64;
    exports.wsint8 = wsint8;
    exports.wsint16 = wsint16;
    exports.wsint32 = wsint32;
    exports.wsint64 = wsint64;
    exports.rfloat = rfloat;
    exports.rdouble = rdouble;
    exports.wfloat = wfloat;
    exports.wdouble = wdouble;
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f2", ["f0", "f1", "71", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var mod_ctf = $__require('f0');
    var mod_ctio = $__require('f1');
    var mod_assert = $__require('71');
    var deftypes = {
      'uint8_t': {
        read: ctReadUint8,
        write: ctWriteUint8
      },
      'uint16_t': {
        read: ctReadUint16,
        write: ctWriteUint16
      },
      'uint32_t': {
        read: ctReadUint32,
        write: ctWriteUint32
      },
      'uint64_t': {
        read: ctReadUint64,
        write: ctWriteUint64
      },
      'int8_t': {
        read: ctReadSint8,
        write: ctWriteSint8
      },
      'int16_t': {
        read: ctReadSint16,
        write: ctWriteSint16
      },
      'int32_t': {
        read: ctReadSint32,
        write: ctWriteSint32
      },
      'int64_t': {
        read: ctReadSint64,
        write: ctWriteSint64
      },
      'float': {
        read: ctReadFloat,
        write: ctWriteFloat
      },
      'double': {
        read: ctReadDouble,
        write: ctWriteDouble
      },
      'char': {
        read: ctReadChar,
        write: ctWriteChar
      },
      'char[]': {
        read: ctReadCharArray,
        write: ctWriteCharArray
      }
    };
    function ctReadUint8(endian, buffer, offset) {
      var val = mod_ctio.ruint8(buffer, endian, offset);
      return ({
        value: val,
        size: 1
      });
    }
    function ctReadUint16(endian, buffer, offset) {
      var val = mod_ctio.ruint16(buffer, endian, offset);
      return ({
        value: val,
        size: 2
      });
    }
    function ctReadUint32(endian, buffer, offset) {
      var val = mod_ctio.ruint32(buffer, endian, offset);
      return ({
        value: val,
        size: 4
      });
    }
    function ctReadUint64(endian, buffer, offset) {
      var val = mod_ctio.ruint64(buffer, endian, offset);
      return ({
        value: val,
        size: 8
      });
    }
    function ctReadSint8(endian, buffer, offset) {
      var val = mod_ctio.rsint8(buffer, endian, offset);
      return ({
        value: val,
        size: 1
      });
    }
    function ctReadSint16(endian, buffer, offset) {
      var val = mod_ctio.rsint16(buffer, endian, offset);
      return ({
        value: val,
        size: 2
      });
    }
    function ctReadSint32(endian, buffer, offset) {
      var val = mod_ctio.rsint32(buffer, endian, offset);
      return ({
        value: val,
        size: 4
      });
    }
    function ctReadSint64(endian, buffer, offset) {
      var val = mod_ctio.rsint64(buffer, endian, offset);
      return ({
        value: val,
        size: 8
      });
    }
    function ctReadFloat(endian, buffer, offset) {
      var val = mod_ctio.rfloat(buffer, endian, offset);
      return ({
        value: val,
        size: 4
      });
    }
    function ctReadDouble(endian, buffer, offset) {
      var val = mod_ctio.rdouble(buffer, endian, offset);
      return ({
        value: val,
        size: 8
      });
    }
    function ctReadChar(endian, buffer, offset) {
      var res = new Buffer(1);
      res[0] = mod_ctio.ruint8(buffer, endian, offset);
      return ({
        value: res,
        size: 1
      });
    }
    function ctReadCharArray(length, endian, buffer, offset) {
      var ii;
      var res = new Buffer(length);
      for (ii = 0; ii < length; ii++)
        res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);
      return ({
        value: res,
        size: length
      });
    }
    function ctWriteUint8(value, endian, buffer, offset) {
      mod_ctio.wuint8(value, endian, buffer, offset);
      return (1);
    }
    function ctWriteUint16(value, endian, buffer, offset) {
      mod_ctio.wuint16(value, endian, buffer, offset);
      return (2);
    }
    function ctWriteUint32(value, endian, buffer, offset) {
      mod_ctio.wuint32(value, endian, buffer, offset);
      return (4);
    }
    function ctWriteUint64(value, endian, buffer, offset) {
      mod_ctio.wuint64(value, endian, buffer, offset);
      return (8);
    }
    function ctWriteSint8(value, endian, buffer, offset) {
      mod_ctio.wsint8(value, endian, buffer, offset);
      return (1);
    }
    function ctWriteSint16(value, endian, buffer, offset) {
      mod_ctio.wsint16(value, endian, buffer, offset);
      return (2);
    }
    function ctWriteSint32(value, endian, buffer, offset) {
      mod_ctio.wsint32(value, endian, buffer, offset);
      return (4);
    }
    function ctWriteSint64(value, endian, buffer, offset) {
      mod_ctio.wsint64(value, endian, buffer, offset);
      return (8);
    }
    function ctWriteFloat(value, endian, buffer, offset) {
      mod_ctio.wfloat(value, endian, buffer, offset);
      return (4);
    }
    function ctWriteDouble(value, endian, buffer, offset) {
      mod_ctio.wdouble(value, endian, buffer, offset);
      return (8);
    }
    function ctWriteChar(value, endian, buffer, offset) {
      if (!(value instanceof Buffer))
        throw (new Error('Input must be a buffer'));
      mod_ctio.ruint8(value[0], endian, buffer, offset);
      return (1);
    }
    function ctWriteCharArray(value, length, endian, buffer, offset) {
      var ii;
      if (!(value instanceof Buffer))
        throw (new Error('Input must be a buffer'));
      if (value.length > length)
        throw (new Error('value length greater than array length'));
      for (ii = 0; ii < value.length && ii < length; ii++)
        mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);
      for (; ii < length; ii++)
        mod_ctio.wuint8(0, endian, offset + ii);
      return (length);
    }
    function ctGetBasicTypes() {
      var ret = {};
      var key;
      for (key in deftypes)
        ret[key] = deftypes[key];
      return (ret);
    }
    function ctParseType(str) {
      var begInd,
          endInd;
      var type,
          len;
      if (typeof(str) != 'string')
        throw (new Error('type must be a Javascript string'));
      endInd = str.lastIndexOf(']');
      if (endInd == -1) {
        if (str.lastIndexOf('[') != -1)
          throw (new Error('found invalid type with \'[\' but ' + 'no corresponding \']\''));
        return ({type: str});
      }
      begInd = str.lastIndexOf('[');
      if (begInd == -1)
        throw (new Error('found invalid type with \']\' but ' + 'no corresponding \'[\''));
      if (begInd >= endInd)
        throw (new Error('malformed type, \']\' appears before \'[\''));
      type = str.substring(0, begInd);
      len = str.substring(begInd + 1, endInd);
      return ({
        type: type,
        len: len
      });
    }
    function ctCheckReq(def, types, fields) {
      var ii,
          jj;
      var req,
          keys,
          key;
      var found = {};
      if (!(def instanceof Array))
        throw (new Error('definition is not an array'));
      if (def.length === 0)
        throw (new Error('definition must have at least one element'));
      for (ii = 0; ii < def.length; ii++) {
        req = def[ii];
        if (!(req instanceof Object))
          throw (new Error('definition must be an array of' + 'objects'));
        keys = Object.keys(req);
        if (keys.length != 1)
          throw (new Error('definition entry must only have ' + 'one key'));
        if (keys[0] in found)
          throw (new Error('Specified name already ' + 'specified: ' + keys[0]));
        if (!('type' in req[keys[0]]))
          throw (new Error('missing required type definition'));
        key = ctParseType(req[keys[0]]['type']);
        while (key['len'] !== undefined) {
          if (isNaN(parseInt(key['len'], 10))) {
            if (!(key['len'] in found))
              throw (new Error('Given an array ' + 'length without a matching type'));
          }
          key = ctParseType(key['type']);
        }
        if (!(key['type'] in types))
          throw (new Error('type not found or typdefed: ' + key['type']));
        if (fields !== undefined) {
          for (jj = 0; jj < fields.length; jj++) {
            if (!(fields[jj] in req[keys[0]]))
              throw (new Error('Missing required ' + 'field: ' + fields[jj]));
          }
        }
        found[keys[0]] = true;
      }
    }
    function CTypeParser(conf) {
      if (!conf)
        throw (new Error('missing required argument'));
      if (!('endian' in conf))
        throw (new Error('missing required endian value'));
      if (conf['endian'] != 'big' && conf['endian'] != 'little')
        throw (new Error('Invalid endian type'));
      if ('char-type' in conf && (conf['char-type'] != 'uint8' && conf['char-type'] != 'int8'))
        throw (new Error('invalid option for char-type: ' + conf['char-type']));
      this.endian = conf['endian'];
      this.types = ctGetBasicTypes();
      if ('char-type' in conf && conf['char-type'] == 'uint8')
        this.types['char'] = this.types['uint8_t'];
      if ('char-type' in conf && conf['char-type'] == 'int8')
        this.types['char'] = this.types['int8_t'];
    }
    CTypeParser.prototype.setEndian = function(endian) {
      if (endian != 'big' && endian != 'little')
        throw (new Error('invalid endian type, must be big or ' + 'little'));
      this.endian = endian;
    };
    CTypeParser.prototype.getEndian = function() {
      return (this.endian);
    };
    CTypeParser.prototype.typedef = function(name, value) {
      var type;
      if (name === undefined)
        throw (new (Error('missing required typedef argument: name')));
      if (value === undefined)
        throw (new (Error('missing required typedef argument: value')));
      if (typeof(name) != 'string')
        throw (new (Error('the name of a type must be a string')));
      type = ctParseType(name);
      if (type['len'] !== undefined)
        throw (new Error('Cannot have an array in the typedef name'));
      if (name in this.types)
        throw (new Error('typedef name already present: ' + name));
      if (typeof(value) != 'string' && !(value instanceof Array))
        throw (new Error('typedef value must either be a string or ' + 'struct'));
      if (typeof(value) == 'string') {
        type = ctParseType(value);
        if (type['len'] !== undefined) {
          if (isNaN(parseInt(type['len'], 10)))
            throw (new (Error('typedef value must use ' + 'fixed size array when outside of a ' + 'struct')));
        }
        this.types[name] = value;
      } else {
        ctCheckReq(value, this.types);
        this.types[name] = value;
      }
    };
    CTypeParser.prototype.lstypes = function() {
      var key;
      var ret = {};
      for (key in this.types) {
        if (key in deftypes)
          continue;
        ret[key] = this.types[key];
      }
      return (ret);
    };
    function ctResolveArray(str, values) {
      var ret = '';
      var type = ctParseType(str);
      while (type['len'] !== undefined) {
        if (isNaN(parseInt(type['len'], 10))) {
          if (typeof(values[type['len']]) != 'number')
            throw (new Error('cannot sawp in non-number ' + 'for array value'));
          ret = '[' + values[type['len']] + ']' + ret;
        } else {
          ret = '[' + type['len'] + ']' + ret;
        }
        type = ctParseType(type['type']);
      }
      ret = type['type'] + ret;
      return (ret);
    }
    CTypeParser.prototype.resolveTypedef = function(type, dispatch, buffer, offset, value) {
      var pt;
      mod_assert.ok(type in this.types);
      if (typeof(this.types[type]) == 'string') {
        pt = ctParseType(this.types[type]);
        if (dispatch == 'read')
          return (this.readEntry(pt, buffer, offset));
        else if (dispatch == 'write')
          return (this.writeEntry(value, pt, buffer, offset));
        else
          throw (new Error('invalid dispatch type to ' + 'resolveTypedef'));
      } else {
        if (dispatch == 'read')
          return (this.readStruct(this.types[type], buffer, offset));
        else if (dispatch == 'write')
          return (this.writeStruct(value, this.types[type], buffer, offset));
        else
          throw (new Error('invalid dispatch type to ' + 'resolveTypedef'));
      }
    };
    CTypeParser.prototype.readEntry = function(type, buffer, offset) {
      var parse,
          len;
      if (type['len'] !== undefined) {
        len = parseInt(type['len'], 10);
        if (isNaN(len))
          throw (new Error('somehow got a non-numeric length'));
        if (type['type'] == 'char')
          parse = this.types['char[]']['read'](len, this.endian, buffer, offset);
        else
          parse = this.readArray(type['type'], len, buffer, offset);
      } else {
        if (type['type'] in deftypes)
          parse = this.types[type['type']]['read'](this.endian, buffer, offset);
        else
          parse = this.resolveTypedef(type['type'], 'read', buffer, offset);
      }
      return (parse);
    };
    CTypeParser.prototype.readArray = function(type, length, buffer, offset) {
      var ii,
          ent,
          pt;
      var baseOffset = offset;
      var ret = new Array(length);
      pt = ctParseType(type);
      for (ii = 0; ii < length; ii++) {
        ent = this.readEntry(pt, buffer, offset);
        offset += ent['size'];
        ret[ii] = ent['value'];
      }
      return ({
        value: ret,
        size: offset - baseOffset
      });
    };
    CTypeParser.prototype.readStruct = function(def, buffer, offset) {
      var parse,
          ii,
          type,
          entry,
          key;
      var baseOffset = offset;
      var ret = {};
      for (ii = 0; ii < def.length; ii++) {
        key = Object.keys(def[ii])[0];
        entry = def[ii][key];
        type = ctParseType(ctResolveArray(entry['type'], ret));
        if ('offset' in entry)
          offset = baseOffset + entry['offset'];
        parse = this.readEntry(type, buffer, offset);
        offset += parse['size'];
        ret[key] = parse['value'];
      }
      return ({
        value: ret,
        size: (offset - baseOffset)
      });
    };
    CTypeParser.prototype.readData = function(def, buffer, offset) {
      if (def === undefined)
        throw (new Error('missing definition for what we should be' + 'parsing'));
      if (buffer === undefined)
        throw (new Error('missing buffer for what we should be ' + 'parsing'));
      if (offset === undefined)
        throw (new Error('missing offset for what we should be ' + 'parsing'));
      ctCheckReq(def, this.types);
      return (this.readStruct(def, buffer, offset)['value']);
    };
    CTypeParser.prototype.writeArray = function(value, type, length, buffer, offset) {
      var ii,
          pt;
      var baseOffset = offset;
      if (!(value instanceof Array))
        throw (new Error('asked to write an array, but value is not ' + 'an array'));
      if (value.length != length)
        throw (new Error('asked to write array of length ' + length + ' but that does not match value length: ' + value.length));
      pt = ctParseType(type);
      for (ii = 0; ii < length; ii++)
        offset += this.writeEntry(value[ii], pt, buffer, offset);
      return (offset - baseOffset);
    };
    CTypeParser.prototype.writeEntry = function(value, type, buffer, offset) {
      var len,
          ret;
      if (type['len'] !== undefined) {
        len = parseInt(type['len'], 10);
        if (isNaN(len))
          throw (new Error('somehow got a non-numeric length'));
        if (type['type'] == 'char')
          ret = this.types['char[]']['write'](value, len, this.endian, buffer, offset);
        else
          ret = this.writeArray(value, type['type'], len, buffer, offset);
      } else {
        if (type['type'] in deftypes)
          ret = this.types[type['type']]['write'](value, this.endian, buffer, offset);
        else
          ret = this.resolveTypedef(type['type'], 'write', buffer, offset, value);
      }
      return (ret);
    };
    CTypeParser.prototype.writeStruct = function(value, def, buffer, offset) {
      var ii,
          entry,
          type,
          key;
      var baseOffset = offset;
      var vals = {};
      for (ii = 0; ii < def.length; ii++) {
        key = Object.keys(def[ii])[0];
        entry = def[ii][key];
        type = ctParseType(ctResolveArray(entry['type'], vals));
        if ('offset' in entry)
          offset = baseOffset + entry['offset'];
        offset += this.writeEntry(value[ii], type, buffer, offset);
        vals[key] = value[ii];
      }
      return (offset);
    };
    function getValues(def) {
      var ii,
          out,
          key;
      out = [];
      for (ii = 0; ii < def.length; ii++) {
        key = Object.keys(def[ii])[0];
        mod_assert.ok('value' in def[ii][key]);
        out.push(def[ii][key]['value']);
      }
      return (out);
    }
    CTypeParser.prototype.writeData = function(def, buffer, offset, values) {
      var hv;
      if (def === undefined)
        throw (new Error('missing definition for what we should be' + 'parsing'));
      if (buffer === undefined)
        throw (new Error('missing buffer for what we should be ' + 'parsing'));
      if (offset === undefined)
        throw (new Error('missing offset for what we should be ' + 'parsing'));
      hv = (values != null && values != undefined);
      if (hv) {
        if (!Array.isArray(values))
          throw (new Error('missing values for writing'));
        ctCheckReq(def, this.types);
      } else {
        ctCheckReq(def, this.types, ['value']);
      }
      this.writeStruct(hv ? values : getValues(def), def, buffer, offset);
    };
    function toAbs64(val) {
      if (val === undefined)
        throw (new Error('missing required arg: value'));
      if (!Array.isArray(val))
        throw (new Error('value must be an array'));
      if (val.length != 2)
        throw (new Error('value must be an array of length 2'));
      if (val[0] >= 0x100000)
        throw (new Error('value would become approximated'));
      return (val[0] * Math.pow(2, 32) + val[1]);
    }
    function toApprox64(val) {
      if (val === undefined)
        throw (new Error('missing required arg: value'));
      if (!Array.isArray(val))
        throw (new Error('value must be an array'));
      if (val.length != 2)
        throw (new Error('value must be an array of length 2'));
      return (Math.pow(2, 32) * val[0] + val[1]);
    }
    function parseCTF(json, conf) {
      var ctype = new CTypeParser(conf);
      mod_ctf.ctfParseJson(json, ctype);
      return (ctype);
    }
    exports.Parser = CTypeParser;
    exports.toAbs64 = toAbs64;
    exports.toApprox64 = toApprox64;
    exports.parseCTF = parseCTF;
    exports.ruint8 = mod_ctio.ruint8;
    exports.ruint16 = mod_ctio.ruint16;
    exports.ruint32 = mod_ctio.ruint32;
    exports.ruint64 = mod_ctio.ruint64;
    exports.wuint8 = mod_ctio.wuint8;
    exports.wuint16 = mod_ctio.wuint16;
    exports.wuint32 = mod_ctio.wuint32;
    exports.wuint64 = mod_ctio.wuint64;
    exports.rsint8 = mod_ctio.rsint8;
    exports.rsint16 = mod_ctio.rsint16;
    exports.rsint32 = mod_ctio.rsint32;
    exports.rsint64 = mod_ctio.rsint64;
    exports.wsint8 = mod_ctio.wsint8;
    exports.wsint16 = mod_ctio.wsint16;
    exports.wsint32 = mod_ctio.wsint32;
    exports.wsint64 = mod_ctio.wsint64;
    exports.rfloat = mod_ctio.rfloat;
    exports.rdouble = mod_ctio.rdouble;
    exports.wfloat = mod_ctio.wfloat;
    exports.wdouble = mod_ctio.wdouble;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f3", ["f2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('f2');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f4", ["e5", "cd", "ef", "f3", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var assert = $__require('e5');
    var crypto = $__require('cd');
    var asn1 = $__require('ef');
    var ctype = $__require('f3');
    function readNext(buffer, offset) {
      var len = ctype.ruint32(buffer, 'big', offset);
      offset += 4;
      var newOffset = offset + len;
      return {
        data: buffer.slice(offset, newOffset),
        offset: newOffset
      };
    }
    function writeInt(writer, buffer) {
      writer.writeByte(0x02);
      writer.writeLength(buffer.length);
      for (var i = 0; i < buffer.length; i++)
        writer.writeByte(buffer[i]);
      return writer;
    }
    function rsaToPEM(key) {
      var buffer;
      var der;
      var exponent;
      var i;
      var modulus;
      var newKey = '';
      var offset = 0;
      var type;
      var tmp;
      try {
        buffer = new Buffer(key.split(' ')[1], 'base64');
        tmp = readNext(buffer, offset);
        type = tmp.data.toString();
        offset = tmp.offset;
        if (type !== 'ssh-rsa')
          throw new Error('Invalid ssh key type: ' + type);
        tmp = readNext(buffer, offset);
        exponent = tmp.data;
        offset = tmp.offset;
        tmp = readNext(buffer, offset);
        modulus = tmp.data;
      } catch (e) {
        throw new Error('Invalid ssh key: ' + key);
      }
      der = new asn1.BerWriter();
      der.startSequence();
      der.startSequence();
      der.writeOID('1.2.840.113549.1.1.1');
      der.writeNull();
      der.endSequence();
      der.startSequence(0x03);
      der.writeByte(0x00);
      der.startSequence();
      writeInt(der, modulus);
      writeInt(der, exponent);
      der.endSequence();
      der.endSequence();
      der.endSequence();
      tmp = der.buffer.toString('base64');
      for (i = 0; i < tmp.length; i++) {
        if ((i % 64) === 0)
          newKey += '\n';
        newKey += tmp.charAt(i);
      }
      if (!/\\n$/.test(newKey))
        newKey += '\n';
      return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
    }
    function dsaToPEM(key) {
      var buffer;
      var offset = 0;
      var tmp;
      var der;
      var newKey = '';
      var type;
      var p;
      var q;
      var g;
      var y;
      try {
        buffer = new Buffer(key.split(' ')[1], 'base64');
        tmp = readNext(buffer, offset);
        type = tmp.data.toString();
        offset = tmp.offset;
        if (!/^ssh-ds[as].*/.test(type))
          throw new Error('Invalid ssh key type: ' + type);
        tmp = readNext(buffer, offset);
        p = tmp.data;
        offset = tmp.offset;
        tmp = readNext(buffer, offset);
        q = tmp.data;
        offset = tmp.offset;
        tmp = readNext(buffer, offset);
        g = tmp.data;
        offset = tmp.offset;
        tmp = readNext(buffer, offset);
        y = tmp.data;
      } catch (e) {
        console.log(e.stack);
        throw new Error('Invalid ssh key: ' + key);
      }
      der = new asn1.BerWriter();
      der.startSequence();
      der.startSequence();
      der.writeOID('1.2.840.10040.4.1');
      der.startSequence();
      writeInt(der, p);
      writeInt(der, q);
      writeInt(der, g);
      der.endSequence();
      der.endSequence();
      der.startSequence(0x03);
      der.writeByte(0x00);
      writeInt(der, y);
      der.endSequence();
      der.endSequence();
      tmp = der.buffer.toString('base64');
      for (var i = 0; i < tmp.length; i++) {
        if ((i % 64) === 0)
          newKey += '\n';
        newKey += tmp.charAt(i);
      }
      if (!/\\n$/.test(newKey))
        newKey += '\n';
      return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
    }
    module.exports = {
      sshKeyToPEM: function sshKeyToPEM(key) {
        assert.string(key, 'ssh_key');
        if (/^ssh-rsa.*/.test(key))
          return rsaToPEM(key);
        if (/^ssh-ds[as].*/.test(key))
          return dsaToPEM(key);
        throw new Error('Only RSA and DSA public keys are allowed');
      },
      fingerprint: function fingerprint(key) {
        assert.string(key, 'ssh_key');
        var pieces = key.split(' ');
        if (!pieces || !pieces.length || pieces.length < 2)
          throw new Error('invalid ssh key');
        var data = new Buffer(pieces[1], 'base64');
        var hash = crypto.createHash('md5');
        hash.update(data);
        var digest = hash.digest('hex');
        var fp = '';
        for (var i = 0; i < digest.length; i++) {
          if (i && i % 2 === 0)
            fp += ':';
          fp += digest[i];
        }
        return fp;
      },
      pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
        assert.equal('string', typeof(pem), 'typeof pem');
        var cleaned = pem.split('\n').slice(1, -2).join('');
        var buf = new Buffer(cleaned, 'base64');
        var der = new asn1.BerReader(buf);
        der.readSequence();
        der.readSequence();
        var oid = der.readOID();
        assert.equal(oid, '1.2.840.113549.1.1.1', 'pem not in RSA format');
        der.readByte();
        der.readByte();
        der.readSequence(0x03);
        der.readByte();
        der.readSequence();
        assert.equal(der.peek(), asn1.Ber.Integer, 'modulus not an integer');
        der._offset = der.readLength(der.offset + 1);
        var modulus = der._buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
        assert.equal(der.peek(), asn1.Ber.Integer, 'exponent not an integer');
        der._offset = der.readLength(der.offset + 1);
        var exponent = der._buf.slice(der.offset, der.offset + der.length);
        der._offset += der.length;
        var type = new Buffer('ssh-rsa');
        var buffer = new Buffer(4 + type.length + 4 + modulus.length + 4 + exponent.length);
        var i = 0;
        buffer.writeUInt32BE(type.length, i);
        i += 4;
        type.copy(buffer, i);
        i += type.length;
        buffer.writeUInt32BE(exponent.length, i);
        i += 4;
        exponent.copy(buffer, i);
        i += exponent.length;
        buffer.writeUInt32BE(modulus.length, i);
        i += 4;
        modulus.copy(buffer, i);
        i += modulus.length;
        var s = (type.toString() + ' ' + buffer.toString('base64') + ' ' + (comment || ''));
        return s;
      }
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f5", ["e4", "e6", "e7", "f4"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var parser = $__require('e4');
  var signer = $__require('e6');
  var verify = $__require('e7');
  var util = $__require('f4');
  module.exports = {
    parse: parser.parseRequest,
    parseRequest: parser.parseRequest,
    sign: signer.signRequest,
    signRequest: signer.signRequest,
    sshKeyToPEM: util.sshKeyToPEM,
    sshKeyFingerprint: util.fingerprint,
    pemToRsaSSHKey: util.pemToRsaSSHKey,
    verify: verify.verifySignature,
    verifySignature: verify.verifySignature,
    verifyHMAC: verify.verifyHMAC
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f6", ["f5"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('f5');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f7", ["f6", "69", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var httpSignature = $__require('f6');
    var errors = $__require('69');
    var InvalidHeaderError = errors.InvalidHeaderError;
    var OPTIONS = {algorithms: ['rsa-sha1', 'rsa-sha256', 'rsa-sha512', 'dsa-sha1', 'hmac-sha1', 'hmac-sha256', 'hmac-sha512']};
    function parseBasic(string) {
      var decoded;
      var index;
      var pieces;
      decoded = (new Buffer(string, 'base64')).toString('utf8');
      if (!decoded) {
        throw new InvalidHeaderError('Authorization header invalid');
      }
      index = decoded.indexOf(':');
      if (index === -1) {
        pieces = [decoded];
      } else {
        pieces = [decoded.slice(0, index), decoded.slice(index + 1)];
      }
      if (!pieces || typeof(pieces[0]) !== 'string') {
        throw new InvalidHeaderError('Authorization header invalid');
      }
      if (!pieces[0]) {
        pieces[0] = null;
      }
      if (!pieces[1]) {
        pieces[1] = null;
      }
      return ({
        username: pieces[0],
        password: pieces[1]
      });
    }
    function parseSignature(request, options) {
      var opts = options || {};
      opts.algorithms = OPTIONS.algorithms;
      try {
        return (httpSignature.parseRequest(request, options));
      } catch (e) {
        throw new InvalidHeaderError('Authorization header invalid: ' + e.message);
      }
    }
    function authorizationParser(options) {
      function parseAuthorization(req, res, next) {
        req.authorization = {};
        req.username = 'anonymous';
        if (!req.headers.authorization) {
          return (next());
        }
        var pieces = req.headers.authorization.split(' ', 2);
        if (!pieces || pieces.length !== 2) {
          var e = new InvalidHeaderError('BasicAuth content ' + 'is invalid.');
          return (next(e));
        }
        req.authorization.scheme = pieces[0];
        req.authorization.credentials = pieces[1];
        try {
          switch (pieces[0].toLowerCase()) {
            case 'basic':
              req.authorization.basic = parseBasic(pieces[1]);
              req.username = req.authorization.basic.username;
              break;
            case 'signature':
              req.authorization.signature = parseSignature(req, options);
              req.username = req.authorization.signature.keyId;
              break;
            default:
              break;
          }
        } catch (e2) {
          return (next(e2));
        }
        return (next());
      }
      return (parseAuthorization);
    }
    module.exports = authorizationParser;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f8", ["58", "59"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Generator,
      stream,
      util;
  stream = $__require('58');
  util = $__require('59');
  module.exports = function() {
    var callback,
        data,
        generator,
        options;
    if (arguments.length === 2) {
      options = arguments[0];
      callback = arguments[1];
    } else if (arguments.length === 1) {
      if (typeof arguments[0] === 'function') {
        options = {};
        callback = arguments[0];
      } else {
        options = arguments[0];
      }
    } else if (arguments.length === 0) {
      options = {};
    }
    generator = new Generator(options);
    if (callback) {
      data = [];
      generator.on('readable', function() {
        var d,
            _results;
        _results = [];
        while (d = generator.read()) {
          _results.push(data.push(options.objectMode ? d : d.toString()));
        }
        return _results;
      });
      generator.on('error', callback);
      generator.on('end', function() {
        return callback(null, options.objectMode ? data : data.join(''));
      });
    }
    return generator;
  };
  Generator = function(options) {
    var i,
        v,
        _base,
        _base1,
        _base2,
        _base3,
        _base4,
        _base5,
        _base6,
        _base7,
        _base8,
        _i,
        _len,
        _ref;
    this.options = options != null ? options : {};
    stream.Readable.call(this, this.options);
    this.options.count = 0;
    if ((_base = this.options).duration == null) {
      _base.duration = 4 * 60 * 1000;
    }
    if ((_base1 = this.options).columns == null) {
      _base1.columns = 8;
    }
    if ((_base2 = this.options).max_word_length == null) {
      _base2.max_word_length = 16;
    }
    if ((_base3 = this.options).fixed_size == null) {
      _base3.fixed_size = false;
    }
    if (this.fixed_size_buffer == null) {
      this.fixed_size_buffer = '';
    }
    if ((_base4 = this.options).start == null) {
      _base4.start = Date.now();
    }
    if ((_base5 = this.options).end == null) {
      _base5.end = null;
    }
    if ((_base6 = this.options).seed == null) {
      _base6.seed = false;
    }
    if ((_base7 = this.options).length == null) {
      _base7.length = -1;
    }
    if ((_base8 = this.options).delimiter == null) {
      _base8.delimiter = ',';
    }
    this.count_written = 0;
    this.count_created = 0;
    if (typeof this.options.columns === 'number') {
      this.options.columns = new Array(this.options.columns);
    }
    _ref = this.options.columns;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      v = _ref[i];
      if (v == null) {
        v = 'ascii';
      }
      if (typeof v === 'string') {
        this.options.columns[i] = Generator[v];
      }
    }
    return this;
  };
  util.inherits(Generator, stream.Readable);
  module.exports.Generator = Generator;
  Generator.prototype.random = function() {
    if (this.options.seed) {
      return this.options.seed = this.options.seed * Math.PI * 100 % 100 / 100;
    } else {
      return Math.random();
    }
  };
  Generator.prototype.end = function() {
    return this.push(null);
  };
  Generator.prototype._read = function(size) {
    var column,
        data,
        header,
        length,
        line,
        lineLength,
        _i,
        _j,
        _k,
        _l,
        _len,
        _len1,
        _len2,
        _len3,
        _ref;
    data = [];
    length = this.fixed_size_buffer.length;
    if (length) {
      data.push(this.fixed_size_buffer);
    }
    while (true) {
      if ((this.count_created === this.options.length) || (this.options.end && Date.now() > this.options.end)) {
        if (data.length) {
          if (this.options.objectMode) {
            for (_i = 0, _len = data.length; _i < _len; _i++) {
              line = data[_i];
              this.count_written++;
              this.push(line);
            }
          } else {
            this.count_written++;
            this.push(data.join(''));
          }
        }
        return this.push(null);
      }
      line = [];
      _ref = this.options.columns;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        header = _ref[_j];
        line.push("" + (header(this)));
      }
      if (this.options.objectMode) {
        lineLength = 0;
        for (_k = 0, _len2 = line.length; _k < _len2; _k++) {
          column = line[_k];
          lineLength += column.length;
        }
      } else {
        line = "" + (this.count_created === 0 ? '' : '\n') + (line.join(this.options.delimiter));
        lineLength = line.length;
      }
      this.count_created++;
      if (length + lineLength > size) {
        if (this.options.objectMode) {
          data.push(line);
          for (_l = 0, _len3 = data.length; _l < _len3; _l++) {
            line = data[_l];
            this.count_written++;
            this.push(line);
          }
        } else {
          if (this.options.fixed_size) {
            this.fixed_size_buffer = line.substr(size - length);
            data.push(line.substr(0, size - length));
          } else {
            data.push(line);
          }
          this.count_written++;
          this.push(data.join(''));
        }
        break;
      }
      length += lineLength;
      data.push(line);
    }
  };
  Generator.ascii = function(gen) {
    var char,
        column,
        nb_chars,
        _i,
        _ref;
    column = [];
    for (nb_chars = _i = 0, _ref = Math.ceil(gen.random() * gen.options.max_word_length); 0 <= _ref ? _i < _ref : _i > _ref; nb_chars = 0 <= _ref ? ++_i : --_i) {
      char = Math.floor(gen.random() * 32);
      column.push(String.fromCharCode(char + (char < 16 ? 65 : 97 - 16)));
    }
    return column.join('');
  };
  Generator.int = function(gen) {
    return Math.floor(gen.random() * Math.pow(2, 52));
  };
  Generator.bool = function(gen) {
    return Math.floor(gen.random() * 2);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f9", ["f8"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('f8');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("fa", ["f9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('f9');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("fb", ["58", "59", "fc", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var Parser,
        StringDecoder,
        stream,
        util;
    stream = $__require('58');
    util = $__require('59');
    StringDecoder = $__require('fc').StringDecoder;
    module.exports = function() {
      var callback,
          called,
          chunks,
          data,
          options,
          parser;
      if (arguments.length === 3) {
        data = arguments[0];
        options = arguments[1];
        callback = arguments[2];
        if (typeof callback !== 'function') {
          throw Error("Invalid callback argument: " + (JSON.stringify(callback)));
        }
        if (!(typeof data === 'string' || Buffer.isBuffer(arguments[0]))) {
          return callback(Error("Invalid data argument: " + (JSON.stringify(data))));
        }
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === 'string' || Buffer.isBuffer(arguments[0])) {
          data = arguments[0];
        } else {
          options = arguments[0];
        }
        if (typeof arguments[1] === 'function') {
          callback = arguments[1];
        } else {
          options = arguments[1];
        }
      } else if (arguments.length === 1) {
        if (typeof arguments[0] === 'function') {
          callback = arguments[0];
        } else {
          options = arguments[0];
        }
      }
      if (options == null) {
        options = {};
      }
      parser = new Parser(options);
      if (data != null) {
        process.nextTick(function() {
          parser.write(data);
          return parser.end();
        });
      }
      if (callback) {
        called = false;
        chunks = options.objname ? {} : [];
        parser.on('readable', function() {
          var chunk,
              results;
          results = [];
          while (chunk = parser.read()) {
            if (options.objname) {
              results.push(chunks[chunk[0]] = chunk[1]);
            } else {
              results.push(chunks.push(chunk));
            }
          }
          return results;
        });
        parser.on('error', function(err) {
          called = true;
          return callback(err);
        });
        parser.on('end', function() {
          if (!called) {
            return callback(null, chunks);
          }
        });
      }
      return parser;
    };
    Parser = function(options) {
      var base,
          base1,
          base10,
          base11,
          base12,
          base2,
          base3,
          base4,
          base5,
          base6,
          base7,
          base8,
          base9,
          k,
          v;
      if (options == null) {
        options = {};
      }
      options.objectMode = true;
      this.options = {};
      for (k in options) {
        v = options[k];
        this.options[k] = v;
      }
      stream.Transform.call(this, this.options);
      if ((base = this.options).rowDelimiter == null) {
        base.rowDelimiter = null;
      }
      if ((base1 = this.options).delimiter == null) {
        base1.delimiter = ',';
      }
      if ((base2 = this.options).quote == null) {
        base2.quote = '"';
      }
      if ((base3 = this.options).escape == null) {
        base3.escape = '"';
      }
      if ((base4 = this.options).columns == null) {
        base4.columns = null;
      }
      if ((base5 = this.options).comment == null) {
        base5.comment = '';
      }
      if ((base6 = this.options).objname == null) {
        base6.objname = false;
      }
      if ((base7 = this.options).trim == null) {
        base7.trim = false;
      }
      if ((base8 = this.options).ltrim == null) {
        base8.ltrim = false;
      }
      if ((base9 = this.options).rtrim == null) {
        base9.rtrim = false;
      }
      if ((base10 = this.options).auto_parse == null) {
        base10.auto_parse = false;
      }
      if ((base11 = this.options).auto_parse_date == null) {
        base11.auto_parse_date = false;
      }
      if ((base12 = this.options).skip_empty_lines == null) {
        base12.skip_empty_lines = false;
      }
      this.lines = 0;
      this.count = 0;
      this.is_int = /^(\-|\+)?([1-9]+[0-9]*)$/;
      this.is_float = function(value) {
        return (value - parseFloat(value) + 1) >= 0;
      };
      this.decoder = new StringDecoder();
      this.buf = '';
      this.quoting = false;
      this.commenting = false;
      this.field = '';
      this.nextChar = null;
      this.closingQuote = 0;
      this.line = [];
      this.chunks = [];
      return this;
    };
    util.inherits(Parser, stream.Transform);
    module.exports.Parser = Parser;
    Parser.prototype._transform = function(chunk, encoding, callback) {
      var err;
      if (chunk instanceof Buffer) {
        chunk = this.decoder.write(chunk);
      }
      try {
        this.__write(chunk, false);
        return callback();
      } catch (error) {
        err = error;
        return this.emit('error', err);
      }
    };
    Parser.prototype._flush = function(callback) {
      var err;
      try {
        this.__write(this.decoder.end(), true);
        if (this.quoting) {
          this.emit('error', new Error("Quoted field not terminated at line " + (this.lines + 1)));
          return;
        }
        if (this.line.length > 0) {
          this.__push(this.line);
        }
        return callback();
      } catch (error) {
        err = error;
        return this.emit('error', err);
      }
    };
    Parser.prototype.__push = function(line) {
      var field,
          i,
          j,
          len,
          lineAsColumns;
      if (this.options.columns === true) {
        this.options.columns = line;
        return;
      } else if (typeof this.options.columns === 'function') {
        this.options.columns = this.options.columns(line);
        return;
      }
      this.count++;
      if (this.options.columns != null) {
        lineAsColumns = {};
        for (i = j = 0, len = line.length; j < len; i = ++j) {
          field = line[i];
          lineAsColumns[this.options.columns[i]] = field;
        }
        if (this.options.objname) {
          return this.push([lineAsColumns[this.options.objname], lineAsColumns]);
        } else {
          return this.push(lineAsColumns);
        }
      } else {
        return this.push(line);
      }
    };
    Parser.prototype.__write = function(chars, end, callback) {
      var acceptedLength,
          areNextCharsDelimiter,
          areNextCharsRowDelimiters,
          auto_parse,
          char,
          escapeIsQuote,
          i,
          isDelimiter,
          isEscape,
          isNextCharAComment,
          isQuote,
          isRowDelimiter,
          is_float,
          is_int,
          l,
          ltrim,
          nextCharPos,
          ref,
          results,
          rowDelimiter,
          rowDelimiterLength,
          rtrim,
          wasCommenting;
      is_int = (function(_this) {
        return function(value) {
          if (typeof _this.is_int === 'function') {
            return _this.is_int(value);
          } else {
            return _this.is_int.test(value);
          }
        };
      })(this);
      is_float = (function(_this) {
        return function(value) {
          if (typeof _this.is_float === 'function') {
            return _this.is_float(value);
          } else {
            return _this.is_float.test(value);
          }
        };
      })(this);
      auto_parse = (function(_this) {
        return function(value) {
          var m;
          if (_this.options.auto_parse && is_int(_this.field)) {
            _this.field = parseInt(_this.field);
          } else if (_this.options.auto_parse && is_float(_this.field)) {
            _this.field = parseFloat(_this.field);
          } else if (_this.options.auto_parse && _this.options.auto_parse_date) {
            m = Date.parse(_this.field);
            if (!isNaN(m)) {
              _this.field = new Date(m);
            }
          }
          return _this.field;
        };
      })(this);
      ltrim = this.options.trim || this.options.ltrim;
      rtrim = this.options.trim || this.options.rtrim;
      chars = this.buf + chars;
      l = chars.length;
      rowDelimiterLength = this.options.rowDelimiter ? this.options.rowDelimiter.length : 0;
      i = 0;
      if (this.lines === 0 && 0xFEFF === chars.charCodeAt(0)) {
        i++;
      }
      while (i < l) {
        acceptedLength = rowDelimiterLength + this.options.comment.length + this.options.escape.length + this.options.delimiter.length;
        if (this.quoting) {
          acceptedLength += this.options.quote.length;
        }
        if (!end && (i + acceptedLength >= l)) {
          break;
        }
        char = this.nextChar ? this.nextChar : chars.charAt(i);
        this.nextChar = chars.charAt(i + 1);
        if (this.options.rowDelimiter == null) {
          if ((this.field === '') && (char === '\n' || char === '\r')) {
            rowDelimiter = char;
            nextCharPos = i + 1;
          } else if (this.nextChar === '\n' || this.nextChar === '\r') {
            rowDelimiter = this.nextChar;
            nextCharPos = i + 2;
          }
          if (rowDelimiter) {
            if (rowDelimiter === '\r' && chars.charAt(nextCharPos) === '\n') {
              rowDelimiter += '\n';
            }
            this.options.rowDelimiter = rowDelimiter;
            rowDelimiterLength = this.options.rowDelimiter.length;
          }
        }
        if (!this.commenting && char === this.options.escape) {
          escapeIsQuote = this.options.escape === this.options.quote;
          isEscape = this.nextChar === this.options.escape;
          isQuote = this.nextChar === this.options.quote;
          if (!(escapeIsQuote && !this.field && !this.quoting) && (isEscape || isQuote)) {
            i++;
            char = this.nextChar;
            this.nextChar = chars.charAt(i + 1);
            this.field += char;
            i++;
            continue;
          }
        }
        if (!this.commenting && char === this.options.quote) {
          if (this.quoting) {
            areNextCharsRowDelimiters = this.options.rowDelimiter && chars.substr(i + 1, this.options.rowDelimiter.length) === this.options.rowDelimiter;
            areNextCharsDelimiter = chars.substr(i + 1, this.options.delimiter.length) === this.options.delimiter;
            isNextCharAComment = this.nextChar === this.options.comment;
            if (this.nextChar && !areNextCharsRowDelimiters && !areNextCharsDelimiter && !isNextCharAComment) {
              if (this.options.relax) {
                this.quoting = false;
                this.field = "" + this.options.quote + this.field;
              } else {
                throw Error("Invalid closing quote at line " + (this.lines + 1) + "; found " + (JSON.stringify(this.nextChar)) + " instead of delimiter " + (JSON.stringify(this.options.delimiter)));
              }
            } else {
              this.quoting = false;
              this.closingQuote = this.options.quote.length;
              i++;
              if (end && i === l) {
                this.line.push(auto_parse(this.field));
              }
              continue;
            }
          } else if (!this.field) {
            this.quoting = true;
            i++;
            continue;
          } else if (this.field && !this.options.relax) {
            throw Error("Invalid opening quote at line " + (this.lines + 1));
          }
        }
        isRowDelimiter = this.options.rowDelimiter && chars.substr(i, this.options.rowDelimiter.length) === this.options.rowDelimiter;
        if (isRowDelimiter) {
          this.lines++;
        }
        wasCommenting = false;
        if (!this.commenting && !this.quoting && this.options.comment && chars.substr(i, this.options.comment.length) === this.options.comment) {
          this.commenting = true;
        } else if (this.commenting && isRowDelimiter) {
          wasCommenting = true;
          this.commenting = false;
        }
        isDelimiter = chars.substr(i, this.options.delimiter.length) === this.options.delimiter;
        if (!this.commenting && !this.quoting && (isDelimiter || isRowDelimiter)) {
          if (isRowDelimiter && this.line.length === 0 && this.field === '') {
            if (wasCommenting || this.options.skip_empty_lines) {
              i += this.options.rowDelimiter.length;
              this.nextChar = chars.charAt(i);
              continue;
            }
          }
          if (rtrim) {
            if (!this.closingQuote) {
              this.field = this.field.trimRight();
            }
          }
          this.line.push(auto_parse(this.field));
          this.closingQuote = 0;
          this.field = '';
          if (isDelimiter) {
            i += this.options.delimiter.length;
            this.nextChar = chars.charAt(i);
            if (end && !this.nextChar) {
              isRowDelimiter = true;
              this.line.push('');
            }
          }
          if (isRowDelimiter) {
            this.__push(this.line);
            this.line = [];
            i += (ref = this.options.rowDelimiter) != null ? ref.length : void 0;
            this.nextChar = chars.charAt(i);
            continue;
          }
        } else if (!this.commenting && !this.quoting && (char === ' ' || char === '\t')) {
          if (!(ltrim && !this.field)) {
            this.field += char;
          }
          if (end && i + 1 === l) {
            if (this.options.trim || this.options.rtrim) {
              this.field = this.field.trimRight();
            }
            this.line.push(auto_parse(this.field));
          }
          i++;
        } else if (!this.commenting) {
          this.field += char;
          i++;
          if (end && i === l) {
            this.line.push(auto_parse(this.field));
          }
        } else {
          i++;
        }
      }
      this.buf = '';
      results = [];
      while (i < l) {
        this.buf += chars.charAt(i);
        results.push(i++);
      }
      return results;
    };
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("fd", ["fb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('fb');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("fe", ["fd"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('fd');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ff", ["58", "59", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var Transformer,
        stream,
        util,
        slice = [].slice;
    stream = $__require('58');
    util = $__require('59');
    module.exports = function() {
      var argument,
          callback,
          data,
          error,
          handler,
          i,
          j,
          k,
          len,
          options,
          result,
          transform,
          type,
          v;
      options = {};
      for (i = j = 0, len = arguments.length; j < len; i = ++j) {
        argument = arguments[i];
        type = typeof argument;
        if (argument === null) {
          type = 'null';
        } else if (type === 'object' && Array.isArray(argument)) {
          type = 'array';
        }
        if (i === 0) {
          if (type === 'function') {
            handler = argument;
          } else if (type !== null) {
            data = argument;
          }
          continue;
        }
        if (type === 'object') {
          for (k in argument) {
            v = argument[k];
            options[k] = v;
          }
        } else if (type === 'function') {
          if (handler && i === arguments.length - 1) {
            callback = argument;
          } else {
            handler = argument;
          }
        } else if (type !== 'null') {
          throw new Error('Invalid arguments');
        }
      }
      transform = new Transformer(options, handler);
      error = false;
      if (data) {
        process.nextTick(function() {
          var l,
              len1,
              row;
          for (l = 0, len1 = data.length; l < len1; l++) {
            row = data[l];
            if (error) {
              break;
            }
            transform.write(row);
          }
          return transform.end();
        });
      }
      if (callback || options.consume) {
        result = [];
        transform.on('readable', function() {
          var r,
              results;
          results = [];
          while ((r = transform.read())) {
            results.push(result.push(r));
          }
          return results;
        });
        transform.on('error', function(err) {
          error = true;
          if (callback) {
            return callback(err);
          }
        });
        transform.on('end', function() {
          if (callback && !error) {
            return callback(null, result);
          }
        });
      }
      return transform;
    };
    Transformer = function(options1, transform1) {
      var base;
      this.options = options1 != null ? options1 : {};
      this.transform = transform1;
      this.options.objectMode = true;
      if ((base = this.options).parallel == null) {
        base.parallel = 100;
      }
      stream.Transform.call(this, this.options);
      this.running = 0;
      this.started = 0;
      this.finished = 0;
      return this;
    };
    util.inherits(Transformer, stream.Transform);
    module.exports.Transformer = Transformer;
    Transformer.prototype._transform = function(chunk, encoding, cb) {
      var err;
      this.started++;
      this.running++;
      if (this.running < this.options.parallel) {
        cb();
        cb = null;
      }
      try {
        if (this.transform.length === 2) {
          this.transform.call(null, chunk, (function(_this) {
            return function() {
              var chunks,
                  err;
              err = arguments[0], chunks = 2 <= arguments.length ? slice.call(arguments, 1) : [];
              return _this._done(err, chunks, cb);
            };
          })(this));
        } else {
          this._done(null, [this.transform.call(null, chunk)], cb);
        }
        return false;
      } catch (_error) {
        err = _error;
        return this._done(err);
      }
    };
    Transformer.prototype._flush = function(cb) {
      this._ending = function() {
        if (this.running === 0) {
          return cb();
        }
      };
      return this._ending();
    };
    Transformer.prototype._done = function(err, chunks, cb) {
      var chunk,
          j,
          len;
      this.running--;
      if (err) {
        return this.emit('error', err);
      }
      this.finished++;
      for (j = 0, len = chunks.length; j < len; j++) {
        chunk = chunks[j];
        if (typeof chunk === 'number') {
          chunk = "" + chunk;
        }
        if (chunk != null) {
          this.push(chunk);
        }
      }
      if (cb) {
        cb();
      }
      if (this._ending) {
        return this._ending();
      }
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("100", ["ff"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('ff');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("101", ["100"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('100');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("102", ["58", "59", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var Stringifier,
        stream,
        util;
    stream = $__require('58');
    util = $__require('59');
    module.exports = function() {
      var callback,
          chunks,
          data,
          options,
          stringifier;
      if (arguments.length === 3) {
        data = arguments[0];
        options = arguments[1];
        callback = arguments[2];
      } else if (arguments.length === 2) {
        if (Array.isArray(arguments[0])) {
          data = arguments[0];
        } else {
          options = arguments[0];
        }
        if (typeof arguments[1] === 'function') {
          callback = arguments[1];
        } else {
          options = arguments[1];
        }
      } else if (arguments.length === 1) {
        if (typeof arguments[0] === 'function') {
          callback = arguments[0];
        } else if (Array.isArray(arguments[0])) {
          data = arguments[0];
        } else {
          options = arguments[0];
        }
      }
      if (options == null) {
        options = {};
      }
      stringifier = new Stringifier(options);
      if (data) {
        process.nextTick(function() {
          var d,
              j,
              len;
          for (j = 0, len = data.length; j < len; j++) {
            d = data[j];
            stringifier.write(d);
          }
          return stringifier.end();
        });
      }
      if (callback) {
        chunks = [];
        stringifier.on('readable', function() {
          var chunk,
              results;
          results = [];
          while (chunk = stringifier.read()) {
            results.push(chunks.push(chunk));
          }
          return results;
        });
        stringifier.on('error', function(err) {
          return callback(err);
        });
        stringifier.on('end', function() {
          return callback(null, chunks.join(''));
        });
      }
      return stringifier;
    };
    Stringifier = function(options) {
      var base,
          base1,
          base2,
          base3,
          base4,
          base5,
          base6,
          base7,
          base8;
      if (options == null) {
        options = {};
      }
      stream.Transform.call(this, options);
      this.options = options;
      if ((base = this.options).delimiter == null) {
        base.delimiter = ',';
      }
      if ((base1 = this.options).quote == null) {
        base1.quote = '"';
      }
      if ((base2 = this.options).quoted == null) {
        base2.quoted = false;
      }
      if ((base3 = this.options).quotedString == null) {
        base3.quotedString = false;
      }
      if ((base4 = this.options).eof == null) {
        base4.eof = true;
      }
      if ((base5 = this.options).escape == null) {
        base5.escape = '"';
      }
      if ((base6 = this.options).columns == null) {
        base6.columns = null;
      }
      if ((base7 = this.options).header == null) {
        base7.header = false;
      }
      if ((base8 = this.options).rowDelimiter == null) {
        base8.rowDelimiter = '\n';
      }
      if (this.countWriten == null) {
        this.countWriten = 0;
      }
      switch (this.options.rowDelimiter) {
        case 'auto':
          this.options.rowDelimiter = null;
          break;
        case 'unix':
          this.options.rowDelimiter = "\n";
          break;
        case 'mac':
          this.options.rowDelimiter = "\r";
          break;
        case 'windows':
          this.options.rowDelimiter = "\r\n";
          break;
        case 'unicode':
          this.options.rowDelimiter = "\u2028";
      }
      return this;
    };
    util.inherits(Stringifier, stream.Transform);
    module.exports.Stringifier = Stringifier;
    Stringifier.prototype.headers = function() {
      var k,
          label,
          labels;
      if (!this.options.header) {
        return;
      }
      if (!this.options.columns) {
        return;
      }
      labels = this.options.columns;
      if (typeof labels === 'object') {
        labels = (function() {
          var results;
          results = [];
          for (k in labels) {
            label = labels[k];
            results.push(label);
          }
          return results;
        })();
      }
      if (this.options.eof) {
        labels = this.stringify(labels) + this.options.rowDelimiter;
      } else {
        labels = this.stringify(labels);
      }
      return stream.Transform.prototype.write.call(this, labels);
    };
    Stringifier.prototype.end = function(chunk, encoding, callback) {
      if (this.countWriten === 0) {
        this.headers();
      }
      return stream.Transform.prototype.end.apply(this, arguments);
    };
    Stringifier.prototype.write = function(chunk, encoding, callback) {
      var base,
          e,
          preserve;
      if (chunk == null) {
        return;
      }
      preserve = typeof chunk !== 'object';
      if (!preserve) {
        if (this.countWriten === 0 && !Array.isArray(chunk)) {
          if ((base = this.options).columns == null) {
            base.columns = Object.keys(chunk);
          }
        }
        try {
          this.emit('record', chunk, this.countWriten);
        } catch (_error) {
          e = _error;
          return this.emit('error', e);
        }
        if (this.options.eof) {
          chunk = this.stringify(chunk) + this.options.rowDelimiter;
        } else {
          chunk = this.stringify(chunk);
          if (this.options.header || this.countWriten) {
            chunk = this.options.rowDelimiter + chunk;
          }
        }
      }
      if (typeof chunk === 'number') {
        chunk = "" + chunk;
      }
      if (this.countWriten === 0) {
        this.headers();
      }
      if (!preserve) {
        this.countWriten++;
      }
      return stream.Transform.prototype.write.call(this, chunk, encoding, callback);
    };
    Stringifier.prototype._transform = function(chunk, encoding, callback) {
      this.push(chunk);
      return callback();
    };
    Stringifier.prototype.stringify = function(line) {
      var _line,
          column,
          columns,
          containsLinebreak,
          containsQuote,
          containsdelimiter,
          delimiter,
          escape,
          field,
          i,
          j,
          l,
          newLine,
          quote,
          ref,
          ref1,
          regexp;
      if (typeof line !== 'object') {
        return line;
      }
      columns = this.options.columns;
      if (typeof columns === 'object' && columns !== null && !Array.isArray(columns)) {
        columns = Object.keys(columns);
      }
      delimiter = this.options.delimiter;
      quote = this.options.quote;
      escape = this.options.escape;
      if (!Array.isArray(line)) {
        _line = [];
        if (columns) {
          for (i = j = 0, ref = columns.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            column = columns[i];
            _line[i] = typeof line[column] === 'undefined' || line[column] === null ? '' : line[column];
          }
        } else {
          for (column in line) {
            _line.push(line[column]);
          }
        }
        line = _line;
        _line = null;
      } else if (columns) {
        line.splice(columns.length);
      }
      if (Array.isArray(line)) {
        newLine = '';
        for (i = l = 0, ref1 = line.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
          field = line[i];
          if (typeof field === 'string') {} else if (typeof field === 'number') {
            field = '' + field;
          } else if (typeof field === 'boolean') {
            field = field ? '1' : '';
          } else if (field instanceof Date) {
            field = '' + field.getTime();
          } else if (typeof field === 'object' && field !== null) {
            field = JSON.stringify(field);
          }
          if (field) {
            containsdelimiter = field.indexOf(delimiter) >= 0;
            containsQuote = field.indexOf(quote) >= 0;
            containsLinebreak = field.indexOf('\r') >= 0 || field.indexOf('\n') >= 0;
            if (containsQuote) {
              regexp = new RegExp(quote, 'g');
              field = field.replace(regexp, escape + quote);
            }
            if (containsQuote || containsdelimiter || containsLinebreak || this.options.quoted || (this.options.quotedString && typeof line[i] === 'string')) {
              field = quote + field + quote;
            }
            newLine += field;
          } else if (this.options.quotedEmpty || ((this.options.quotedEmpty == null) && line[i] === '' && this.options.quotedString)) {
            newLine += quote + quote;
          }
          if (i !== line.length - 1) {
            newLine += delimiter;
          }
        }
        line = newLine;
      }
      return line;
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("103", ["102"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('102');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("104", ["103"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('103');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("105", ["fa", "fe", "101", "104"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var generate,
      parse,
      stringify,
      transform;
  generate = $__require('fa');
  parse = $__require('fe');
  transform = $__require('101');
  stringify = $__require('104');
  module.exports.generate = generate;
  module.exports.parse = parse;
  module.exports.transform = transform;
  module.exports.stringify = stringify;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("106", ["105"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('105');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("107", ["106"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('106');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("108", ["107", "5a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var csv = $__require('107');
  var assert = $__require('5a');
  function fieldedTextParser(options) {
    assert.optionalObject(options, 'options');
    function parseFieldedText(req, res, next) {
      req.rawBody = req._body = req.body;
      var contentType = req.getContentType();
      if (contentType !== 'text/csv' && contentType !== 'text/tsv' && contentType !== 'text/tab-separated-values' || !req.body) {
        next();
        return;
      }
      var hDelimiter = req.headers['x-content-delimiter'];
      var hEscape = req.headers['x-content-escape'];
      var hQuote = req.headers['x-content-quote'];
      var hColumns = req.headers['x-content-columns'];
      var delimiter = (contentType === 'text/tsv') ? '\t' : ',';
      delimiter = (hDelimiter) ? hDelimiter : delimiter;
      var escape = (hEscape) ? hEscape : '\\';
      var quote = (hQuote) ? hQuote : '"';
      var columns = (hColumns) ? hColumns : true;
      var parserOptions = {
        delimiter: delimiter,
        quote: quote,
        escape: escape,
        columns: columns
      };
      csv.parse(req.body, parserOptions, function(err, parsedBody) {
        if (err) {
          return (next(err));
        }
        parsedBody.forEach(function(row, index) {
          row.index = index;
        });
        req.body = parsedBody;
        return (next());
      });
    }
    return (parseFieldedText);
  }
  module.exports = fieldedTextParser;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("109", ["5a", "69", "10a", "10b", "10c", "10d", "108"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('5a');
  var errors = $__require('69');
  var bodyReader = $__require('10a');
  var jsonParser = $__require('10b');
  var formParser = $__require('10c');
  var multipartParser = $__require('10d');
  var fieldedTextParser = $__require('108');
  var UnsupportedMediaTypeError = errors.UnsupportedMediaTypeError;
  function bodyParser(options) {
    assert.optionalObject(options, 'options');
    var opts = options || {};
    opts.bodyReader = true;
    var read = bodyReader(opts);
    var parseForm = formParser(opts);
    var parseJson = jsonParser(opts);
    var parseMultipart = multipartParser(opts);
    var parseFieldedText = fieldedTextParser(opts);
    function parseBody(req, res, next) {
      if (req.method === 'HEAD') {
        next();
        return;
      }
      if (req.method === 'GET') {
        if (!opts.requestBodyOnGet) {
          next();
          return;
        }
      }
      if (req.contentLength() === 0 && !req.isChunked()) {
        next();
        return;
      }
      var parser;
      var type = req.contentType().toLowerCase();
      switch (type) {
        case 'application/json':
          parser = parseJson[0];
          break;
        case 'application/x-www-form-urlencoded':
          parser = parseForm[0];
          break;
        case 'multipart/form-data':
          parser = parseMultipart;
          break;
        case 'text/tsv':
          parser = parseFieldedText;
          break;
        case 'text/tab-separated-values':
          parser = parseFieldedText;
          break;
        case 'text/csv':
          parser = parseFieldedText;
          break;
        default:
          break;
      }
      if (parser) {
        parser(req, res, next);
      } else if (opts && opts.rejectUnknown) {
        next(new UnsupportedMediaTypeError(type));
      } else {
        next();
      }
    }
    return ([read, parseBody]);
  }
  module.exports = bodyParser;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("10e", ["69"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var errors = $__require('69');
  var BadRequestError = errors.BadRequestError;
  var PreconditionFailedError = errors.PreconditionFailedError;
  var IF_MATCH_FAIL = 'if-match \'%s\' didn\'t match etag \'%s\'';
  var IF_NO_MATCH_FAIL = 'if-none-match \'%s\' matched etag \'%s\'';
  var IF_MOD_FAIL = 'object was modified at \'%s\'; if-modified-since \'%s\'';
  var IF_UNMOD_FAIL = 'object was modified at \'%s\'; if-unmodified-since \'%s\'';
  function checkIfMatch(req, res, next) {
    var clientETags;
    var cur;
    var etag = res.etag || res.getHeader('etag') || '';
    var ifMatch;
    var matched = false;
    if ((ifMatch = req.headers['if-match'])) {
      clientETags = ifMatch.split(/\s*,\s*/);
      for (var i = 0; i < clientETags.length; i++) {
        cur = clientETags[i];
        cur = cur.replace(/^W\//, '');
        cur = cur.replace(/^"(\w*)"$/, '$1');
        if (cur === '*' || cur === etag) {
          matched = true;
          break;
        }
      }
      if (!matched) {
        var err = new PreconditionFailedError(IF_MATCH_FAIL, ifMatch, etag);
        return (next(err));
      }
    }
    return (next());
  }
  function checkIfNoneMatch(req, res, next) {
    var clientETags;
    var cur;
    var etag = res.etag || res.getHeader('etag') || '';
    var ifNoneMatch;
    var matched = false;
    if ((ifNoneMatch = req.headers['if-none-match'])) {
      clientETags = ifNoneMatch.split(/\s*,\s*/);
      for (var i = 0; i < clientETags.length; i++) {
        cur = clientETags[i];
        cur = cur.replace(/^W\//, '');
        cur = cur.replace(/^"(\w*)"$/, '$1');
        if (cur === '*' || cur === etag) {
          matched = true;
          break;
        }
      }
      if (!matched) {
        return (next());
      }
      if (req.method !== 'GET' && req.method !== 'HEAD') {
        var err = new PreconditionFailedError(IF_NO_MATCH_FAIL, ifNoneMatch, etag);
        return (next(err));
      }
      res.send(304);
      return (next(false));
    }
    return (next());
  }
  function checkIfModified(req, res, next) {
    var code;
    var err;
    var ctime = req.header('if-modified-since');
    var mtime = res.mtime || res.header('Last-Modified') || '';
    if (!mtime || !ctime) {
      next();
      return;
    }
    try {
      if (Date.parse(mtime) <= Date.parse(ctime)) {
        switch (req.method) {
          case 'GET':
          case 'HEAD':
            code = 304;
            break;
          default:
            err = new PreconditionFailedError(IF_MOD_FAIL, mtime, ctime);
            break;
        }
      }
    } catch (e) {
      next(new BadRequestError(e.message));
      return;
    }
    if (code !== undefined) {
      res.send(code);
      next(false);
      return;
    }
    next(err);
  }
  function checkIfUnmodified(req, res, next) {
    var err;
    var ctime = req.headers['if-unmodified-since'];
    var mtime = res.mtime || res.header('Last-Modified') || '';
    if (!mtime || !ctime) {
      next();
      return;
    }
    try {
      if (Date.parse(mtime) > Date.parse(ctime)) {
        err = new PreconditionFailedError(IF_UNMOD_FAIL, mtime, ctime);
      }
    } catch (e) {
      next(new BadRequestError(e.message));
      return;
    }
    next(err);
  }
  function conditionalRequest() {
    var chain = [checkIfMatch, checkIfNoneMatch, checkIfModified, checkIfUnmodified];
    return (chain);
  }
  module.exports = conditionalRequest;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("10f", ["5a", "69"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('5a');
  var errors = $__require('69');
  var InvalidHeaderError = errors.InvalidHeaderError;
  var RequestExpiredError = errors.RequestExpiredError;
  var BAD_MSG = 'Date header is invalid';
  var OLD_MSG = 'Date header %s is too old';
  function dateParser(clockSkew) {
    var normalizedClockSkew = clockSkew || 300;
    assert.number(normalizedClockSkew, 'normalizedClockSkew');
    normalizedClockSkew = normalizedClockSkew * 1000;
    function parseDate(req, res, next) {
      if (!req.headers.date) {
        return (next());
      }
      var e;
      var date = req.headers.date;
      var log = req.log;
      try {
        var now = Date.now();
        var sent = new Date(date).getTime();
        if (log.trace()) {
          log.trace({
            allowedSkew: normalizedClockSkew,
            now: now,
            sent: sent
          }, 'Checking clock skew');
        }
        if ((now - sent) > normalizedClockSkew) {
          e = new RequestExpiredError(OLD_MSG, date);
          return (next(e));
        }
      } catch (err) {
        log.trace({err: err}, 'Bad Date header: %s', date);
        e = new InvalidHeaderError(BAD_MSG, date);
        return (next(e));
      }
      return (next());
    }
    return (parseDate);
  }
  module.exports = dateParser;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("110", ["111"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var qs = $__require('111');
  function jsonp() {
    function _jsonp(req, res, next) {
      var q = req.getQuery();
      if (typeof(q) === 'string') {
        req.query = qs.parse(q);
      }
      if (req.query.callback || req.query.jsonp) {
        res.setHeader('Content-Type', 'application/javascript');
      }
      next();
    }
    return (_jsonp);
  }
  module.exports = jsonp;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("10c", ["5a", "111", "10a", "69"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('5a');
  var querystring = $__require('111');
  var bodyReader = $__require('10a');
  var errors = $__require('69');
  var MIME_TYPE = 'application/x-www-form-urlencoded';
  function urlEncodedBodyParser(options) {
    var opts = options || {};
    assert.object(opts, 'opts');
    var override = opts.overrideParams;
    function parseUrlEncodedBody(req, res, next) {
      req.rawBody = req._body = req.body;
      if (req.getContentType() !== MIME_TYPE || !req.body) {
        next();
        return;
      }
      try {
        var params = querystring.parse(req.body);
        if (opts.mapParams === true) {
          var keys = Object.keys(params);
          keys.forEach(function(k) {
            var p = req.params[k];
            if (p && !override) {
              return;
            }
            req.params[k] = params[k];
          });
        }
        req.body = params;
      } catch (e) {
        next(new errors.InvalidContentError(e.message));
        return;
      }
      req.log.trace('req.params now: %j', req.params);
      next();
    }
    var chain = [];
    if (!opts.bodyReader) {
      chain.push(bodyReader(opts));
    }
    chain.push(parseUrlEncodedBody);
    return (chain);
  }
  module.exports = urlEncodedBodyParser;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("112", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function shallowCopy(obj) {
    if (!obj) {
      return (obj);
    }
    var copy = {};
    Object.keys(obj).forEach(function(k) {
      copy[k] = obj[k];
    });
    return (copy);
  }
  module.exports = shallowCopy;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("113", ["5a", "112"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('5a');
  var shallowCopy = $__require('112');
  function requestLogger(options) {
    assert.optionalObject(options);
    var opts = options || {};
    var props;
    if (opts.properties) {
      props = shallowCopy(opts.properties);
    } else {
      props = {};
    }
    if (opts.serializers) {
      props.serializers = opts.serializers;
    }
    var headersToCopy = opts.headers || [];
    return function bunyan(req, res, next) {
      if (!req.log && !opts.log) {
        next();
        return;
      }
      var log = req.log || opts.log;
      props.req_id = req.getId();
      headersToCopy.forEach(function(k) {
        if (req.headers[k]) {
          props[k] = req.headers[k];
        }
      });
      req.log = log.child(props, props.serializers ? false : true);
      if (props.req_id) {
        delete props.req_id;
      }
      next();
    };
  }
  module.exports = requestLogger;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("114", ["a0", "5a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var zlib = $__require('a0');
  var assert = $__require('5a');
  function _writeHead(originalFunction) {
    this.removeHeader('Content-Length');
    originalFunction.apply(this, Array.prototype.slice.call(arguments, 1));
  }
  function gzipResponse(opts) {
    assert.optionalObject(opts, 'options');
    function gzip(req, res, next) {
      if (!req.acceptsEncoding('gzip')) {
        next();
        return;
      }
      var gz = zlib.createGzip(opts);
      gz.on('data', res.write.bind(res));
      gz.once('end', res.end.bind(res));
      gz.on('drain', res.emit.bind(res, 'drain'));
      var origWrite = res.write;
      var origEnd = res.end;
      var origWriteHead = res.writeHead;
      res.handledGzip = function _handledGzip() {
        res.write = origWrite;
        res.end = origEnd;
        res.writeHead = origWriteHead;
      };
      res.write = gz.write.bind(gz);
      res.end = gz.end.bind(gz);
      res.writeHead = _writeHead.bind(res, res.writeHead);
      res.setHeader('Content-Encoding', 'gzip');
      next();
    }
    return (gzip);
  }
  module.exports = gzipResponse;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("115", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function httpDate(now) {
    return (now.toUTCString());
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("116", ["cd", "115"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var crypto = $__require('cd');
  var httpDate = $__require('115');
  var ALLOW_HEADERS = ['Accept', 'Accept-Version', 'Content-Length', 'Content-MD5', 'Content-Type', 'Date', 'Api-Version', 'Response-Time'].join(', ');
  var EXPOSE_HEADERS = ['Api-Version', 'Request-Id', 'Response-Time'].join(', ');
  function setHeaders(req, res) {
    var hash;
    var now = new Date();
    var methods;
    if (!res.getHeader('Access-Control-Allow-Origin')) {
      res.setHeader('Access-Control-Allow-Origin', '*');
    }
    if (!res.getHeader('Access-Control-Allow-Headers')) {
      res.setHeader('Access-Control-Allow-Headers', ALLOW_HEADERS);
    }
    if (!res.getHeader('Access-Control-Allow-Methods')) {
      if (res.methods && res.methods.length > 0) {
        methods = res.methods.join(', ');
        res.setHeader('Access-Control-Allow-Methods', methods);
      }
    }
    if (!res.getHeader('Access-Control-Expose-Headers')) {
      res.setHeader('Access-Control-Expose-Headers', EXPOSE_HEADERS);
    }
    if (!res.getHeader('Connection')) {
      res.setHeader('Connection', req.isKeepAlive() ? 'Keep-Alive' : 'close');
    }
    if (res._data && !res.getHeader('Content-MD5')) {
      hash = crypto.createHash('md5');
      hash.update(res._data);
      res.setHeader('Content-MD5', hash.digest('base64'));
    }
    if (!res.getHeader('Date')) {
      res.setHeader('Date', httpDate(now));
    }
    if (res.etag && !res.getHeader('Etag')) {
      res.setHeader('Etag', res.etag);
    }
    if (!res.getHeader('Server')) {
      res.setHeader('Server', res.serverName);
    }
    if (res.version && !res.getHeader('Api-Version')) {
      res.setHeader('Api-Version', res.version);
    }
    if (!res.getHeader('Request-Id')) {
      res.setHeader('Request-Id', req.getId());
    }
    if (!res.getHeader('Response-Time')) {
      res.setHeader('Response-Time', now.getTime() - req._time);
    }
  }
  function fullResponse() {
    function restifyResponseHeaders(req, res, next) {
      res.once('header', function() {
        if (res.defaultResponseFormatters) {
          res.defaultResponseFormatters(res._data);
        }
        res.emit('beforeSend', res._data, res._body);
        return (setHeaders(req, res));
      });
      return (next());
    }
    return (restifyResponseHeaders);
  }
  module.exports = fullResponse;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ba", ["118", "117", "72", "1a", "b8", "ad", "@empty", "bc", "119", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    'use strict';
    module.exports = Readable;
    var processNextTick = $__require('118');
    var isArray = $__require('117');
    var Buffer = $__require('72').Buffer;
    Readable.ReadableState = ReadableState;
    var EE = $__require('1a');
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream;
    (function() {
      try {
        Stream = $__require('st' + 'ream');
      } catch (_) {} finally {
        if (!Stream)
          Stream = $__require('1a').EventEmitter;
      }
    })();
    var Buffer = $__require('72').Buffer;
    var util = $__require('b8');
    util.inherits = $__require('ad');
    var debugUtil = $__require('@empty');
    var debug = undefined;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog('stream');
    } else {
      debug = function() {};
    }
    var StringDecoder;
    util.inherits(Readable, Stream);
    var Duplex;
    function ReadableState(options, stream) {
      Duplex = Duplex || $__require('bc');
      options = options || {};
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = $__require('119').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    var Duplex;
    function Readable(options) {
      Duplex = Duplex || $__require('bc');
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options && typeof options.read === 'function')
        this._read = options.read;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          var skipAdd;
          if (state.decoder && !addToFront && !encoding) {
            chunk = state.decoder.write(chunk);
            skipAdd = !state.objectMode && chunk.length === 0;
          }
          if (!addToFront)
            state.reading = false;
          if (!skipAdd) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk);
              stream.read(0);
            } else {
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront)
                state.buffer.unshift(chunk);
              else
                state.buffer.push(chunk);
              if (state.needReadable)
                emitReadable(stream);
            }
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = $__require('119').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 0x800000;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (n === null || isNaN(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else {
          return state.length;
        }
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      debug('read', n);
      var state = this._readableState;
      var nOrig = n;
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug('need readable', doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      }
      if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
      if (ret !== null)
        this.emit('data', ret);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          processNextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        processNextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        processNextTick(endFn);
      else
        src.once('end', endFn);
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug('onend');
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug('cleanup');
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        if (false === ret) {
          if (state.pipesCount === 1 && state.pipes[0] === dest && src.listenerCount('data') === 1 && !cleanedUp) {
            debug('false write response, pause', src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EElistenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
      dest.emit('pipe', src);
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit('unpipe', this);
        }
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit('unpipe', this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === 'data' && false !== this._readableState.flowing) {
        this.resume();
      }
      if (ev === 'readable' && !this._readableState.endEmitted) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            processNextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self) {
      debug('readable nexttick read 0');
      self.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        processNextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug('resume read 0');
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
        self.push(null);
      });
      stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
      self._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join('');
        else if (list.length === 1)
          ret = list[0];
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
          var c = 0;
          for (var i = 0,
              l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        processNextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    }
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11a", ["9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
      module.exports = nextTick;
    } else {
      module.exports = process.nextTick;
    }
    function nextTick(fn) {
      var args = new Array(arguments.length - 1);
      var i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("118", ["11a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('11a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11b", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = deprecate;
  function deprecate(fn, msg) {
    if (config('noDeprecation')) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config('throwDeprecation')) {
          throw new Error(msg);
        } else if (config('traceDeprecation')) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function config(name) {
    try {
      if (!global.localStorage)
        return false;
    } catch (_) {
      return false;
    }
    var val = global.localStorage[name];
    if (null == val)
      return false;
    return String(val).toLowerCase() === 'true';
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11c", ["11b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('11b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bb", ["118", "72", "b8", "ad", "11c", "1a", "bc", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    'use strict';
    module.exports = Writable;
    var processNextTick = $__require('118');
    var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
    var Buffer = $__require('72').Buffer;
    Writable.WritableState = WritableState;
    var util = $__require('b8');
    util.inherits = $__require('ad');
    var internalUtil = {deprecate: $__require('11c')};
    var Stream;
    (function() {
      try {
        Stream = $__require('st' + 'ream');
      } catch (_) {} finally {
        if (!Stream)
          Stream = $__require('1a').EventEmitter;
      }
    })();
    var Buffer = $__require('72').Buffer;
    util.inherits(Writable, Stream);
    function nop() {}
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }
    var Duplex;
    function WritableState(options, stream) {
      Duplex = Duplex || $__require('bc');
      options = options || {};
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
      this.corkedRequestsFree.next = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, 'buffer', {get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')});
      } catch (_) {}
    })();
    var Duplex;
    function Writable(options) {
      Duplex = Duplex || $__require('bc');
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === 'function')
          this._write = options.write;
        if (typeof options.writev === 'function')
          this._writev = options.writev;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error('write after end');
      stream.emit('error', er);
      processNextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        processNextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== 'function')
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === 'string')
        encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1))
        throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync)
        processNextTick(cb, er);
      else
        cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        while (entry) {
          buffer[count] = entry;
          entry = entry.next;
          count += 1;
        }
        doWrite(stream, state, true, state.length, buffer, '', holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequestCount = 0;
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== undefined)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish(stream, state);
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          processNextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function(err) {
        var entry = _this.entry;
        _this.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        if (state.corkedRequestsFree) {
          state.corkedRequestsFree.next = _this;
        } else {
          state.corkedRequestsFree = _this;
        }
      };
    }
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bc", ["118", "b8", "ad", "ba", "bb", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj) {
        keys.push(key);
      }
      return keys;
    };
    module.exports = Duplex;
    var processNextTick = $__require('118');
    var util = $__require('b8');
    util.inherits = $__require('ad');
    var Readable = $__require('ba');
    var Writable = $__require('bb');
    util.inherits(Duplex, Readable);
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once('end', onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      processNextTick(onEndNT, this);
    }
    function onEndNT(self) {
      self.end();
    }
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b7", ["bc", "b8", "ad", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    module.exports = Transform;
    var Duplex = $__require('bc');
    var util = $__require('b8');
    util.inherits = $__require('ad');
    util.inherits(Transform, Duplex);
    function TransformState(stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
      this.writeencoding = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== undefined)
        stream.push(data);
      cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === 'function')
          this._transform = options.transform;
        if (typeof options.flush === 'function')
          this._flush = options.flush;
      }
      this.once('prefinish', function() {
        if (typeof this._flush === 'function')
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
      return stream.push(null);
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11d", ["b7"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('b7');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11e", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = '';
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  module.exports = ZStream;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11f", ["120", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var utils = $__require('120');
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    var StaticTreeDesc = function(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    };
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    var TreeDesc = function(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    };
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = (w) & 0xff;
      s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > (Buf_size - length)) {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> (Buf_size - s.bi_valid);
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n,
          m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1 << extra_lbits[code]); n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1 << extra_dbits[code]); n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return (tree[_n2] < tree[_m2] || (tree[_n2] === tree[_m2] && depth[n] <= depth[m]));
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n,
          m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = (s.heap_len >> 1); n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 0xffff;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 0xf3ffc07f;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if ((black_mask & 1) && (s.dyn_ltree[n * 2] !== 0)) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb,
          static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = (s.opt_len + 3 + 7) >>> 3;
        static_lenb = (s.static_len + 3 + 7) >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return (s.last_lit === s.lit_bufsize - 1);
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("121", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    '2': 'need dictionary',
    '1': 'stream end',
    '0': '',
    '-1': 'file error',
    '-2': 'stream error',
    '-3': 'data error',
    '-4': 'insufficient memory',
    '-5': 'buffer error',
    '-6': 'incompatible version'
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("122", ["120", "11f", "123", "124", "121", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var utils = $__require('120');
    var trees = $__require('11f');
    var adler32 = $__require('123');
    var crc32 = $__require('124');
    var msg = $__require('121');
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
    var PRESET_DICT = 0x20;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 0x03;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return ((f) << 1) - ((f) > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
      s.pending_buf[s.pending++] = b & 0xff;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p,
          n,
          m,
          more,
          str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = (m >= _w_size ? m - _w_size : 0);
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = (m >= _w_size ? m - _w_size : 0);
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 0xffff;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan,
          strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    var Config = function(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    };
    var configuration_table;
    configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
      strm.adler = (s.wrap === 2) ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << (memLevel + 6);
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = s.lit_bufsize >> 1;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush,
          s;
      var beg,
          val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || (!strm.input && strm.avail_in !== 0) || (s.status === FINISH_STATE && flush !== Z_FINISH)) {
        return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0));
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 0xff);
            put_byte(s, (s.gzhead.time >> 8) & 0xff);
            put_byte(s, (s.gzhead.time >> 16) & 0xff);
            put_byte(s, (s.gzhead.time >> 24) & 0xff);
            put_byte(s, s.level === 9 ? 2 : (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0));
            put_byte(s, s.gzhead.os & 0xff);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 0xff);
              put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= (level_flags << 6);
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - (header % 31);
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, (strm.adler >> 8) & 0xff);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
        var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) : (s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush));
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        put_byte(s, (strm.adler >> 16) & 0xff);
        put_byte(s, (strm.adler >> 24) & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, (strm.total_in >> 8) & 0xff);
        put_byte(s, (strm.total_in >> 16) & 0xff);
        put_byte(s, (strm.total_in >> 24) & 0xff);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateInfo = 'pako deflate (from Nodeca project)';
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("123", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function adler32(adler, buf, len, pos) {
    var s1 = (adler & 0xffff) | 0,
        s2 = ((adler >>> 16) & 0xffff) | 0,
        n = 0;
    while (len !== 0) {
      n = len > 2000 ? 2000 : len;
      len -= n;
      do {
        s1 = (s1 + buf[pos++]) | 0;
        s2 = (s2 + s1) | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return (s1 | (s2 << 16)) | 0;
  }
  module.exports = adler32;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("124", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function makeTable() {
    var c,
        table = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
      }
      table[n] = c;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable,
        end = pos + len;
    crc = crc ^ (-1);
    for (var i = pos; i < end; i++) {
      crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }
    return (crc ^ (-1));
  }
  module.exports = crc32;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("125", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var BAD = 30;
  var TYPE = 12;
  module.exports = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input,
        output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top: do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen: for (; ; ) {
        op = here >>> 24;
        hold >>>= op;
        bits -= op;
        op = (here >>> 16) & 0xff;
        if (op === 0) {
          output[_out++] = here & 0xffff;
        } else if (op & 16) {
          len = here & 0xffff;
          op &= 15;
          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }
            len += hold & ((1 << op) - 1);
            hold >>>= op;
            bits -= op;
          }
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = dcode[hold & dmask];
          dodist: for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = (here >>> 16) & 0xff;
            if (op & 16) {
              dist = here & 0xffff;
              op &= 15;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }
              dist += hold & ((1 << op) - 1);
              if (dist > dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break top;
              }
              hold >>>= op;
              bits -= op;
              op = _out - beg;
              if (dist > op) {
                op = dist - op;
                if (op > whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break top;
                  }
                }
                from = 0;
                from_source = s_window;
                if (wnext === 0) {
                  from += wsize - op;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;
                    from_source = output;
                  }
                } else if (wnext < op) {
                  from += wsize + wnext - op;
                  op -= wnext;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = 0;
                    if (wnext < len) {
                      op = wnext;
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;
                      from_source = output;
                    }
                  }
                } else {
                  from += wnext - op;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;
                    from_source = output;
                  }
                }
                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }
                if (len) {
                  output[_out++] = from_source[from++];
                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              } else {
                from = _out - dist;
                do {
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);
                if (len) {
                  output[_out++] = output[from++];
                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            } else if ((op & 64) === 0) {
              here = dcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
              continue dodist;
            } else {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break top;
            }
            break;
          }
        } else if ((op & 64) === 0) {
          here = lcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
          continue dolen;
        } else if (op & 32) {
          state.mode = TYPE;
          break top;
        } else {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break top;
        }
        break;
      }
    } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
    strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
    state.hold = hold;
    state.bits = bits;
    return;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("120", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var TYPED_OK = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Int32Array !== 'undefined');
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== 'object') {
        throw new TypeError(source + 'must be non-object');
      }
      for (var p in source) {
        if (source.hasOwnProperty(p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      var i,
          l,
          len,
          pos,
          chunk,
          result;
      len = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("126", ["120", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var utils = $__require('120');
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
    var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
    var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
    var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0,
          max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits,
          here_op,
          here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = (1 << 24) | (64 << 16) | 0;
        table[table_index++] = (1 << 24) | (64 << 16) | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }
      var i = 0;
      for (; ; ) {
        i++;
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << (len - drop);
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;
        } while (fill !== 0);
        incr = 1 << (len - 1);
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {
            return 1;
          }
          low = huff & mask;
          table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;
      }
      opts.bits = root;
      return 0;
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("127", ["120", "123", "124", "125", "126", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var utils = $__require('120');
    var adler32 = $__require('123');
    var crc32 = $__require('124');
    var inflate_fast = $__require('125');
    var inflate_table = $__require('126');
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function ZSWAP32(q) {
      return (((q >>> 24) & 0xff) + ((q >>> 8) & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24));
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = '';
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix,
        distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {bits: 9});
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {bits: 5});
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input,
          output;
      var next;
      var put;
      var have,
          left;
      var hold;
      var bits;
      var _in,
          _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits,
          here_op,
          here_val;
      var last_bits,
          last_op,
          last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!strm || !strm.state || !strm.output || (!strm.input && strm.avail_in !== 0)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave: for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((state.wrap & 2) && hold === 0x8b1f) {
              state.check = 0;
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
              strm.msg = 'incorrect header check';
              state.mode = BAD;
              break;
            }
            if ((hold & 0x0f) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 0x0f) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = 'invalid window size';
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 0x200 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 0xff) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            if (state.flags & 0xe000) {
              strm.msg = 'unknown header flags set';
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = ((hold >> 8) & 1);
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              hbuf[2] = (hold >>> 16) & 0xff;
              hbuf[3] = (hold >>> 24) & 0xff;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = (hold & 0xff);
              state.head.os = (hold >> 8);
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 0x0400) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 0x0200) {
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 0x0400) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(state.head.extra, input, next, copy, len);
                }
                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 0x0800) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && (state.length < 65536)) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 0x1000) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && (state.length < 65536)) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 0x0200) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 0xffff)) {
                strm.msg = 'header crc mismatch';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = ((state.flags >> 9) & 1);
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = ZSWAP32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = (hold & 0x01);
            hold >>>= 1;
            bits -= 1;
            switch ((hold & 0x03)) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = 'invalid block type';
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
              strm.msg = 'invalid stored block lengths';
              state.mode = BAD;
              break;
            }
            state.length = hold & 0xffff;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 0x1f) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 0x1f) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 0x0f) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = 'too many length or distance symbols';
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = (hold & 0x07);
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid code lengths set';
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & ((1 << state.lenbits) - 1)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;
                if ((here_bits) <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = 'invalid bit length repeat';
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 0x03);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 0x07);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 0x7f);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = 'invalid code -- missing end-of-block';
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid literal/lengths set';
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid distances set';
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & ((1 << state.lenbits) - 1)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;
                if ((last_bits + here_bits) <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = 'invalid literal/length code';
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & ((1 << state.extra) - 1);
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & ((1 << state.distbits) - 1)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;
              if ((here_bits) <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;
                if ((last_bits + here_bits) <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = (here_op) & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & ((1 << state.extra) - 1);
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
              }
              _out = left;
              if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
                strm.msg = 'incorrect data check';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 0xffffffff)) {
                strm.msg = 'incorrect length check';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || (_out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH))) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateInfo = 'pako inflate (from Nodeca project)';
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("128", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("129", ["121", "11e", "122", "127", "128", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var msg = $__require('121');
    var zstream = $__require('11e');
    var zlib_deflate = $__require('122');
    var zlib_inflate = $__require('127');
    var constants = $__require('128');
    for (var key in constants) {
      exports[key] = constants[key];
    }
    exports.NONE = 0;
    exports.DEFLATE = 1;
    exports.INFLATE = 2;
    exports.GZIP = 3;
    exports.GUNZIP = 4;
    exports.DEFLATERAW = 5;
    exports.INFLATERAW = 6;
    exports.UNZIP = 7;
    function Zlib(mode) {
      if (mode < exports.DEFLATE || mode > exports.UNZIP)
        throw new TypeError("Bad argument");
      this.mode = mode;
      this.init_done = false;
      this.write_in_progress = false;
      this.pending_close = false;
      this.windowBits = 0;
      this.level = 0;
      this.memLevel = 0;
      this.strategy = 0;
      this.dictionary = null;
    }
    Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
      this.windowBits = windowBits;
      this.level = level;
      this.memLevel = memLevel;
      this.strategy = strategy;
      if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)
        this.windowBits += 16;
      if (this.mode === exports.UNZIP)
        this.windowBits += 32;
      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
        this.windowBits = -this.windowBits;
      this.strm = new zstream();
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          var status = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
        case exports.UNZIP:
          var status = zlib_inflate.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (status !== exports.Z_OK) {
        this._error(status);
        return;
      }
      this.write_in_progress = false;
      this.init_done = true;
    };
    Zlib.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype._writeCheck = function() {
      if (!this.init_done)
        throw new Error("write before init");
      if (this.mode === exports.NONE)
        throw new Error("already finalized");
      if (this.write_in_progress)
        throw new Error("write already in progress");
      if (this.pending_close)
        throw new Error("close is pending");
    };
    Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      this._writeCheck();
      this.write_in_progress = true;
      var self = this;
      process.nextTick(function() {
        self.write_in_progress = false;
        var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
        self.callback(res[0], res[1]);
        if (self.pending_close)
          self.close();
      });
      return this;
    };
    function bufferSet(data, offset) {
      for (var i = 0; i < data.length; i++) {
        this[offset + i] = data[i];
      }
    }
    Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
      this._writeCheck();
      return this._write(flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      this.write_in_progress = true;
      if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
        throw new Error("Invalid flush value");
      }
      if (input == null) {
        input = new Buffer(0);
        in_len = 0;
        in_off = 0;
      }
      if (out._set)
        out.set = out._set;
      else
        out.set = bufferSet;
      var strm = this.strm;
      strm.avail_in = in_len;
      strm.input = input;
      strm.next_in = in_off;
      strm.avail_out = out_len;
      strm.output = out;
      strm.next_out = out_off;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          var status = zlib_deflate.deflate(strm, flush);
          break;
        case exports.UNZIP:
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
          var status = zlib_inflate.inflate(strm, flush);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
        this._error(status);
      }
      this.write_in_progress = false;
      return [strm.avail_in, strm.avail_out];
    };
    Zlib.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false;
      if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
        zlib_deflate.deflateEnd(this.strm);
      } else {
        zlib_inflate.inflateEnd(this.strm);
      }
      this.mode = exports.NONE;
    };
    Zlib.prototype.reset = function() {
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
          var status = zlib_deflate.deflateReset(this.strm);
          break;
        case exports.INFLATE:
        case exports.INFLATERAW:
          var status = zlib_inflate.inflateReset(this.strm);
          break;
      }
      if (status !== exports.Z_OK) {
        this._error(status);
      }
    };
    Zlib.prototype._error = function(status) {
      this.onerror(msg[status] + ': ' + this.strm.msg, status);
      this.write_in_progress = false;
      if (this.pending_close)
        this.close();
    };
    exports.Zlib = Zlib;
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12a", ["11d", "129", "59", "71", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var Transform = $__require('11d');
    var binding = $__require('129');
    var util = $__require('59');
    var assert = $__require('71').ok;
    binding.Z_MIN_WINDOWBITS = 8;
    binding.Z_MAX_WINDOWBITS = 15;
    binding.Z_DEFAULT_WINDOWBITS = 15;
    binding.Z_MIN_CHUNK = 64;
    binding.Z_MAX_CHUNK = Infinity;
    binding.Z_DEFAULT_CHUNK = (16 * 1024);
    binding.Z_MIN_MEMLEVEL = 1;
    binding.Z_MAX_MEMLEVEL = 9;
    binding.Z_DEFAULT_MEMLEVEL = 8;
    binding.Z_MIN_LEVEL = -1;
    binding.Z_MAX_LEVEL = 9;
    binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
    Object.keys(binding).forEach(function(k) {
      if (k.match(/^Z/))
        exports[k] = binding[k];
    });
    exports.codes = {
      Z_OK: binding.Z_OK,
      Z_STREAM_END: binding.Z_STREAM_END,
      Z_NEED_DICT: binding.Z_NEED_DICT,
      Z_ERRNO: binding.Z_ERRNO,
      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
      Z_DATA_ERROR: binding.Z_DATA_ERROR,
      Z_MEM_ERROR: binding.Z_MEM_ERROR,
      Z_BUF_ERROR: binding.Z_BUF_ERROR,
      Z_VERSION_ERROR: binding.Z_VERSION_ERROR
    };
    Object.keys(exports.codes).forEach(function(k) {
      exports.codes[exports.codes[k]] = k;
    });
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    exports.createDeflate = function(o) {
      return new Deflate(o);
    };
    exports.createInflate = function(o) {
      return new Inflate(o);
    };
    exports.createDeflateRaw = function(o) {
      return new DeflateRaw(o);
    };
    exports.createInflateRaw = function(o) {
      return new InflateRaw(o);
    };
    exports.createGzip = function(o) {
      return new Gzip(o);
    };
    exports.createGunzip = function(o) {
      return new Gunzip(o);
    };
    exports.createUnzip = function(o) {
      return new Unzip(o);
    };
    exports.deflate = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Deflate(opts), buffer, callback);
    };
    exports.deflateSync = function(buffer, opts) {
      return zlibBufferSync(new Deflate(opts), buffer);
    };
    exports.gzip = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gzip(opts), buffer, callback);
    };
    exports.gzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gzip(opts), buffer);
    };
    exports.deflateRaw = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new DeflateRaw(opts), buffer, callback);
    };
    exports.deflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new DeflateRaw(opts), buffer);
    };
    exports.unzip = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Unzip(opts), buffer, callback);
    };
    exports.unzipSync = function(buffer, opts) {
      return zlibBufferSync(new Unzip(opts), buffer);
    };
    exports.inflate = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Inflate(opts), buffer, callback);
    };
    exports.inflateSync = function(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    };
    exports.gunzip = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gunzip(opts), buffer, callback);
    };
    exports.gunzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gunzip(opts), buffer);
    };
    exports.inflateRaw = function(buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new InflateRaw(opts), buffer, callback);
    };
    exports.inflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new InflateRaw(opts), buffer);
    };
    function zlibBuffer(engine, buffer, callback) {
      var buffers = [];
      var nread = 0;
      engine.on('error', onError);
      engine.on('end', onEnd);
      engine.end(buffer);
      flow();
      function flow() {
        var chunk;
        while (null !== (chunk = engine.read())) {
          buffers.push(chunk);
          nread += chunk.length;
        }
        engine.once('readable', flow);
      }
      function onError(err) {
        engine.removeListener('end', onEnd);
        engine.removeListener('readable', flow);
        callback(err);
      }
      function onEnd() {
        var buf = Buffer.concat(buffers, nread);
        buffers = [];
        callback(null, buf);
        engine.close();
      }
    }
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === 'string')
        buffer = new Buffer(buffer);
      if (!Buffer.isBuffer(buffer))
        throw new TypeError('Not a string or buffer');
      var flushFlag = binding.Z_FINISH;
      return engine._processChunk(buffer, flushFlag);
    }
    function Deflate(opts) {
      if (!(this instanceof Deflate))
        return new Deflate(opts);
      Zlib.call(this, opts, binding.DEFLATE);
    }
    function Inflate(opts) {
      if (!(this instanceof Inflate))
        return new Inflate(opts);
      Zlib.call(this, opts, binding.INFLATE);
    }
    function Gzip(opts) {
      if (!(this instanceof Gzip))
        return new Gzip(opts);
      Zlib.call(this, opts, binding.GZIP);
    }
    function Gunzip(opts) {
      if (!(this instanceof Gunzip))
        return new Gunzip(opts);
      Zlib.call(this, opts, binding.GUNZIP);
    }
    function DeflateRaw(opts) {
      if (!(this instanceof DeflateRaw))
        return new DeflateRaw(opts);
      Zlib.call(this, opts, binding.DEFLATERAW);
    }
    function InflateRaw(opts) {
      if (!(this instanceof InflateRaw))
        return new InflateRaw(opts);
      Zlib.call(this, opts, binding.INFLATERAW);
    }
    function Unzip(opts) {
      if (!(this instanceof Unzip))
        return new Unzip(opts);
      Zlib.call(this, opts, binding.UNZIP);
    }
    function Zlib(opts, mode) {
      this._opts = opts = opts || {};
      this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
      Transform.call(this, opts);
      if (opts.flush) {
        if (opts.flush !== binding.Z_NO_FLUSH && opts.flush !== binding.Z_PARTIAL_FLUSH && opts.flush !== binding.Z_SYNC_FLUSH && opts.flush !== binding.Z_FULL_FLUSH && opts.flush !== binding.Z_FINISH && opts.flush !== binding.Z_BLOCK) {
          throw new Error('Invalid flush flag: ' + opts.flush);
        }
      }
      this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
      if (opts.chunkSize) {
        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
          throw new Error('Invalid chunk size: ' + opts.chunkSize);
        }
      }
      if (opts.windowBits) {
        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
          throw new Error('Invalid windowBits: ' + opts.windowBits);
        }
      }
      if (opts.level) {
        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
          throw new Error('Invalid compression level: ' + opts.level);
        }
      }
      if (opts.memLevel) {
        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
          throw new Error('Invalid memLevel: ' + opts.memLevel);
        }
      }
      if (opts.strategy) {
        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
          throw new Error('Invalid strategy: ' + opts.strategy);
        }
      }
      if (opts.dictionary) {
        if (!Buffer.isBuffer(opts.dictionary)) {
          throw new Error('Invalid dictionary: it should be a Buffer instance');
        }
      }
      this._binding = new binding.Zlib(mode);
      var self = this;
      this._hadError = false;
      this._binding.onerror = function(message, errno) {
        self._binding = null;
        self._hadError = true;
        var error = new Error(message);
        error.errno = errno;
        error.code = exports.codes[errno];
        self.emit('error', error);
      };
      var level = exports.Z_DEFAULT_COMPRESSION;
      if (typeof opts.level === 'number')
        level = opts.level;
      var strategy = exports.Z_DEFAULT_STRATEGY;
      if (typeof opts.strategy === 'number')
        strategy = opts.strategy;
      this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
      this._buffer = new Buffer(this._chunkSize);
      this._offset = 0;
      this._closed = false;
      this._level = level;
      this._strategy = strategy;
      this.once('end', this.close);
    }
    util.inherits(Zlib, Transform);
    Zlib.prototype.params = function(level, strategy, callback) {
      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
        throw new RangeError('Invalid compression level: ' + level);
      }
      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new TypeError('Invalid strategy: ' + strategy);
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self = this;
        this.flush(binding.Z_SYNC_FLUSH, function() {
          self._binding.params(level, strategy);
          if (!self._hadError) {
            self._level = level;
            self._strategy = strategy;
            if (callback)
              callback();
          }
        });
      } else {
        process.nextTick(callback);
      }
    };
    Zlib.prototype.reset = function() {
      return this._binding.reset();
    };
    Zlib.prototype._flush = function(callback) {
      this._transform(new Buffer(0), '', callback);
    };
    Zlib.prototype.flush = function(kind, callback) {
      var ws = this._writableState;
      if (typeof kind === 'function' || (kind === void 0 && !callback)) {
        callback = kind;
        kind = binding.Z_FULL_FLUSH;
      }
      if (ws.ended) {
        if (callback)
          process.nextTick(callback);
      } else if (ws.ending) {
        if (callback)
          this.once('end', callback);
      } else if (ws.needDrain) {
        var self = this;
        this.once('drain', function() {
          self.flush(callback);
        });
      } else {
        this._flushFlag = kind;
        this.write(new Buffer(0), '', callback);
      }
    };
    Zlib.prototype.close = function(callback) {
      if (callback)
        process.nextTick(callback);
      if (this._closed)
        return;
      this._closed = true;
      this._binding.close();
      var self = this;
      process.nextTick(function() {
        self.emit('close');
      });
    };
    Zlib.prototype._transform = function(chunk, encoding, cb) {
      var flushFlag;
      var ws = this._writableState;
      var ending = ws.ending || ws.ended;
      var last = ending && (!chunk || ws.length === chunk.length);
      if (!chunk === null && !Buffer.isBuffer(chunk))
        return cb(new Error('invalid input'));
      if (last)
        flushFlag = binding.Z_FINISH;
      else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws.length) {
          this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
        }
      }
      var self = this;
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var inOff = 0;
      var self = this;
      var async = typeof cb === 'function';
      if (!async) {
        var buffers = [];
        var nread = 0;
        var error;
        this.on('error', function(er) {
          error = er;
        });
        do {
          var res = this._binding.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        } while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError) {
          throw error;
        }
        var buf = Buffer.concat(buffers, nread);
        this.close();
        return buf;
      }
      var req = this._binding.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
      req.buffer = chunk;
      req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (self._hadError)
          return;
        var have = availOutBefore - availOutAfter;
        assert(have >= 0, 'have should not go down');
        if (have > 0) {
          var out = self._buffer.slice(self._offset, self._offset + have);
          self._offset += have;
          if (async) {
            self.push(out);
          } else {
            buffers.push(out);
            nread += out.length;
          }
        }
        if (availOutAfter === 0 || self._offset >= self._chunkSize) {
          availOutBefore = self._chunkSize;
          self._offset = 0;
          self._buffer = new Buffer(self._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += (availInBefore - availInAfter);
          availInBefore = availInAfter;
          if (!async)
            return true;
          var newReq = self._binding.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
          newReq.callback = callback;
          newReq.buffer = chunk;
          return;
        }
        if (!async)
          return false;
        cb();
      }
    };
    util.inherits(Deflate, Zlib);
    util.inherits(Inflate, Zlib);
    util.inherits(Gzip, Zlib);
    util.inherits(Gunzip, Zlib);
    util.inherits(DeflateRaw, Zlib);
    util.inherits(InflateRaw, Zlib);
    util.inherits(Unzip, Zlib);
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12b", ["12a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('12a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12c", ["12b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('zlib') : $__require('12b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a0", ["12c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('12c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("10a", ["cd", "a0", "5a", "69", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var crypto = $__require('cd');
    var zlib = $__require('a0');
    var assert = $__require('5a');
    var errors = $__require('69');
    var BadDigestError = errors.BadDigestError;
    var RequestEntityTooLargeError = errors.RequestEntityTooLargeError;
    var PayloadTooLargeError = errors.PayloadTooLargeError;
    var MD5_MSG = 'Content-MD5 \'%s\' didn\'t match \'%s\'';
    function createBodyWriter(req) {
      var buffers = [];
      var contentType = req.contentType();
      var isText = false;
      if (!contentType || contentType === 'application/json' || contentType === 'application/x-www-form-urlencoded' || contentType === 'multipart/form-data' || contentType.substr(0, 5) === 'text/') {
        isText = true;
      }
      req.body = new Buffer(0);
      return {
        write: function(chunk) {
          buffers.push(chunk);
        },
        end: function() {
          req.body = Buffer.concat(buffers);
          if (isText) {
            req.body = req.body.toString('utf8');
          }
        }
      };
    }
    function bodyReader(options) {
      var opts = options || {};
      assert.object(opts, 'opts');
      var maxBodySize = opts.maxBodySize || 0;
      function readBody(req, res, next) {
        if ((req.getContentLength() === 0 && !req.isChunked()) || req.contentType() === 'multipart/form-data' || req.contentType() === 'application/octet-stream') {
          next();
          return;
        }
        var bodyWriter = createBodyWriter(req);
        var bytesReceived = 0;
        var digest;
        var gz;
        var hash;
        var md5;
        if ((md5 = req.headers['content-md5'])) {
          hash = crypto.createHash('md5');
        }
        function done() {
          bodyWriter.end();
          if (maxBodySize && bytesReceived > maxBodySize) {
            var msg = 'Request body size exceeds ' + maxBodySize;
            var err;
            if (PayloadTooLargeError !== undefined) {
              err = new PayloadTooLargeError(msg);
            } else {
              err = new RequestEntityTooLargeError(msg);
            }
            next(err);
            return;
          }
          if (!req.body.length) {
            next();
            return;
          }
          if (hash && md5 !== (digest = hash.digest('base64'))) {
            next(new BadDigestError(MD5_MSG, md5, digest));
            return;
          }
          next();
        }
        if (req.headers['content-encoding'] === 'gzip') {
          gz = zlib.createGunzip();
          gz.on('data', bodyWriter.write);
          gz.once('end', done);
          req.once('end', gz.end.bind(gz));
        } else {
          req.once('end', done);
        }
        req.on('data', function onRequestData(chunk) {
          if (maxBodySize) {
            bytesReceived += chunk.length;
            if (bytesReceived > maxBodySize) {
              return;
            }
          }
          if (hash) {
            hash.update(chunk, 'binary');
          }
          if (gz) {
            gz.write(chunk);
          } else {
            bodyWriter.write(chunk);
          }
        });
        req.once('error', next);
        req.resume();
      }
      return (readBody);
    }
    module.exports = bodyReader;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("10b", ["5a", "69", "10a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('5a');
  var errors = $__require('69');
  var bodyReader = $__require('10a');
  function jsonBodyParser(options) {
    assert.optionalObject(options, 'options');
    var opts = options || {};
    var override = opts.overrideParams;
    function parseJson(req, res, next) {
      req.rawBody = req._body = req.body;
      if (req.getContentType() !== 'application/json' || !req.body) {
        return next();
      }
      var params;
      try {
        params = JSON.parse(req.body, opts.reviver);
      } catch (e) {
        return next(new errors.InvalidContentError('Invalid JSON: ' + e.message));
      }
      if (opts.mapParams === true) {
        if (Array.isArray(params)) {
          if (req.params && Object.keys(req.params).length > 0 && !(req.params instanceof Array)) {
            return next(new errors.InternalServerError('Cannot map POST body of [Array array] onto req.params'));
          }
          req.params = params;
        } else if (typeof(params) === 'object' && params !== null) {
          Object.keys(params).forEach(function(k) {
            var p = req.params[k];
            if (p && !override) {
              return;
            }
            req.params[k] = params[k];
          });
        } else {
          req.params = params || req.params;
        }
      }
      req.body = params;
      return next();
    }
    var chain = [];
    if (!opts.bodyReader) {
      chain.push(bodyReader(opts));
    }
    chain.push(parseJson);
    return chain;
  }
  module.exports = jsonBodyParser;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12d", ["59", "e1", "1a", "cd"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if (global.GENTLY)
    $__require = GENTLY.hijack($__require);
  var util = $__require('59'),
      WriteStream = $__require('e1').WriteStream,
      EventEmitter = $__require('1a').EventEmitter,
      crypto = $__require('cd');
  function File(properties) {
    EventEmitter.call(this);
    this.size = 0;
    this.path = null;
    this.name = null;
    this.type = null;
    this.hash = null;
    this.lastModifiedDate = null;
    this._writeStream = null;
    for (var key in properties) {
      this[key] = properties[key];
    }
    if (typeof this.hash === 'string') {
      this.hash = crypto.createHash(properties.hash);
    } else {
      this.hash = null;
    }
  }
  module.exports = File;
  util.inherits(File, EventEmitter);
  File.prototype.open = function() {
    this._writeStream = new WriteStream(this.path);
  };
  File.prototype.toJSON = function() {
    return {
      size: this.size,
      path: this.path,
      name: this.name,
      type: this.type,
      mtime: this.lastModifiedDate,
      length: this.length,
      filename: this.filename,
      mime: this.mime
    };
  };
  File.prototype.write = function(buffer, cb) {
    var self = this;
    if (self.hash) {
      self.hash.update(buffer);
    }
    this._writeStream.write(buffer, function() {
      self.lastModifiedDate = new Date();
      self.size += buffer.length;
      self.emit('progress', self.size);
      cb();
    });
  };
  File.prototype.end = function(cb) {
    var self = this;
    if (self.hash) {
      self.hash = self.hash.digest('hex');
    }
    this._writeStream.end(function() {
      self.emit('end');
      cb();
    });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12e", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var Buffer = $__require('72').Buffer,
        s = 0,
        S = {
          PARSER_UNINITIALIZED: s++,
          START: s++,
          START_BOUNDARY: s++,
          HEADER_FIELD_START: s++,
          HEADER_FIELD: s++,
          HEADER_VALUE_START: s++,
          HEADER_VALUE: s++,
          HEADER_VALUE_ALMOST_DONE: s++,
          HEADERS_ALMOST_DONE: s++,
          PART_DATA_START: s++,
          PART_DATA: s++,
          PART_END: s++,
          END: s++
        },
        f = 1,
        F = {
          PART_BOUNDARY: f,
          LAST_BOUNDARY: f *= 2
        },
        LF = 10,
        CR = 13,
        SPACE = 32,
        HYPHEN = 45,
        COLON = 58,
        A = 97,
        Z = 122,
        lower = function(c) {
          return c | 0x20;
        };
    for (s in S) {
      exports[s] = S[s];
    }
    function MultipartParser() {
      this.boundary = null;
      this.boundaryChars = null;
      this.lookbehind = null;
      this.state = S.PARSER_UNINITIALIZED;
      this.index = null;
      this.flags = 0;
    }
    exports.MultipartParser = MultipartParser;
    MultipartParser.stateToString = function(stateNumber) {
      for (var state in S) {
        var number = S[state];
        if (number === stateNumber)
          return state;
      }
    };
    MultipartParser.prototype.initWithBoundary = function(str) {
      this.boundary = new Buffer(str.length + 4);
      this.boundary.write('\r\n--', 0);
      this.boundary.write(str, 4);
      this.lookbehind = new Buffer(this.boundary.length + 8);
      this.state = S.START;
      this.boundaryChars = {};
      for (var i = 0; i < this.boundary.length; i++) {
        this.boundaryChars[this.boundary[i]] = true;
      }
    };
    MultipartParser.prototype.write = function(buffer) {
      var self = this,
          i = 0,
          len = buffer.length,
          prevIndex = this.index,
          index = this.index,
          state = this.state,
          flags = this.flags,
          lookbehind = this.lookbehind,
          boundary = this.boundary,
          boundaryChars = this.boundaryChars,
          boundaryLength = this.boundary.length,
          boundaryEnd = boundaryLength - 1,
          bufferLength = buffer.length,
          c,
          cl,
          mark = function(name) {
            self[name + 'Mark'] = i;
          },
          clear = function(name) {
            delete self[name + 'Mark'];
          },
          callback = function(name, buffer, start, end) {
            if (start !== undefined && start === end) {
              return;
            }
            var callbackSymbol = 'on' + name.substr(0, 1).toUpperCase() + name.substr(1);
            if (callbackSymbol in self) {
              self[callbackSymbol](buffer, start, end);
            }
          },
          dataCallback = function(name, clear) {
            var markSymbol = name + 'Mark';
            if (!(markSymbol in self)) {
              return;
            }
            if (!clear) {
              callback(name, buffer, self[markSymbol], buffer.length);
              self[markSymbol] = 0;
            } else {
              callback(name, buffer, self[markSymbol], i);
              delete self[markSymbol];
            }
          };
      for (i = 0; i < len; i++) {
        c = buffer[i];
        switch (state) {
          case S.PARSER_UNINITIALIZED:
            return i;
          case S.START:
            index = 0;
            state = S.START_BOUNDARY;
          case S.START_BOUNDARY:
            if (index == boundary.length - 2) {
              if (c == HYPHEN) {
                flags |= F.LAST_BOUNDARY;
              } else if (c != CR) {
                return i;
              }
              index++;
              break;
            } else if (index - 1 == boundary.length - 2) {
              if (flags & F.LAST_BOUNDARY && c == HYPHEN) {
                callback('end');
                state = S.END;
                flags = 0;
              } else if (!(flags & F.LAST_BOUNDARY) && c == LF) {
                index = 0;
                callback('partBegin');
                state = S.HEADER_FIELD_START;
              } else {
                return i;
              }
              break;
            }
            if (c != boundary[index + 2]) {
              index = -2;
            }
            if (c == boundary[index + 2]) {
              index++;
            }
            break;
          case S.HEADER_FIELD_START:
            state = S.HEADER_FIELD;
            mark('headerField');
            index = 0;
          case S.HEADER_FIELD:
            if (c == CR) {
              clear('headerField');
              state = S.HEADERS_ALMOST_DONE;
              break;
            }
            index++;
            if (c == HYPHEN) {
              break;
            }
            if (c == COLON) {
              if (index == 1) {
                return i;
              }
              dataCallback('headerField', true);
              state = S.HEADER_VALUE_START;
              break;
            }
            cl = lower(c);
            if (cl < A || cl > Z) {
              return i;
            }
            break;
          case S.HEADER_VALUE_START:
            if (c == SPACE) {
              break;
            }
            mark('headerValue');
            state = S.HEADER_VALUE;
          case S.HEADER_VALUE:
            if (c == CR) {
              dataCallback('headerValue', true);
              callback('headerEnd');
              state = S.HEADER_VALUE_ALMOST_DONE;
            }
            break;
          case S.HEADER_VALUE_ALMOST_DONE:
            if (c != LF) {
              return i;
            }
            state = S.HEADER_FIELD_START;
            break;
          case S.HEADERS_ALMOST_DONE:
            if (c != LF) {
              return i;
            }
            callback('headersEnd');
            state = S.PART_DATA_START;
            break;
          case S.PART_DATA_START:
            state = S.PART_DATA;
            mark('partData');
          case S.PART_DATA:
            prevIndex = index;
            if (index === 0) {
              i += boundaryEnd;
              while (i < bufferLength && !(buffer[i] in boundaryChars)) {
                i += boundaryLength;
              }
              i -= boundaryEnd;
              c = buffer[i];
            }
            if (index < boundary.length) {
              if (boundary[index] == c) {
                if (index === 0) {
                  dataCallback('partData', true);
                }
                index++;
              } else {
                index = 0;
              }
            } else if (index == boundary.length) {
              index++;
              if (c == CR) {
                flags |= F.PART_BOUNDARY;
              } else if (c == HYPHEN) {
                flags |= F.LAST_BOUNDARY;
              } else {
                index = 0;
              }
            } else if (index - 1 == boundary.length) {
              if (flags & F.PART_BOUNDARY) {
                index = 0;
                if (c == LF) {
                  flags &= ~F.PART_BOUNDARY;
                  callback('partEnd');
                  callback('partBegin');
                  state = S.HEADER_FIELD_START;
                  break;
                }
              } else if (flags & F.LAST_BOUNDARY) {
                if (c == HYPHEN) {
                  callback('partEnd');
                  callback('end');
                  state = S.END;
                  flags = 0;
                } else {
                  index = 0;
                }
              } else {
                index = 0;
              }
            }
            if (index > 0) {
              lookbehind[index - 1] = c;
            } else if (prevIndex > 0) {
              callback('partData', lookbehind, 0, prevIndex);
              prevIndex = 0;
              mark('partData');
              i--;
            }
            break;
          case S.END:
            break;
          default:
            return i;
        }
      }
      dataCallback('headerField');
      dataCallback('headerValue');
      dataCallback('partData');
      this.index = index;
      this.state = state;
      this.flags = flags;
      return len;
    };
    MultipartParser.prototype.end = function() {
      var callback = function(self, name) {
        var callbackSymbol = 'on' + name.substr(0, 1).toUpperCase() + name.substr(1);
        if (callbackSymbol in self) {
          self[callbackSymbol]();
        }
      };
      if ((this.state == S.HEADER_FIELD_START && this.index === 0) || (this.state == S.PART_DATA && this.index == this.boundary.length)) {
        callback(this, 'partEnd');
        callback(this, 'end');
      } else if (this.state != S.END) {
        return new Error('MultipartParser.end(): stream ended unexpectedly: ' + this.explain());
      }
    };
    MultipartParser.prototype.explain = function() {
      return 'state = ' + MultipartParser.stateToString(this.state);
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12f", ["130"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('querystring') : $__require('130');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("131", ["12f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('12f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("132", ["131"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if (global.GENTLY)
    $__require = GENTLY.hijack($__require);
  var querystring = $__require('131');
  function QuerystringParser(maxKeys) {
    this.maxKeys = maxKeys;
    this.buffer = '';
  }
  exports.QuerystringParser = QuerystringParser;
  QuerystringParser.prototype.write = function(buffer) {
    this.buffer += buffer.toString('ascii');
    return buffer.length;
  };
  QuerystringParser.prototype.end = function() {
    var fields = querystring.parse(this.buffer, '&', '=', {maxKeys: this.maxKeys});
    for (var field in fields) {
      this.onField(field, fields[field]);
    }
    this.buffer = '';
    this.onEnd();
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("133", ["1a", "59"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var EventEmitter = $__require('1a').EventEmitter,
      util = $__require('59');
  function OctetParser(options) {
    if (!(this instanceof OctetParser))
      return new OctetParser(options);
    EventEmitter.call(this);
  }
  util.inherits(OctetParser, EventEmitter);
  exports.OctetParser = OctetParser;
  OctetParser.prototype.write = function(buffer) {
    this.emit('data', buffer);
    return buffer.length;
  };
  OctetParser.prototype.end = function() {
    this.emit('end');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("134", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    if (global.GENTLY)
      $__require = GENTLY.hijack($__require);
    var Buffer = $__require('72').Buffer;
    function JSONParser() {
      this.data = new Buffer('');
      this.bytesWritten = 0;
    }
    exports.JSONParser = JSONParser;
    JSONParser.prototype.initWithLength = function(length) {
      this.data = new Buffer(length);
    };
    JSONParser.prototype.write = function(buffer) {
      if (this.data.length >= this.bytesWritten + buffer.length) {
        buffer.copy(this.data, this.bytesWritten);
      } else {
        this.data = Buffer.concat([this.data, buffer]);
      }
      this.bytesWritten += buffer.length;
      return buffer.length;
    };
    JSONParser.prototype.end = function() {
      try {
        var fields = JSON.parse(this.data.toString('utf8'));
        for (var field in fields) {
          this.onField(field, fields[field]);
        }
      } catch (e) {}
      this.data = null;
      this.onEnd();
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("135", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.endianness = function() {
    return 'LE';
  };
  exports.hostname = function() {
    if (typeof location !== 'undefined') {
      return location.hostname;
    } else
      return '';
  };
  exports.loadavg = function() {
    return [];
  };
  exports.uptime = function() {
    return 0;
  };
  exports.freemem = function() {
    return Number.MAX_VALUE;
  };
  exports.totalmem = function() {
    return Number.MAX_VALUE;
  };
  exports.cpus = function() {
    return [];
  };
  exports.type = function() {
    return 'Browser';
  };
  exports.release = function() {
    if (typeof navigator !== 'undefined') {
      return navigator.appVersion;
    }
    return '';
  };
  exports.networkInterfaces = exports.getNetworkInterfaces = function() {
    return {};
  };
  exports.arch = function() {
    return 'javascript';
  };
  exports.platform = function() {
    return 'browser';
  };
  exports.tmpdir = exports.tmpDir = function() {
    return '/tmp';
  };
  exports.EOL = '\n';
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("136", ["135"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('135');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("137", ["136"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('os') : $__require('136');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e2", ["137"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('137');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("138", ["cd", "e1", "59", "139", "12d", "12e", "132", "133", "134", "fc", "1a", "58", "e2", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    if (global.GENTLY)
      $__require = GENTLY.hijack($__require);
    var crypto = $__require('cd');
    var fs = $__require('e1');
    var util = $__require('59'),
        path = $__require('139'),
        File = $__require('12d'),
        MultipartParser = $__require('12e').MultipartParser,
        QuerystringParser = $__require('132').QuerystringParser,
        OctetParser = $__require('133').OctetParser,
        JSONParser = $__require('134').JSONParser,
        StringDecoder = $__require('fc').StringDecoder,
        EventEmitter = $__require('1a').EventEmitter,
        Stream = $__require('58').Stream,
        os = $__require('e2');
    function IncomingForm(opts) {
      if (!(this instanceof IncomingForm))
        return new IncomingForm(opts);
      EventEmitter.call(this);
      opts = opts || {};
      this.error = null;
      this.ended = false;
      this.maxFields = opts.maxFields || 1000;
      this.maxFieldsSize = opts.maxFieldsSize || 2 * 1024 * 1024;
      this.keepExtensions = opts.keepExtensions || false;
      this.uploadDir = opts.uploadDir || os.tmpDir();
      this.encoding = opts.encoding || 'utf-8';
      this.headers = null;
      this.type = null;
      this.hash = opts.hash || false;
      this.multiples = opts.multiples || false;
      this.bytesReceived = null;
      this.bytesExpected = null;
      this._parser = null;
      this._flushing = 0;
      this._fieldsSize = 0;
      this.openedFiles = [];
      return this;
    }
    util.inherits(IncomingForm, EventEmitter);
    exports.IncomingForm = IncomingForm;
    IncomingForm.prototype.parse = function(req, cb) {
      this.pause = function() {
        try {
          req.pause();
        } catch (err) {
          if (!this.ended) {
            this._error(err);
          }
          return false;
        }
        return true;
      };
      this.resume = function() {
        try {
          req.resume();
        } catch (err) {
          if (!this.ended) {
            this._error(err);
          }
          return false;
        }
        return true;
      };
      if (cb) {
        var fields = {},
            files = {};
        this.on('field', function(name, value) {
          fields[name] = value;
        }).on('file', function(name, file) {
          if (this.multiples) {
            if (files[name]) {
              if (!Array.isArray(files[name])) {
                files[name] = [files[name]];
              }
              files[name].push(file);
            } else {
              files[name] = file;
            }
          } else {
            files[name] = file;
          }
        }).on('error', function(err) {
          cb(err, fields, files);
        }).on('end', function() {
          cb(null, fields, files);
        });
      }
      this.writeHeaders(req.headers);
      var self = this;
      req.on('error', function(err) {
        self._error(err);
      }).on('aborted', function() {
        self.emit('aborted');
        self._error(new Error('Request aborted'));
      }).on('data', function(buffer) {
        self.write(buffer);
      }).on('end', function() {
        if (self.error) {
          return;
        }
        var err = self._parser.end();
        if (err) {
          self._error(err);
        }
      });
      return this;
    };
    IncomingForm.prototype.writeHeaders = function(headers) {
      this.headers = headers;
      this._parseContentLength();
      this._parseContentType();
    };
    IncomingForm.prototype.write = function(buffer) {
      if (this.error) {
        return;
      }
      if (!this._parser) {
        this._error(new Error('uninitialized parser'));
        return;
      }
      this.bytesReceived += buffer.length;
      this.emit('progress', this.bytesReceived, this.bytesExpected);
      var bytesParsed = this._parser.write(buffer);
      if (bytesParsed !== buffer.length) {
        this._error(new Error('parser error, ' + bytesParsed + ' of ' + buffer.length + ' bytes parsed'));
      }
      return bytesParsed;
    };
    IncomingForm.prototype.pause = function() {
      return false;
    };
    IncomingForm.prototype.resume = function() {
      return false;
    };
    IncomingForm.prototype.onPart = function(part) {
      this.handlePart(part);
    };
    IncomingForm.prototype.handlePart = function(part) {
      var self = this;
      if (part.filename === undefined) {
        var value = '',
            decoder = new StringDecoder(this.encoding);
        part.on('data', function(buffer) {
          self._fieldsSize += buffer.length;
          if (self._fieldsSize > self.maxFieldsSize) {
            self._error(new Error('maxFieldsSize exceeded, received ' + self._fieldsSize + ' bytes of field data'));
            return;
          }
          value += decoder.write(buffer);
        });
        part.on('end', function() {
          self.emit('field', part.name, value);
        });
        return;
      }
      this._flushing++;
      var file = new File({
        path: this._uploadPath(part.filename),
        name: part.filename,
        type: part.mime,
        hash: self.hash
      });
      this.emit('fileBegin', part.name, file);
      file.open();
      this.openedFiles.push(file);
      part.on('data', function(buffer) {
        if (buffer.length == 0) {
          return;
        }
        self.pause();
        file.write(buffer, function() {
          self.resume();
        });
      });
      part.on('end', function() {
        file.end(function() {
          self._flushing--;
          self.emit('file', part.name, file);
          self._maybeEnd();
        });
      });
    };
    function dummyParser(self) {
      return {end: function() {
          self.ended = true;
          self._maybeEnd();
          return null;
        }};
    }
    IncomingForm.prototype._parseContentType = function() {
      if (this.bytesExpected === 0) {
        this._parser = dummyParser(this);
        return;
      }
      if (!this.headers['content-type']) {
        this._error(new Error('bad content-type header, no content-type'));
        return;
      }
      if (this.headers['content-type'].match(/octet-stream/i)) {
        this._initOctetStream();
        return;
      }
      if (this.headers['content-type'].match(/urlencoded/i)) {
        this._initUrlencoded();
        return;
      }
      if (this.headers['content-type'].match(/multipart/i)) {
        var m = this.headers['content-type'].match(/boundary=(?:"([^"]+)"|([^;]+))/i);
        if (m) {
          this._initMultipart(m[1] || m[2]);
        } else {
          this._error(new Error('bad content-type header, no multipart boundary'));
        }
        return;
      }
      if (this.headers['content-type'].match(/json/i)) {
        this._initJSONencoded();
        return;
      }
      this._error(new Error('bad content-type header, unknown content-type: ' + this.headers['content-type']));
    };
    IncomingForm.prototype._error = function(err) {
      if (this.error || this.ended) {
        return;
      }
      this.error = err;
      this.emit('error', err);
      if (Array.isArray(this.openedFiles)) {
        this.openedFiles.forEach(function(file) {
          file._writeStream.destroy();
          setTimeout(fs.unlink, 0, file.path, function(error) {});
        });
      }
    };
    IncomingForm.prototype._parseContentLength = function() {
      this.bytesReceived = 0;
      if (this.headers['content-length']) {
        this.bytesExpected = parseInt(this.headers['content-length'], 10);
      } else if (this.headers['transfer-encoding'] === undefined) {
        this.bytesExpected = 0;
      }
      if (this.bytesExpected !== null) {
        this.emit('progress', this.bytesReceived, this.bytesExpected);
      }
    };
    IncomingForm.prototype._newParser = function() {
      return new MultipartParser();
    };
    IncomingForm.prototype._initMultipart = function(boundary) {
      this.type = 'multipart';
      var parser = new MultipartParser(),
          self = this,
          headerField,
          headerValue,
          part;
      parser.initWithBoundary(boundary);
      parser.onPartBegin = function() {
        part = new Stream();
        part.readable = true;
        part.headers = {};
        part.name = null;
        part.filename = null;
        part.mime = null;
        part.transferEncoding = 'binary';
        part.transferBuffer = '';
        headerField = '';
        headerValue = '';
      };
      parser.onHeaderField = function(b, start, end) {
        headerField += b.toString(self.encoding, start, end);
      };
      parser.onHeaderValue = function(b, start, end) {
        headerValue += b.toString(self.encoding, start, end);
      };
      parser.onHeaderEnd = function() {
        headerField = headerField.toLowerCase();
        part.headers[headerField] = headerValue;
        var m = headerValue.match(/\bname="([^"]+)"/i);
        if (headerField == 'content-disposition') {
          if (m) {
            part.name = m[1];
          }
          part.filename = self._fileName(headerValue);
        } else if (headerField == 'content-type') {
          part.mime = headerValue;
        } else if (headerField == 'content-transfer-encoding') {
          part.transferEncoding = headerValue.toLowerCase();
        }
        headerField = '';
        headerValue = '';
      };
      parser.onHeadersEnd = function() {
        switch (part.transferEncoding) {
          case 'binary':
          case '7bit':
          case '8bit':
            parser.onPartData = function(b, start, end) {
              part.emit('data', b.slice(start, end));
            };
            parser.onPartEnd = function() {
              part.emit('end');
            };
            break;
          case 'base64':
            parser.onPartData = function(b, start, end) {
              part.transferBuffer += b.slice(start, end).toString('ascii');
              var offset = parseInt(part.transferBuffer.length / 4, 10) * 4;
              part.emit('data', new Buffer(part.transferBuffer.substring(0, offset), 'base64'));
              part.transferBuffer = part.transferBuffer.substring(offset);
            };
            parser.onPartEnd = function() {
              part.emit('data', new Buffer(part.transferBuffer, 'base64'));
              part.emit('end');
            };
            break;
          default:
            return self._error(new Error('unknown transfer-encoding'));
        }
        self.onPart(part);
      };
      parser.onEnd = function() {
        self.ended = true;
        self._maybeEnd();
      };
      this._parser = parser;
    };
    IncomingForm.prototype._fileName = function(headerValue) {
      var m = headerValue.match(/\bfilename="(.*?)"($|; )/i);
      if (!m)
        return;
      var filename = m[1].substr(m[1].lastIndexOf('\\') + 1);
      filename = filename.replace(/%22/g, '"');
      filename = filename.replace(/&#([\d]{4});/g, function(m, code) {
        return String.fromCharCode(code);
      });
      return filename;
    };
    IncomingForm.prototype._initUrlencoded = function() {
      this.type = 'urlencoded';
      var parser = new QuerystringParser(this.maxFields),
          self = this;
      parser.onField = function(key, val) {
        self.emit('field', key, val);
      };
      parser.onEnd = function() {
        self.ended = true;
        self._maybeEnd();
      };
      this._parser = parser;
    };
    IncomingForm.prototype._initOctetStream = function() {
      this.type = 'octet-stream';
      var filename = this.headers['x-file-name'];
      var mime = this.headers['content-type'];
      var file = new File({
        path: this._uploadPath(filename),
        name: filename,
        type: mime
      });
      this.emit('fileBegin', filename, file);
      file.open();
      this._flushing++;
      var self = this;
      self._parser = new OctetParser();
      var outstandingWrites = 0;
      self._parser.on('data', function(buffer) {
        self.pause();
        outstandingWrites++;
        file.write(buffer, function() {
          outstandingWrites--;
          self.resume();
          if (self.ended) {
            self._parser.emit('doneWritingFile');
          }
        });
      });
      self._parser.on('end', function() {
        self._flushing--;
        self.ended = true;
        var done = function() {
          file.end(function() {
            self.emit('file', 'file', file);
            self._maybeEnd();
          });
        };
        if (outstandingWrites === 0) {
          done();
        } else {
          self._parser.once('doneWritingFile', done);
        }
      });
    };
    IncomingForm.prototype._initJSONencoded = function() {
      this.type = 'json';
      var parser = new JSONParser(),
          self = this;
      if (this.bytesExpected) {
        parser.initWithLength(this.bytesExpected);
      }
      parser.onField = function(key, val) {
        self.emit('field', key, val);
      };
      parser.onEnd = function() {
        self.ended = true;
        self._maybeEnd();
      };
      this._parser = parser;
    };
    IncomingForm.prototype._uploadPath = function(filename) {
      var name = 'upload_';
      var buf = crypto.randomBytes(16);
      for (var i = 0; i < buf.length; ++i) {
        name += ('0' + buf[i].toString(16)).slice(-2);
      }
      if (this.keepExtensions) {
        var ext = path.extname(filename);
        ext = ext.replace(/(\.[a-z0-9]+).*/i, '$1');
        name += ext;
      }
      return path.join(this.uploadDir, name);
    };
    IncomingForm.prototype._maybeEnd = function() {
      if (!this.ended || this._flushing || this.error) {
        return;
      }
      this.emit('end');
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13a", ["138"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IncomingForm = $__require('138').IncomingForm;
  IncomingForm.IncomingForm = IncomingForm;
  module.exports = IncomingForm;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13b", ["13a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('13a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13c", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== 'function')
      throw new TypeError('need wrapper function');
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb = args[args.length - 1];
      if (typeof ret === 'function' && ret !== cb) {
        Object.keys(cb).forEach(function(k) {
          ret[k] = cb[k];
        });
      }
      return ret;
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13d", ["13c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('13c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13e", ["13d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var wrappy = $__require('13d');
  module.exports = wrappy(once);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, 'once', {
      value: function() {
        return once(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d5", ["13e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('13e');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13f", ["71", "1a", "59", "140", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var mod_assert = $__require('71');
    var mod_events = $__require('1a');
    var mod_util = $__require('59');
    var mod_verror = $__require('140');
    exports.parallel = parallel;
    exports.forEachParallel = forEachParallel;
    exports.pipeline = pipeline;
    exports.forEachPipeline = forEachPipeline;
    exports.queue = queue;
    exports.queuev = queuev;
    exports.barrier = barrier;
    exports.waterfall = waterfall;
    if (!global.setImmediate) {
      global.setImmediate = function(func) {
        var args = Array.prototype.slice.call(arguments, 1);
        args.unshift(0);
        args.unshift(func);
        setTimeout.apply(this, args);
      };
    }
    function isEmpty(obj) {
      var key;
      for (key in obj)
        return (false);
      return (true);
    }
    function parallel(args, callback) {
      var funcs,
          rv,
          doneOne,
          i;
      mod_assert.equal(typeof(args), 'object', '"args" must be an object');
      mod_assert.ok(Array.isArray(args['funcs']), '"args.funcs" must be specified and must be an array');
      mod_assert.equal(typeof(callback), 'function', 'callback argument must be specified and must be a function');
      funcs = args['funcs'].slice(0);
      rv = {
        'operations': new Array(funcs.length),
        'successes': [],
        'ndone': 0,
        'nerrors': 0
      };
      if (funcs.length === 0) {
        setImmediate(function() {
          callback(null, rv);
        });
        return (rv);
      }
      doneOne = function(entry) {
        return (function(err, result) {
          mod_assert.equal(entry['status'], 'pending');
          entry['err'] = err;
          entry['result'] = result;
          entry['status'] = err ? 'fail' : 'ok';
          if (err)
            rv['nerrors']++;
          else
            rv['successes'].push(result);
          if (++rv['ndone'] < funcs.length)
            return;
          var errors = rv['operations'].filter(function(ent) {
            return (ent['status'] == 'fail');
          }).map(function(ent) {
            return (ent['err']);
          });
          if (errors.length > 0)
            callback(new mod_verror.MultiError(errors), rv);
          else
            callback(null, rv);
        });
      };
      for (i = 0; i < funcs.length; i++) {
        rv['operations'][i] = {
          'func': funcs[i],
          'funcname': funcs[i].name || '(anon)',
          'status': 'pending'
        };
        funcs[i](doneOne(rv['operations'][i]));
      }
      return (rv);
    }
    function forEachParallel(args, callback) {
      var func,
          funcs;
      mod_assert.equal(typeof(args), 'object', '"args" must be an object');
      mod_assert.equal(typeof(args['func']), 'function', '"args.func" must be specified and must be a function');
      mod_assert.ok(Array.isArray(args['inputs']), '"args.inputs" must be specified and must be an array');
      func = args['func'];
      funcs = args['inputs'].map(function(input) {
        return (function(subcallback) {
          return (func(input, subcallback));
        });
      });
      return (parallel({'funcs': funcs}, callback));
    }
    function pipeline(args, callback) {
      var funcs,
          uarg,
          rv,
          next;
      mod_assert.equal(typeof(args), 'object', '"args" must be an object');
      mod_assert.ok(Array.isArray(args['funcs']), '"args.funcs" must be specified and must be an array');
      funcs = args['funcs'].slice(0);
      uarg = args['arg'];
      rv = {
        'operations': funcs.map(function(func) {
          return ({
            'func': func,
            'funcname': func.name || '(anon)',
            'status': 'waiting'
          });
        }),
        'successes': [],
        'ndone': 0,
        'nerrors': 0
      };
      if (funcs.length === 0) {
        setImmediate(function() {
          callback(null, rv);
        });
        return (rv);
      }
      next = function(err, result) {
        if (rv['nerrors'] > 0 || rv['ndone'] >= rv['operations'].length) {
          throw new mod_verror.VError('pipeline callback ' + 'invoked after the pipeline has already ' + 'completed (%j)', rv);
        }
        var entry = rv['operations'][rv['ndone']++];
        mod_assert.equal(entry['status'], 'pending');
        entry['status'] = err ? 'fail' : 'ok';
        entry['err'] = err;
        entry['result'] = result;
        if (err)
          rv['nerrors']++;
        else
          rv['successes'].push(result);
        if (err || rv['ndone'] == funcs.length) {
          callback(err, rv);
        } else {
          var nextent = rv['operations'][rv['ndone']];
          nextent['status'] = 'pending';
          setImmediate(function() {
            nextent['func'](uarg, next);
          });
        }
      };
      rv['operations'][0]['status'] = 'pending';
      funcs[0](uarg, next);
      return (rv);
    }
    function forEachPipeline(args, callback) {
      mod_assert.equal(typeof(args), 'object', '"args" must be an object');
      mod_assert.equal(typeof(args['func']), 'function', '"args.func" must be specified and must be a function');
      mod_assert.ok(Array.isArray(args['inputs']), '"args.inputs" must be specified and must be an array');
      mod_assert.equal(typeof(callback), 'function', 'callback argument must be specified and must be a function');
      var func = args['func'];
      var funcs = args['inputs'].map(function(input) {
        return (function(_, subcallback) {
          return (func(input, subcallback));
        });
      });
      return (pipeline({'funcs': funcs}, callback));
    }
    function queue(worker, concurrency) {
      return (new WorkQueue({
        'worker': worker,
        'concurrency': concurrency
      }));
    }
    function queuev(args) {
      return (new WorkQueue(args));
    }
    function WorkQueue(args) {
      mod_assert.ok(args.hasOwnProperty('worker'));
      mod_assert.equal(typeof(args['worker']), 'function');
      mod_assert.ok(args.hasOwnProperty('concurrency'));
      mod_assert.equal(typeof(args['concurrency']), 'number');
      mod_assert.equal(Math.floor(args['concurrency']), args['concurrency']);
      mod_assert.ok(args['concurrency'] > 0);
      mod_events.EventEmitter.call(this);
      this.nextid = 0;
      this.worker = args['worker'];
      this.worker_name = args['worker'].name || 'anon';
      this.npending = 0;
      this.pending = {};
      this.queued = [];
      this.closed = false;
      this.ended = false;
      this.concurrency = args['concurrency'];
      this.saturated = undefined;
      this.empty = undefined;
      this.drain = undefined;
    }
    mod_util.inherits(WorkQueue, mod_events.EventEmitter);
    WorkQueue.prototype.push = function(tasks, callback) {
      if (!Array.isArray(tasks))
        return (this.pushOne(tasks, callback));
      var wq = this;
      return (tasks.map(function(task) {
        return (wq.pushOne(task, callback));
      }));
    };
    WorkQueue.prototype.updateConcurrency = function(concurrency) {
      if (this.closed)
        throw new mod_verror.VError('update concurrency invoked after queue closed');
      this.concurrency = concurrency;
      this.dispatchNext();
    };
    WorkQueue.prototype.close = function() {
      var wq = this;
      if (wq.closed)
        return;
      wq.closed = true;
      if (wq.npending === 0 && wq.queued.length === 0) {
        setImmediate(function() {
          if (!wq.ended) {
            wq.ended = true;
            wq.emit('end');
          }
        });
      }
    };
    WorkQueue.prototype.pushOne = function(task, callback) {
      if (this.closed)
        throw new mod_verror.VError('push invoked after queue closed');
      var id = ++this.nextid;
      var entry = {
        'id': id,
        'task': task,
        'callback': callback
      };
      this.queued.push(entry);
      this.dispatchNext();
      return (id);
    };
    WorkQueue.prototype.dispatchNext = function() {
      var wq = this;
      if (wq.npending === 0 && wq.queued.length === 0) {
        if (wq.drain)
          wq.drain();
        wq.emit('drain');
        if (wq.closed) {
          wq.ended = true;
          wq.emit('end');
        }
      } else if (wq.queued.length > 0) {
        while (wq.queued.length > 0 && wq.npending < wq.concurrency) {
          var next = wq.queued.shift();
          wq.dispatch(next);
          if (wq.queued.length === 0) {
            if (wq.empty)
              wq.empty();
            wq.emit('empty');
          }
        }
      }
    };
    WorkQueue.prototype.dispatch = function(entry) {
      var wq = this;
      mod_assert.ok(!this.pending.hasOwnProperty(entry['id']));
      mod_assert.ok(this.npending < this.concurrency);
      mod_assert.ok(!this.ended);
      this.npending++;
      this.pending[entry['id']] = entry;
      if (this.npending === this.concurrency) {
        if (this.saturated)
          this.saturated();
        this.emit('saturated');
      }
      setImmediate(function() {
        wq.worker(entry['task'], function(err) {
          --wq.npending;
          delete(wq.pending[entry['id']]);
          if (entry['callback'])
            entry['callback'].apply(null, arguments);
          wq.dispatchNext();
        });
      });
    };
    WorkQueue.prototype.length = function() {
      return (this.queued.length);
    };
    WorkQueue.prototype.kill = function() {
      this.killed = true;
      this.queued = [];
      this.drain = undefined;
      this.close();
    };
    function barrier(args) {
      return (new Barrier(args));
    }
    function Barrier(args) {
      mod_assert.ok(!args || !args['nrecent'] || typeof(args['nrecent']) == 'number', '"nrecent" must have type "number"');
      mod_events.EventEmitter.call(this);
      var nrecent = args && args['nrecent'] ? args['nrecent'] : 10;
      if (nrecent > 0) {
        this.nrecent = nrecent;
        this.recent = [];
      }
      this.pending = {};
      this.scheduled = false;
    }
    mod_util.inherits(Barrier, mod_events.EventEmitter);
    Barrier.prototype.start = function(name) {
      mod_assert.ok(!this.pending.hasOwnProperty(name), 'operation "' + name + '" is already pending');
      this.pending[name] = Date.now();
    };
    Barrier.prototype.done = function(name) {
      mod_assert.ok(this.pending.hasOwnProperty(name), 'operation "' + name + '" is not pending');
      if (this.recent) {
        this.recent.push({
          'name': name,
          'start': this.pending[name],
          'done': Date.now()
        });
        if (this.recent.length > this.nrecent)
          this.recent.shift();
      }
      delete(this.pending[name]);
      if (!isEmpty(this.pending) || this.scheduled)
        return;
      this.scheduled = true;
      var self = this;
      setImmediate(function() {
        self.scheduled = false;
        if (isEmpty(self.pending))
          self.emit('drain');
      });
    };
    function waterfall(funcs, callback) {
      var rv,
          current,
          next;
      mod_assert.ok(Array.isArray(funcs));
      mod_assert.ok(arguments.length == 1 || typeof(callback) == 'function');
      funcs = funcs.slice(0);
      rv = {
        'operations': funcs.map(function(func) {
          return ({
            'func': func,
            'funcname': func.name || '(anon)',
            'status': 'waiting'
          });
        }),
        'successes': [],
        'ndone': 0,
        'nerrors': 0
      };
      if (funcs.length === 0) {
        if (callback)
          setImmediate(function() {
            callback(null, rv);
          });
        return (rv);
      }
      next = function(idx, err) {
        var args,
            entry,
            nextentry;
        if (err === undefined)
          err = null;
        if (idx != current) {
          throw (new mod_verror.VError('vasync.waterfall: function %d ("%s") invoked ' + 'its callback twice', idx, rv['operations'][idx].funcname));
        }
        mod_assert.equal(idx, rv['ndone']);
        entry = rv['operations'][rv['ndone']++];
        args = Array.prototype.slice.call(arguments, 2);
        mod_assert.equal(entry['status'], 'pending');
        entry['status'] = err ? 'fail' : 'ok';
        entry['err'] = err;
        entry['results'] = args;
        if (err)
          rv['nerrors']++;
        else
          rv['successes'].push(args);
        if (err || rv['ndone'] == funcs.length) {
          if (callback) {
            args.unshift(err);
            callback.apply(null, args);
          }
        } else {
          nextentry = rv['operations'][rv['ndone']];
          nextentry['status'] = 'pending';
          current++;
          args.push(next.bind(null, current));
          setImmediate(function() {
            nextentry['func'].apply(null, args);
          });
        }
      };
      rv['operations'][0]['status'] = 'pending';
      current = 0;
      funcs[0](next.bind(null, current));
      return (rv);
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d6", ["13f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('13f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("10d", ["e1", "5a", "13b", "d5", "69", "d6"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var fs = $__require('e1');
  var assert = $__require('5a');
  var formidable = $__require('13b');
  var once = $__require('d5');
  var errors = $__require('69');
  var vasync = $__require('d6');
  function multipartBodyParser(options) {
    var opts = options || {};
    assert.object(opts, 'opts');
    assert.optionalBool(opts.overrideParams, 'opts.overrideParams');
    assert.optionalBool(opts.multiples, 'opts.multiples');
    assert.optionalBool(opts.keepExtensions, 'opts.keepExtensions');
    assert.optionalString(opts.uploadDir, 'opts.uploadDir');
    assert.optionalNumber(opts.maxFieldsSize, 'opts.maxFieldsSize');
    assert.optionalString(opts.hash, 'opts.hash');
    assert.optionalFunc(opts.multipartFileHandler, 'opts.multipartFileHandler');
    assert.optionalFunc(opts.multipartHandler, 'opts.multipartHandler');
    assert.optionalBool(opts.mapParams, 'opts.mapParams');
    assert.optionalBool(opts.mapFiles, 'opts.mapFiles');
    var override = opts.overrideParams;
    function parseMultipartBody(req, res, originalNext) {
      req.rawBody = req._body = undefined;
      var next = once(originalNext);
      if (req.getContentType() !== 'multipart/form-data' || (req.getContentLength() === 0 && !req.isChunked())) {
        return (next());
      }
      var form = new formidable.IncomingForm();
      form.multiples = opts.multiples || false;
      form.keepExtensions = opts.keepExtensions ? true : false;
      if (opts.uploadDir) {
        form.uploadDir = opts.uploadDir;
      }
      if (opts.maxFieldsSize) {
        form.maxFieldsSize = opts.maxFieldsSize;
      }
      if (opts.hash) {
        form.hash = opts.hash;
      }
      form.onPart = function onPart(part) {
        if (part.filename && opts.multipartFileHandler) {
          opts.multipartFileHandler(part, req);
        } else if (!part.filename && opts.multipartHandler) {
          opts.multipartHandler(part, req);
        } else {
          form.handlePart(part);
        }
      };
      form.parse(req, function(err, fields, files) {
        if (err) {
          return (next(new errors.BadRequestError(err.message)));
        }
        req.body = fields;
        req.files = files;
        if (opts.mapParams !== false) {
          Object.keys(fields).forEach(function(k) {
            if (req.params[k] && !override) {
              return;
            }
            req.params[k] = fields[k];
          });
          if (opts.mapFiles) {
            var barrier = vasync.barrier();
            barrier.on('drain', function() {
              return next();
            });
            barrier.start('fs');
            Object.keys(files).forEach(function(f) {
              if (req.params[f] && !override) {
                return;
              }
              barrier.start('fs' + f);
              fs.readFile(files[f].path, function(ex, data) {
                barrier.done('fs' + f);
                if (ex) {
                  return next(new errors.InternalError(ex, 'unable to read file' + f));
                }
                req.params[f] = data;
                return (true);
              });
            });
            barrier.done('fs');
          } else {
            return next();
          }
        } else {
          return next();
        }
      });
      return (false);
    }
    return (parseMultipartBody);
  }
  module.exports = multipartBodyParser;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("141", ["142"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Utils = $__require('142');
  var internals = {
    delimiter: '&',
    arrayPrefixGenerators: {
      brackets: function(prefix, key) {
        return prefix + '[]';
      },
      indices: function(prefix, key) {
        return prefix + '[' + key + ']';
      },
      repeat: function(prefix, key) {
        return prefix;
      }
    },
    strictNullHandling: false,
    skipNulls: false,
    encode: true
  };
  internals.stringify = function(obj, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort) {
    if (typeof filter === 'function') {
      obj = filter(prefix, obj);
    } else if (Utils.isBuffer(obj)) {
      obj = obj.toString();
    } else if (obj instanceof Date) {
      obj = obj.toISOString();
    } else if (obj === null) {
      if (strictNullHandling) {
        return encode ? Utils.encode(prefix) : prefix;
      }
      obj = '';
    }
    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {
      if (encode) {
        return [Utils.encode(prefix) + '=' + Utils.encode(obj)];
      }
      return [prefix + '=' + obj];
    }
    var values = [];
    if (typeof obj === 'undefined') {
      return values;
    }
    var objKeys;
    if (Array.isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    for (var i = 0,
        il = objKeys.length; i < il; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj[key] === null) {
        continue;
      }
      if (Array.isArray(obj)) {
        values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));
      } else {
        values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));
      }
    }
    return values;
  };
  module.exports = function(obj, options) {
    options = options || {};
    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : internals.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : internals.encode;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var objKeys;
    var filter;
    if (typeof options.filter === 'function') {
      filter = options.filter;
      obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
      objKeys = filter = options.filter;
    }
    var keys = [];
    if (typeof obj !== 'object' || obj === null) {
      return '';
    }
    var arrayFormat;
    if (options.arrayFormat in internals.arrayPrefixGenerators) {
      arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
      arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
      arrayFormat = 'indices';
    }
    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (sort) {
      objKeys.sort(sort);
    }
    for (var i = 0,
        il = objKeys.length; i < il; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj[key] === null) {
        continue;
      }
      keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort));
    }
    return keys.join(delimiter);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("142", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var internals = {};
  internals.hexTable = new Array(256);
  for (var h = 0; h < 256; ++h) {
    internals.hexTable[h] = '%' + ((h < 16 ? '0' : '') + h.toString(16)).toUpperCase();
  }
  exports.arrayToObject = function(source, options) {
    var obj = options.plainObjects ? Object.create(null) : {};
    for (var i = 0,
        il = source.length; i < il; ++i) {
      if (typeof source[i] !== 'undefined') {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  exports.merge = function(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== 'object') {
      if (Array.isArray(target)) {
        target.push(source);
      } else if (typeof target === 'object') {
        target[source] = true;
      } else {
        target = [target, source];
      }
      return target;
    }
    if (typeof target !== 'object') {
      target = [target].concat(source);
      return target;
    }
    if (Array.isArray(target) && !Array.isArray(source)) {
      target = exports.arrayToObject(target, options);
    }
    var keys = Object.keys(source);
    for (var k = 0,
        kl = keys.length; k < kl; ++k) {
      var key = keys[k];
      var value = source[key];
      if (!Object.prototype.hasOwnProperty.call(target, key)) {
        target[key] = value;
      } else {
        target[key] = exports.merge(target[key], value, options);
      }
    }
    return target;
  };
  exports.decode = function(str) {
    try {
      return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
      return str;
    }
  };
  exports.encode = function(str) {
    if (str.length === 0) {
      return str;
    }
    if (typeof str !== 'string') {
      str = '' + str;
    }
    var out = '';
    for (var i = 0,
        il = str.length; i < il; ++i) {
      var c = str.charCodeAt(i);
      if (c === 0x2D || c === 0x2E || c === 0x5F || c === 0x7E || (c >= 0x30 && c <= 0x39) || (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A)) {
        out += str[i];
        continue;
      }
      if (c < 0x80) {
        out += internals.hexTable[c];
        continue;
      }
      if (c < 0x800) {
        out += internals.hexTable[0xC0 | (c >> 6)] + internals.hexTable[0x80 | (c & 0x3F)];
        continue;
      }
      if (c < 0xD800 || c >= 0xE000) {
        out += internals.hexTable[0xE0 | (c >> 12)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
        continue;
      }
      ++i;
      c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));
      out += internals.hexTable[0xF0 | (c >> 18)] + internals.hexTable[0x80 | ((c >> 12) & 0x3F)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
    }
    return out;
  };
  exports.compact = function(obj, refs) {
    if (typeof obj !== 'object' || obj === null) {
      return obj;
    }
    refs = refs || [];
    var lookup = refs.indexOf(obj);
    if (lookup !== -1) {
      return refs[lookup];
    }
    refs.push(obj);
    if (Array.isArray(obj)) {
      var compacted = [];
      for (var i = 0,
          il = obj.length; i < il; ++i) {
        if (typeof obj[i] !== 'undefined') {
          compacted.push(obj[i]);
        }
      }
      return compacted;
    }
    var keys = Object.keys(obj);
    for (i = 0, il = keys.length; i < il; ++i) {
      var key = keys[i];
      obj[key] = exports.compact(obj[key], refs);
    }
    return obj;
  };
  exports.isRegExp = function(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
  };
  exports.isBuffer = function(obj) {
    if (obj === null || typeof obj === 'undefined') {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("143", ["142"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Utils = $__require('142');
  var internals = {
    delimiter: '&',
    depth: 5,
    arrayLimit: 20,
    parameterLimit: 1000,
    strictNullHandling: false,
    plainObjects: false,
    allowPrototypes: false,
    allowDots: false
  };
  internals.parseValues = function(str, options) {
    var obj = {};
    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);
    for (var i = 0,
        il = parts.length; i < il; ++i) {
      var part = parts[i];
      var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;
      if (pos === -1) {
        obj[Utils.decode(part)] = '';
        if (options.strictNullHandling) {
          obj[Utils.decode(part)] = null;
        }
      } else {
        var key = Utils.decode(part.slice(0, pos));
        var val = Utils.decode(part.slice(pos + 1));
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          obj[key] = val;
        } else {
          obj[key] = [].concat(obj[key]).concat(val);
        }
      }
    }
    return obj;
  };
  internals.parseObject = function(chain, val, options) {
    if (!chain.length) {
      return val;
    }
    var root = chain.shift();
    var obj;
    if (root === '[]') {
      obj = [];
      obj = obj.concat(internals.parseObject(chain, val, options));
    } else {
      obj = options.plainObjects ? Object.create(null) : {};
      var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
      var index = parseInt(cleanRoot, 10);
      var indexString = '' + index;
      if (!isNaN(index) && root !== cleanRoot && indexString === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
        obj = [];
        obj[index] = internals.parseObject(chain, val, options);
      } else {
        obj[cleanRoot] = internals.parseObject(chain, val, options);
      }
    }
    return obj;
  };
  internals.parseKeys = function(key, val, options) {
    if (!key) {
      return;
    }
    if (options.allowDots) {
      key = key.replace(/\.([^\.\[]+)/g, '[$1]');
    }
    var parent = /^([^\[\]]*)/;
    var child = /(\[[^\[\]]*\])/g;
    var segment = parent.exec(key);
    var keys = [];
    if (segment[1]) {
      if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
      ++i;
      if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
        if (!options.allowPrototypes) {
          continue;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      keys.push('[' + key.slice(segment.index) + ']');
    }
    return internals.parseObject(keys, val, options);
  };
  module.exports = function(str, options) {
    options = options || {};
    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
    if (str === '' || str === null || typeof str === 'undefined') {
      return options.plainObjects ? Object.create(null) : {};
    }
    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0,
        il = keys.length; i < il; ++i) {
      var key = keys[i];
      var newObj = internals.parseKeys(key, tempObj[key], options);
      obj = Utils.merge(obj, newObj, options);
    }
    return Utils.compact(obj);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("144", ["141", "143"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Stringify = $__require('141');
  var Parse = $__require('143');
  var internals = {};
  module.exports = {
    stringify: Stringify,
    parse: Parse
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("111", ["144"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('144');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("145", ["111", "5a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var qs = $__require('111');
  var assert = $__require('5a');
  function queryParser(options) {
    var opts = options || {};
    assert.object(opts, 'opts');
    function parseQueryString(req, res, next) {
      if (!req.getQuery()) {
        req.query = {};
        return next();
      }
      req.query = qs.parse(req.getQuery());
      if (opts.mapParams === true) {
        Object.keys(req.query).forEach(function(k) {
          if (req.params[k] && !opts.overrideParams) {
            return;
          }
          req.params[k] = req.query[k];
        });
      }
      return next();
    }
    return parseQueryString;
  }
  module.exports = queryParser;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("146", ["5a", "69"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('5a');
  var GatewayTimeoutError = $__require('69').GatewayTimeoutError;
  function requestExpiry(options) {
    assert.object(options, 'options');
    assert.optionalString(options.absoluteHeader, 'options.absoluteHeader');
    assert.optionalString(options.startHeader, 'options.startHeader');
    assert.optionalString(options.timeoutHeader, 'options.timeoutHeader');
    var useAbsolute = (options.absoluteHeader !== undefined);
    var absoluteHeaderKey = options.absoluteHeader;
    var startHeaderKey = options.startHeader;
    var timeoutHeaderKey = options.timeoutHeader;
    return function requestExpirationCheck(req, res, next) {
      var expiryTime;
      if (useAbsolute) {
        expiryTime = Number(req.headers[absoluteHeaderKey]);
      } else {
        var startTime = req.headers[startHeaderKey];
        var timeout = req.headers[timeoutHeaderKey];
        if (startTime && timeout) {
          expiryTime = Number(startTime) + Number(timeout);
        }
      }
      if (expiryTime) {
        if (Date.now() > expiryTime) {
          return next(new GatewayTimeoutError('Request has expired'));
        }
      }
      return next();
    };
  }
  module.exports = requestExpiry;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("147", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(str) {
    return String(str).replace(/([.*+?=^!:${}()|[\]\/\\])/g, '\\$1');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("148", ["147"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('147');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("149", ["9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    function normalizeArray(parts, allowAboveRoot) {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }
      return parts;
    }
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var splitPath = function(filename) {
      return splitPathRe.exec(filename).slice(1);
    };
    exports.resolve = function() {
      var resolvedPath = '',
          resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = (i >= 0) ? arguments[i] : process.cwd();
        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }
        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }
      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
        return !!p;
      }), !resolvedAbsolute).join('/');
      return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    };
    exports.normalize = function(path) {
      var isAbsolute = exports.isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';
      path = normalizeArray(filter(path.split('/'), function(p) {
        return !!p;
      }), !isAbsolute).join('/');
      if (!path && !isAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }
      return (isAbsolute ? '/' : '') + path;
    };
    exports.isAbsolute = function(path) {
      return path.charAt(0) === '/';
    };
    exports.join = function() {
      var paths = Array.prototype.slice.call(arguments, 0);
      return exports.normalize(filter(paths, function(p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }).join('/'));
    };
    exports.relative = function(from, to) {
      from = exports.resolve(from).substr(1);
      to = exports.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '')
            break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '')
            break;
        }
        if (start > end)
          return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join('/');
    };
    exports.sep = '/';
    exports.delimiter = ':';
    exports.dirname = function(path) {
      var result = splitPath(path),
          root = result[0],
          dir = result[1];
      if (!root && !dir) {
        return '.';
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    };
    exports.basename = function(path, ext) {
      var f = splitPath(path)[2];
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    exports.extname = function(path) {
      return splitPath(path)[3];
    };
    function filter(xs, f) {
      if (xs.filter)
        return xs.filter(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs))
          res.push(xs[i]);
      }
      return res;
    }
    var substr = 'ab'.substr(-1) === 'b' ? function(str, start, len) {
      return str.substr(start, len);
    } : function(str, start, len) {
      if (start < 0)
        start = str.length + start;
      return str.substr(start, len);
    };
    ;
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14a", ["149"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('149');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14b", ["14a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('path') : $__require('14a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("139", ["14b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('14b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14c", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if ($__System._nodeRequire) {
    module.exports = $__System._nodeRequire('fs');
  } else {
    exports.readFileSync = function(address) {
      var output;
      var xhr = new XMLHttpRequest();
      xhr.open('GET', address, false);
      xhr.onreadystatechange = function(e) {
        if (xhr.readyState == 4) {
          var status = xhr.status;
          if ((status > 399 && status < 600) || status == 400) {
            throw 'File read error on ' + address;
          } else
            output = xhr.responseText;
        }
      };
      xhr.send(null);
      return output;
    };
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e1", ["14c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('14c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14d", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "application/andrew-inset": ["ez"],
    "application/applixware": ["aw"],
    "application/atom+xml": ["atom"],
    "application/atomcat+xml": ["atomcat"],
    "application/atomsvc+xml": ["atomsvc"],
    "application/ccxml+xml": ["ccxml"],
    "application/cdmi-capability": ["cdmia"],
    "application/cdmi-container": ["cdmic"],
    "application/cdmi-domain": ["cdmid"],
    "application/cdmi-object": ["cdmio"],
    "application/cdmi-queue": ["cdmiq"],
    "application/cu-seeme": ["cu"],
    "application/dash+xml": ["mdp"],
    "application/davmount+xml": ["davmount"],
    "application/docbook+xml": ["dbk"],
    "application/dssc+der": ["dssc"],
    "application/dssc+xml": ["xdssc"],
    "application/ecmascript": ["ecma"],
    "application/emma+xml": ["emma"],
    "application/epub+zip": ["epub"],
    "application/exi": ["exi"],
    "application/font-tdpfr": ["pfr"],
    "application/font-woff": ["woff"],
    "application/font-woff2": ["woff2"],
    "application/gml+xml": ["gml"],
    "application/gpx+xml": ["gpx"],
    "application/gxf": ["gxf"],
    "application/hyperstudio": ["stk"],
    "application/inkml+xml": ["ink", "inkml"],
    "application/ipfix": ["ipfix"],
    "application/java-archive": ["jar"],
    "application/java-serialized-object": ["ser"],
    "application/java-vm": ["class"],
    "application/javascript": ["js"],
    "application/json": ["json", "map"],
    "application/json5": ["json5"],
    "application/jsonml+json": ["jsonml"],
    "application/lost+xml": ["lostxml"],
    "application/mac-binhex40": ["hqx"],
    "application/mac-compactpro": ["cpt"],
    "application/mads+xml": ["mads"],
    "application/marc": ["mrc"],
    "application/marcxml+xml": ["mrcx"],
    "application/mathematica": ["ma", "nb", "mb"],
    "application/mathml+xml": ["mathml"],
    "application/mbox": ["mbox"],
    "application/mediaservercontrol+xml": ["mscml"],
    "application/metalink+xml": ["metalink"],
    "application/metalink4+xml": ["meta4"],
    "application/mets+xml": ["mets"],
    "application/mods+xml": ["mods"],
    "application/mp21": ["m21", "mp21"],
    "application/mp4": ["mp4s", "m4p"],
    "application/msword": ["doc", "dot"],
    "application/mxf": ["mxf"],
    "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "buffer"],
    "application/oda": ["oda"],
    "application/oebps-package+xml": ["opf"],
    "application/ogg": ["ogx"],
    "application/omdoc+xml": ["omdoc"],
    "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
    "application/oxps": ["oxps"],
    "application/patch-ops-error+xml": ["xer"],
    "application/pdf": ["pdf"],
    "application/pgp-encrypted": ["pgp"],
    "application/pgp-signature": ["asc", "sig"],
    "application/pics-rules": ["prf"],
    "application/pkcs10": ["p10"],
    "application/pkcs7-mime": ["p7m", "p7c"],
    "application/pkcs7-signature": ["p7s"],
    "application/pkcs8": ["p8"],
    "application/pkix-attr-cert": ["ac"],
    "application/pkix-cert": ["cer"],
    "application/pkix-crl": ["crl"],
    "application/pkix-pkipath": ["pkipath"],
    "application/pkixcmp": ["pki"],
    "application/pls+xml": ["pls"],
    "application/postscript": ["ai", "eps", "ps"],
    "application/prs.cww": ["cww"],
    "application/pskc+xml": ["pskcxml"],
    "application/rdf+xml": ["rdf"],
    "application/reginfo+xml": ["rif"],
    "application/relax-ng-compact-syntax": ["rnc"],
    "application/resource-lists+xml": ["rl"],
    "application/resource-lists-diff+xml": ["rld"],
    "application/rls-services+xml": ["rs"],
    "application/rpki-ghostbusters": ["gbr"],
    "application/rpki-manifest": ["mft"],
    "application/rpki-roa": ["roa"],
    "application/rsd+xml": ["rsd"],
    "application/rss+xml": ["rss"],
    "application/rtf": ["rtf"],
    "application/sbml+xml": ["sbml"],
    "application/scvp-cv-request": ["scq"],
    "application/scvp-cv-response": ["scs"],
    "application/scvp-vp-request": ["spq"],
    "application/scvp-vp-response": ["spp"],
    "application/sdp": ["sdp"],
    "application/set-payment-initiation": ["setpay"],
    "application/set-registration-initiation": ["setreg"],
    "application/shf+xml": ["shf"],
    "application/smil+xml": ["smi", "smil"],
    "application/sparql-query": ["rq"],
    "application/sparql-results+xml": ["srx"],
    "application/srgs": ["gram"],
    "application/srgs+xml": ["grxml"],
    "application/sru+xml": ["sru"],
    "application/ssdl+xml": ["ssdl"],
    "application/ssml+xml": ["ssml"],
    "application/tei+xml": ["tei", "teicorpus"],
    "application/thraud+xml": ["tfi"],
    "application/timestamped-data": ["tsd"],
    "application/vnd.3gpp.pic-bw-large": ["plb"],
    "application/vnd.3gpp.pic-bw-small": ["psb"],
    "application/vnd.3gpp.pic-bw-var": ["pvb"],
    "application/vnd.3gpp2.tcap": ["tcap"],
    "application/vnd.3m.post-it-notes": ["pwn"],
    "application/vnd.accpac.simply.aso": ["aso"],
    "application/vnd.accpac.simply.imp": ["imp"],
    "application/vnd.acucobol": ["acu"],
    "application/vnd.acucorp": ["atc", "acutc"],
    "application/vnd.adobe.air-application-installer-package+zip": ["air"],
    "application/vnd.adobe.formscentral.fcdt": ["fcdt"],
    "application/vnd.adobe.fxp": ["fxp", "fxpl"],
    "application/vnd.adobe.xdp+xml": ["xdp"],
    "application/vnd.adobe.xfdf": ["xfdf"],
    "application/vnd.ahead.space": ["ahead"],
    "application/vnd.airzip.filesecure.azf": ["azf"],
    "application/vnd.airzip.filesecure.azs": ["azs"],
    "application/vnd.amazon.ebook": ["azw"],
    "application/vnd.americandynamics.acc": ["acc"],
    "application/vnd.amiga.ami": ["ami"],
    "application/vnd.android.package-archive": ["apk"],
    "application/vnd.anser-web-certificate-issue-initiation": ["cii"],
    "application/vnd.anser-web-funds-transfer-initiation": ["fti"],
    "application/vnd.antix.game-component": ["atx"],
    "application/vnd.apple.installer+xml": ["mpkg"],
    "application/vnd.apple.mpegurl": ["m3u8"],
    "application/vnd.aristanetworks.swi": ["swi"],
    "application/vnd.astraea-software.iota": ["iota"],
    "application/vnd.audiograph": ["aep"],
    "application/vnd.blueice.multipass": ["mpm"],
    "application/vnd.bmi": ["bmi"],
    "application/vnd.businessobjects": ["rep"],
    "application/vnd.chemdraw+xml": ["cdxml"],
    "application/vnd.chipnuts.karaoke-mmd": ["mmd"],
    "application/vnd.cinderella": ["cdy"],
    "application/vnd.claymore": ["cla"],
    "application/vnd.cloanto.rp9": ["rp9"],
    "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"],
    "application/vnd.cluetrust.cartomobile-config": ["c11amc"],
    "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
    "application/vnd.commonspace": ["csp"],
    "application/vnd.contact.cmsg": ["cdbcmsg"],
    "application/vnd.cosmocaller": ["cmc"],
    "application/vnd.crick.clicker": ["clkx"],
    "application/vnd.crick.clicker.keyboard": ["clkk"],
    "application/vnd.crick.clicker.palette": ["clkp"],
    "application/vnd.crick.clicker.template": ["clkt"],
    "application/vnd.crick.clicker.wordbank": ["clkw"],
    "application/vnd.criticaltools.wbs+xml": ["wbs"],
    "application/vnd.ctc-posml": ["pml"],
    "application/vnd.cups-ppd": ["ppd"],
    "application/vnd.curl.car": ["car"],
    "application/vnd.curl.pcurl": ["pcurl"],
    "application/vnd.dart": ["dart"],
    "application/vnd.data-vision.rdz": ["rdz"],
    "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"],
    "application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
    "application/vnd.dece.unspecified": ["uvx", "uvvx"],
    "application/vnd.dece.zip": ["uvz", "uvvz"],
    "application/vnd.denovo.fcselayout-link": ["fe_launch"],
    "application/vnd.dna": ["dna"],
    "application/vnd.dolby.mlp": ["mlp"],
    "application/vnd.dpgraph": ["dpg"],
    "application/vnd.dreamfactory": ["dfac"],
    "application/vnd.ds-keypoint": ["kpxx"],
    "application/vnd.dvb.ait": ["ait"],
    "application/vnd.dvb.service": ["svc"],
    "application/vnd.dynageo": ["geo"],
    "application/vnd.ecowin.chart": ["mag"],
    "application/vnd.enliven": ["nml"],
    "application/vnd.epson.esf": ["esf"],
    "application/vnd.epson.msf": ["msf"],
    "application/vnd.epson.quickanime": ["qam"],
    "application/vnd.epson.salt": ["slt"],
    "application/vnd.epson.ssf": ["ssf"],
    "application/vnd.eszigno3+xml": ["es3", "et3"],
    "application/vnd.ezpix-album": ["ez2"],
    "application/vnd.ezpix-package": ["ez3"],
    "application/vnd.fdf": ["fdf"],
    "application/vnd.fdsn.mseed": ["mseed"],
    "application/vnd.fdsn.seed": ["seed", "dataless"],
    "application/vnd.flographit": ["gph"],
    "application/vnd.fluxtime.clip": ["ftc"],
    "application/vnd.framemaker": ["fm", "frame", "maker", "book"],
    "application/vnd.frogans.fnc": ["fnc"],
    "application/vnd.frogans.ltf": ["ltf"],
    "application/vnd.fsc.weblaunch": ["fsc"],
    "application/vnd.fujitsu.oasys": ["oas"],
    "application/vnd.fujitsu.oasys2": ["oa2"],
    "application/vnd.fujitsu.oasys3": ["oa3"],
    "application/vnd.fujitsu.oasysgp": ["fg5"],
    "application/vnd.fujitsu.oasysprs": ["bh2"],
    "application/vnd.fujixerox.ddd": ["ddd"],
    "application/vnd.fujixerox.docuworks": ["xdw"],
    "application/vnd.fujixerox.docuworks.binder": ["xbd"],
    "application/vnd.fuzzysheet": ["fzs"],
    "application/vnd.genomatix.tuxedo": ["txd"],
    "application/vnd.geogebra.file": ["ggb"],
    "application/vnd.geogebra.tool": ["ggt"],
    "application/vnd.geometry-explorer": ["gex", "gre"],
    "application/vnd.geonext": ["gxt"],
    "application/vnd.geoplan": ["g2w"],
    "application/vnd.geospace": ["g3w"],
    "application/vnd.gmx": ["gmx"],
    "application/vnd.google-earth.kml+xml": ["kml"],
    "application/vnd.google-earth.kmz": ["kmz"],
    "application/vnd.grafeq": ["gqf", "gqs"],
    "application/vnd.groove-account": ["gac"],
    "application/vnd.groove-help": ["ghf"],
    "application/vnd.groove-identity-message": ["gim"],
    "application/vnd.groove-injector": ["grv"],
    "application/vnd.groove-tool-message": ["gtm"],
    "application/vnd.groove-tool-template": ["tpl"],
    "application/vnd.groove-vcard": ["vcg"],
    "application/vnd.hal+xml": ["hal"],
    "application/vnd.handheld-entertainment+xml": ["zmm"],
    "application/vnd.hbci": ["hbci"],
    "application/vnd.hhe.lesson-player": ["les"],
    "application/vnd.hp-hpgl": ["hpgl"],
    "application/vnd.hp-hpid": ["hpid"],
    "application/vnd.hp-hps": ["hps"],
    "application/vnd.hp-jlyt": ["jlt"],
    "application/vnd.hp-pcl": ["pcl"],
    "application/vnd.hp-pclxl": ["pclxl"],
    "application/vnd.ibm.minipay": ["mpy"],
    "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"],
    "application/vnd.ibm.rights-management": ["irm"],
    "application/vnd.ibm.secure-container": ["sc"],
    "application/vnd.iccprofile": ["icc", "icm"],
    "application/vnd.igloader": ["igl"],
    "application/vnd.immervision-ivp": ["ivp"],
    "application/vnd.immervision-ivu": ["ivu"],
    "application/vnd.insors.igm": ["igm"],
    "application/vnd.intercon.formnet": ["xpw", "xpx"],
    "application/vnd.intergeo": ["i2g"],
    "application/vnd.intu.qbo": ["qbo"],
    "application/vnd.intu.qfx": ["qfx"],
    "application/vnd.ipunplugged.rcprofile": ["rcprofile"],
    "application/vnd.irepository.package+xml": ["irp"],
    "application/vnd.is-xpr": ["xpr"],
    "application/vnd.isac.fcs": ["fcs"],
    "application/vnd.jam": ["jam"],
    "application/vnd.jcp.javame.midlet-rms": ["rms"],
    "application/vnd.jisp": ["jisp"],
    "application/vnd.joost.joda-archive": ["joda"],
    "application/vnd.kahootz": ["ktz", "ktr"],
    "application/vnd.kde.karbon": ["karbon"],
    "application/vnd.kde.kchart": ["chrt"],
    "application/vnd.kde.kformula": ["kfo"],
    "application/vnd.kde.kivio": ["flw"],
    "application/vnd.kde.kontour": ["kon"],
    "application/vnd.kde.kpresenter": ["kpr", "kpt"],
    "application/vnd.kde.kspread": ["ksp"],
    "application/vnd.kde.kword": ["kwd", "kwt"],
    "application/vnd.kenameaapp": ["htke"],
    "application/vnd.kidspiration": ["kia"],
    "application/vnd.kinar": ["kne", "knp"],
    "application/vnd.koan": ["skp", "skd", "skt", "skm"],
    "application/vnd.kodak-descriptor": ["sse"],
    "application/vnd.las.las+xml": ["lasxml"],
    "application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
    "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
    "application/vnd.lotus-1-2-3": ["123"],
    "application/vnd.lotus-approach": ["apr"],
    "application/vnd.lotus-freelance": ["pre"],
    "application/vnd.lotus-notes": ["nsf"],
    "application/vnd.lotus-organizer": ["org"],
    "application/vnd.lotus-screencam": ["scm"],
    "application/vnd.lotus-wordpro": ["lwp"],
    "application/vnd.macports.portpkg": ["portpkg"],
    "application/vnd.mcd": ["mcd"],
    "application/vnd.medcalcdata": ["mc1"],
    "application/vnd.mediastation.cdkey": ["cdkey"],
    "application/vnd.mfer": ["mwf"],
    "application/vnd.mfmp": ["mfm"],
    "application/vnd.micrografx.flo": ["flo"],
    "application/vnd.micrografx.igx": ["igx"],
    "application/vnd.mif": ["mif"],
    "application/vnd.mobius.daf": ["daf"],
    "application/vnd.mobius.dis": ["dis"],
    "application/vnd.mobius.mbk": ["mbk"],
    "application/vnd.mobius.mqy": ["mqy"],
    "application/vnd.mobius.msl": ["msl"],
    "application/vnd.mobius.plc": ["plc"],
    "application/vnd.mobius.txf": ["txf"],
    "application/vnd.mophun.application": ["mpn"],
    "application/vnd.mophun.certificate": ["mpc"],
    "application/vnd.mozilla.xul+xml": ["xul"],
    "application/vnd.ms-artgalry": ["cil"],
    "application/vnd.ms-cab-compressed": ["cab"],
    "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
    "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
    "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
    "application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
    "application/vnd.ms-fontobject": ["eot"],
    "application/vnd.ms-htmlhelp": ["chm"],
    "application/vnd.ms-ims": ["ims"],
    "application/vnd.ms-lrm": ["lrm"],
    "application/vnd.ms-officetheme": ["thmx"],
    "application/vnd.ms-pki.seccat": ["cat"],
    "application/vnd.ms-pki.stl": ["stl"],
    "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"],
    "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
    "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
    "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
    "application/vnd.ms-project": ["mpp", "mpt"],
    "application/vnd.ms-word.document.macroenabled.12": ["docm"],
    "application/vnd.ms-word.template.macroenabled.12": ["dotm"],
    "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"],
    "application/vnd.ms-wpl": ["wpl"],
    "application/vnd.ms-xpsdocument": ["xps"],
    "application/vnd.mseq": ["mseq"],
    "application/vnd.musician": ["mus"],
    "application/vnd.muvee.style": ["msty"],
    "application/vnd.mynfc": ["taglet"],
    "application/vnd.neurolanguage.nlu": ["nlu"],
    "application/vnd.nitf": ["ntf", "nitf"],
    "application/vnd.noblenet-directory": ["nnd"],
    "application/vnd.noblenet-sealer": ["nns"],
    "application/vnd.noblenet-web": ["nnw"],
    "application/vnd.nokia.n-gage.data": ["ngdat"],
    "application/vnd.nokia.radio-preset": ["rpst"],
    "application/vnd.nokia.radio-presets": ["rpss"],
    "application/vnd.novadigm.edm": ["edm"],
    "application/vnd.novadigm.edx": ["edx"],
    "application/vnd.novadigm.ext": ["ext"],
    "application/vnd.oasis.opendocument.chart": ["odc"],
    "application/vnd.oasis.opendocument.chart-template": ["otc"],
    "application/vnd.oasis.opendocument.database": ["odb"],
    "application/vnd.oasis.opendocument.formula": ["odf"],
    "application/vnd.oasis.opendocument.formula-template": ["odft"],
    "application/vnd.oasis.opendocument.graphics": ["odg"],
    "application/vnd.oasis.opendocument.graphics-template": ["otg"],
    "application/vnd.oasis.opendocument.image": ["odi"],
    "application/vnd.oasis.opendocument.image-template": ["oti"],
    "application/vnd.oasis.opendocument.presentation": ["odp"],
    "application/vnd.oasis.opendocument.presentation-template": ["otp"],
    "application/vnd.oasis.opendocument.spreadsheet": ["ods"],
    "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
    "application/vnd.oasis.opendocument.text": ["odt"],
    "application/vnd.oasis.opendocument.text-master": ["odm"],
    "application/vnd.oasis.opendocument.text-template": ["ott"],
    "application/vnd.oasis.opendocument.text-web": ["oth"],
    "application/vnd.olpc-sugar": ["xo"],
    "application/vnd.oma.dd2+xml": ["dd2"],
    "application/vnd.openofficeorg.extension": ["oxt"],
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"],
    "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"],
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"],
    "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"],
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"],
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"],
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"],
    "application/vnd.osgeo.mapguide.package": ["mgp"],
    "application/vnd.osgi.dp": ["dp"],
    "application/vnd.osgi.subsystem": ["esa"],
    "application/vnd.palm": ["pdb", "pqa", "oprc"],
    "application/vnd.pawaafile": ["paw"],
    "application/vnd.pg.format": ["str"],
    "application/vnd.pg.osasli": ["ei6"],
    "application/vnd.picsel": ["efif"],
    "application/vnd.pmi.widget": ["wg"],
    "application/vnd.pocketlearn": ["plf"],
    "application/vnd.powerbuilder6": ["pbd"],
    "application/vnd.previewsystems.box": ["box"],
    "application/vnd.proteus.magazine": ["mgz"],
    "application/vnd.publishare-delta-tree": ["qps"],
    "application/vnd.pvi.ptid1": ["ptid"],
    "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
    "application/vnd.realvnc.bed": ["bed"],
    "application/vnd.recordare.musicxml": ["mxl"],
    "application/vnd.recordare.musicxml+xml": ["musicxml"],
    "application/vnd.rig.cryptonote": ["cryptonote"],
    "application/vnd.rim.cod": ["cod"],
    "application/vnd.rn-realmedia": ["rm"],
    "application/vnd.rn-realmedia-vbr": ["rmvb"],
    "application/vnd.route66.link66+xml": ["link66"],
    "application/vnd.sailingtracker.track": ["st"],
    "application/vnd.seemail": ["see"],
    "application/vnd.sema": ["sema"],
    "application/vnd.semd": ["semd"],
    "application/vnd.semf": ["semf"],
    "application/vnd.shana.informed.formdata": ["ifm"],
    "application/vnd.shana.informed.formtemplate": ["itp"],
    "application/vnd.shana.informed.interchange": ["iif"],
    "application/vnd.shana.informed.package": ["ipk"],
    "application/vnd.simtech-mindmapper": ["twd", "twds"],
    "application/vnd.smaf": ["mmf"],
    "application/vnd.smart.teacher": ["teacher"],
    "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
    "application/vnd.spotfire.dxp": ["dxp"],
    "application/vnd.spotfire.sfs": ["sfs"],
    "application/vnd.stardivision.calc": ["sdc"],
    "application/vnd.stardivision.draw": ["sda"],
    "application/vnd.stardivision.impress": ["sdd"],
    "application/vnd.stardivision.math": ["smf"],
    "application/vnd.stardivision.writer": ["sdw", "vor"],
    "application/vnd.stardivision.writer-global": ["sgl"],
    "application/vnd.stepmania.package": ["smzip"],
    "application/vnd.stepmania.stepchart": ["sm"],
    "application/vnd.sun.xml.calc": ["sxc"],
    "application/vnd.sun.xml.calc.template": ["stc"],
    "application/vnd.sun.xml.draw": ["sxd"],
    "application/vnd.sun.xml.draw.template": ["std"],
    "application/vnd.sun.xml.impress": ["sxi"],
    "application/vnd.sun.xml.impress.template": ["sti"],
    "application/vnd.sun.xml.math": ["sxm"],
    "application/vnd.sun.xml.writer": ["sxw"],
    "application/vnd.sun.xml.writer.global": ["sxg"],
    "application/vnd.sun.xml.writer.template": ["stw"],
    "application/vnd.sus-calendar": ["sus", "susp"],
    "application/vnd.svd": ["svd"],
    "application/vnd.symbian.install": ["sis", "sisx"],
    "application/vnd.syncml+xml": ["xsm"],
    "application/vnd.syncml.dm+wbxml": ["bdm"],
    "application/vnd.syncml.dm+xml": ["xdm"],
    "application/vnd.tao.intent-module-archive": ["tao"],
    "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"],
    "application/vnd.tmobile-livetv": ["tmo"],
    "application/vnd.trid.tpt": ["tpt"],
    "application/vnd.triscape.mxs": ["mxs"],
    "application/vnd.trueapp": ["tra"],
    "application/vnd.ufdl": ["ufd", "ufdl"],
    "application/vnd.uiq.theme": ["utz"],
    "application/vnd.umajin": ["umj"],
    "application/vnd.unity": ["unityweb"],
    "application/vnd.uoml+xml": ["uoml"],
    "application/vnd.vcx": ["vcx"],
    "application/vnd.visio": ["vsd", "vst", "vss", "vsw"],
    "application/vnd.visionary": ["vis"],
    "application/vnd.vsf": ["vsf"],
    "application/vnd.wap.wbxml": ["wbxml"],
    "application/vnd.wap.wmlc": ["wmlc"],
    "application/vnd.wap.wmlscriptc": ["wmlsc"],
    "application/vnd.webturbo": ["wtb"],
    "application/vnd.wolfram.player": ["nbp"],
    "application/vnd.wordperfect": ["wpd"],
    "application/vnd.wqd": ["wqd"],
    "application/vnd.wt.stf": ["stf"],
    "application/vnd.xara": ["xar"],
    "application/vnd.xfdl": ["xfdl"],
    "application/vnd.yamaha.hv-dic": ["hvd"],
    "application/vnd.yamaha.hv-script": ["hvs"],
    "application/vnd.yamaha.hv-voice": ["hvp"],
    "application/vnd.yamaha.openscoreformat": ["osf"],
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
    "application/vnd.yamaha.smaf-audio": ["saf"],
    "application/vnd.yamaha.smaf-phrase": ["spf"],
    "application/vnd.yellowriver-custom-menu": ["cmp"],
    "application/vnd.zul": ["zir", "zirz"],
    "application/vnd.zzazz.deck+xml": ["zaz"],
    "application/voicexml+xml": ["vxml"],
    "application/widget": ["wgt"],
    "application/winhlp": ["hlp"],
    "application/wsdl+xml": ["wsdl"],
    "application/wspolicy+xml": ["wspolicy"],
    "application/x-7z-compressed": ["7z"],
    "application/x-abiword": ["abw"],
    "application/x-ace-compressed": ["ace"],
    "application/x-apple-diskimage": ["dmg"],
    "application/x-authorware-bin": ["aab", "x32", "u32", "vox"],
    "application/x-authorware-map": ["aam"],
    "application/x-authorware-seg": ["aas"],
    "application/x-bcpio": ["bcpio"],
    "application/x-bittorrent": ["torrent"],
    "application/x-blorb": ["blb", "blorb"],
    "application/x-bzip": ["bz"],
    "application/x-bzip2": ["bz2", "boz"],
    "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"],
    "application/x-cdlink": ["vcd"],
    "application/x-cfs-compressed": ["cfs"],
    "application/x-chat": ["chat"],
    "application/x-chess-pgn": ["pgn"],
    "application/x-chrome-extension": ["crx"],
    "application/x-conference": ["nsc"],
    "application/x-cpio": ["cpio"],
    "application/x-csh": ["csh"],
    "application/x-debian-package": ["deb", "udeb"],
    "application/x-dgc-compressed": ["dgc"],
    "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
    "application/x-doom": ["wad"],
    "application/x-dtbncx+xml": ["ncx"],
    "application/x-dtbook+xml": ["dtb"],
    "application/x-dtbresource+xml": ["res"],
    "application/x-dvi": ["dvi"],
    "application/x-envoy": ["evy"],
    "application/x-eva": ["eva"],
    "application/x-font-bdf": ["bdf"],
    "application/x-font-ghostscript": ["gsf"],
    "application/x-font-linux-psf": ["psf"],
    "application/x-font-otf": ["otf"],
    "application/x-font-pcf": ["pcf"],
    "application/x-font-snf": ["snf"],
    "application/x-font-ttf": ["ttf", "ttc"],
    "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"],
    "application/x-freearc": ["arc"],
    "application/x-futuresplash": ["spl"],
    "application/x-gca-compressed": ["gca"],
    "application/x-glulx": ["ulx"],
    "application/x-gnumeric": ["gnumeric"],
    "application/x-gramps-xml": ["gramps"],
    "application/x-gtar": ["gtar"],
    "application/x-hdf": ["hdf"],
    "application/x-install-instructions": ["install"],
    "application/x-iso9660-image": ["iso"],
    "application/x-java-jnlp-file": ["jnlp"],
    "application/x-latex": ["latex"],
    "application/x-lua-bytecode": ["luac"],
    "application/x-lzh-compressed": ["lzh", "lha"],
    "application/x-mie": ["mie"],
    "application/x-mobipocket-ebook": ["prc", "mobi"],
    "application/x-ms-application": ["application"],
    "application/x-ms-shortcut": ["lnk"],
    "application/x-ms-wmd": ["wmd"],
    "application/x-ms-wmz": ["wmz"],
    "application/x-ms-xbap": ["xbap"],
    "application/x-msaccess": ["mdb"],
    "application/x-msbinder": ["obd"],
    "application/x-mscardfile": ["crd"],
    "application/x-msclip": ["clp"],
    "application/x-msdownload": ["exe", "dll", "com", "bat", "msi"],
    "application/x-msmediaview": ["mvb", "m13", "m14"],
    "application/x-msmetafile": ["wmf", "wmz", "emf", "emz"],
    "application/x-msmoney": ["mny"],
    "application/x-mspublisher": ["pub"],
    "application/x-msschedule": ["scd"],
    "application/x-msterminal": ["trm"],
    "application/x-mswrite": ["wri"],
    "application/x-netcdf": ["nc", "cdf"],
    "application/x-nzb": ["nzb"],
    "application/x-pkcs12": ["p12", "pfx"],
    "application/x-pkcs7-certificates": ["p7b", "spc"],
    "application/x-pkcs7-certreqresp": ["p7r"],
    "application/x-rar-compressed": ["rar"],
    "application/x-research-info-systems": ["ris"],
    "application/x-sh": ["sh"],
    "application/x-shar": ["shar"],
    "application/x-shockwave-flash": ["swf"],
    "application/x-silverlight-app": ["xap"],
    "application/x-sql": ["sql"],
    "application/x-stuffit": ["sit"],
    "application/x-stuffitx": ["sitx"],
    "application/x-subrip": ["srt"],
    "application/x-sv4cpio": ["sv4cpio"],
    "application/x-sv4crc": ["sv4crc"],
    "application/x-t3vm-image": ["t3"],
    "application/x-tads": ["gam"],
    "application/x-tar": ["tar"],
    "application/x-tcl": ["tcl"],
    "application/x-tex": ["tex"],
    "application/x-tex-tfm": ["tfm"],
    "application/x-texinfo": ["texinfo", "texi"],
    "application/x-tgif": ["obj"],
    "application/x-ustar": ["ustar"],
    "application/x-wais-source": ["src"],
    "application/x-web-app-manifest+json": ["webapp"],
    "application/x-x509-ca-cert": ["der", "crt"],
    "application/x-xfig": ["fig"],
    "application/x-xliff+xml": ["xlf"],
    "application/x-xpinstall": ["xpi"],
    "application/x-xz": ["xz"],
    "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
    "application/xaml+xml": ["xaml"],
    "application/xcap-diff+xml": ["xdf"],
    "application/xenc+xml": ["xenc"],
    "application/xhtml+xml": ["xhtml", "xht"],
    "application/xml": ["xml", "xsl", "xsd"],
    "application/xml-dtd": ["dtd"],
    "application/xop+xml": ["xop"],
    "application/xproc+xml": ["xpl"],
    "application/xslt+xml": ["xslt"],
    "application/xspf+xml": ["xspf"],
    "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
    "application/yang": ["yang"],
    "application/yin+xml": ["yin"],
    "application/zip": ["zip"],
    "audio/adpcm": ["adp"],
    "audio/basic": ["au", "snd"],
    "audio/midi": ["mid", "midi", "kar", "rmi"],
    "audio/mp4": ["mp4a", "m4a"],
    "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
    "audio/ogg": ["oga", "ogg", "spx"],
    "audio/s3m": ["s3m"],
    "audio/silk": ["sil"],
    "audio/vnd.dece.audio": ["uva", "uvva"],
    "audio/vnd.digital-winds": ["eol"],
    "audio/vnd.dra": ["dra"],
    "audio/vnd.dts": ["dts"],
    "audio/vnd.dts.hd": ["dtshd"],
    "audio/vnd.lucent.voice": ["lvp"],
    "audio/vnd.ms-playready.media.pya": ["pya"],
    "audio/vnd.nuera.ecelp4800": ["ecelp4800"],
    "audio/vnd.nuera.ecelp7470": ["ecelp7470"],
    "audio/vnd.nuera.ecelp9600": ["ecelp9600"],
    "audio/vnd.rip": ["rip"],
    "audio/webm": ["weba"],
    "audio/x-aac": ["aac"],
    "audio/x-aiff": ["aif", "aiff", "aifc"],
    "audio/x-caf": ["caf"],
    "audio/x-flac": ["flac"],
    "audio/x-matroska": ["mka"],
    "audio/x-mpegurl": ["m3u"],
    "audio/x-ms-wax": ["wax"],
    "audio/x-ms-wma": ["wma"],
    "audio/x-pn-realaudio": ["ram", "ra"],
    "audio/x-pn-realaudio-plugin": ["rmp"],
    "audio/x-wav": ["wav"],
    "audio/xm": ["xm"],
    "chemical/x-cdx": ["cdx"],
    "chemical/x-cif": ["cif"],
    "chemical/x-cmdf": ["cmdf"],
    "chemical/x-cml": ["cml"],
    "chemical/x-csml": ["csml"],
    "chemical/x-xyz": ["xyz"],
    "font/opentype": ["otf"],
    "image/bmp": ["bmp"],
    "image/cgm": ["cgm"],
    "image/g3fax": ["g3"],
    "image/gif": ["gif"],
    "image/ief": ["ief"],
    "image/jpeg": ["jpeg", "jpg", "jpe"],
    "image/ktx": ["ktx"],
    "image/png": ["png"],
    "image/prs.btif": ["btif"],
    "image/sgi": ["sgi"],
    "image/svg+xml": ["svg", "svgz"],
    "image/tiff": ["tiff", "tif"],
    "image/vnd.adobe.photoshop": ["psd"],
    "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"],
    "image/vnd.djvu": ["djvu", "djv"],
    "image/vnd.dvb.subtitle": ["sub"],
    "image/vnd.dwg": ["dwg"],
    "image/vnd.dxf": ["dxf"],
    "image/vnd.fastbidsheet": ["fbs"],
    "image/vnd.fpx": ["fpx"],
    "image/vnd.fst": ["fst"],
    "image/vnd.fujixerox.edmics-mmr": ["mmr"],
    "image/vnd.fujixerox.edmics-rlc": ["rlc"],
    "image/vnd.ms-modi": ["mdi"],
    "image/vnd.ms-photo": ["wdp"],
    "image/vnd.net-fpx": ["npx"],
    "image/vnd.wap.wbmp": ["wbmp"],
    "image/vnd.xiff": ["xif"],
    "image/webp": ["webp"],
    "image/x-3ds": ["3ds"],
    "image/x-cmu-raster": ["ras"],
    "image/x-cmx": ["cmx"],
    "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"],
    "image/x-icon": ["ico"],
    "image/x-mrsid-image": ["sid"],
    "image/x-pcx": ["pcx"],
    "image/x-pict": ["pic", "pct"],
    "image/x-portable-anymap": ["pnm"],
    "image/x-portable-bitmap": ["pbm"],
    "image/x-portable-graymap": ["pgm"],
    "image/x-portable-pixmap": ["ppm"],
    "image/x-rgb": ["rgb"],
    "image/x-tga": ["tga"],
    "image/x-xbitmap": ["xbm"],
    "image/x-xpixmap": ["xpm"],
    "image/x-xwindowdump": ["xwd"],
    "message/rfc822": ["eml", "mime"],
    "model/iges": ["igs", "iges"],
    "model/mesh": ["msh", "mesh", "silo"],
    "model/vnd.collada+xml": ["dae"],
    "model/vnd.dwf": ["dwf"],
    "model/vnd.gdl": ["gdl"],
    "model/vnd.gtw": ["gtw"],
    "model/vnd.mts": ["mts"],
    "model/vnd.vtu": ["vtu"],
    "model/vrml": ["wrl", "vrml"],
    "model/x3d+binary": ["x3db", "x3dbz"],
    "model/x3d+vrml": ["x3dv", "x3dvz"],
    "model/x3d+xml": ["x3d", "x3dz"],
    "text/cache-manifest": ["appcache", "manifest"],
    "text/calendar": ["ics", "ifb"],
    "text/coffeescript": ["coffee"],
    "text/css": ["css"],
    "text/csv": ["csv"],
    "text/hjson": ["hjson"],
    "text/html": ["html", "htm"],
    "text/jade": ["jade"],
    "text/jsx": ["jsx"],
    "text/less": ["less"],
    "text/n3": ["n3"],
    "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
    "text/prs.lines.tag": ["dsc"],
    "text/richtext": ["rtx"],
    "text/sgml": ["sgml", "sgm"],
    "text/stylus": ["stylus", "styl"],
    "text/tab-separated-values": ["tsv"],
    "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
    "text/turtle": ["ttl"],
    "text/uri-list": ["uri", "uris", "urls"],
    "text/vcard": ["vcard"],
    "text/vnd.curl": ["curl"],
    "text/vnd.curl.dcurl": ["dcurl"],
    "text/vnd.curl.mcurl": ["mcurl"],
    "text/vnd.curl.scurl": ["scurl"],
    "text/vnd.dvb.subtitle": ["sub"],
    "text/vnd.fly": ["fly"],
    "text/vnd.fmi.flexstor": ["flx"],
    "text/vnd.graphviz": ["gv"],
    "text/vnd.in3d.3dml": ["3dml"],
    "text/vnd.in3d.spot": ["spot"],
    "text/vnd.sun.j2me.app-descriptor": ["jad"],
    "text/vnd.wap.wml": ["wml"],
    "text/vnd.wap.wmlscript": ["wmls"],
    "text/vtt": ["vtt"],
    "text/x-asm": ["s", "asm"],
    "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
    "text/x-component": ["htc"],
    "text/x-fortran": ["f", "for", "f77", "f90"],
    "text/x-handlebars-template": ["hbs"],
    "text/x-java-source": ["java"],
    "text/x-lua": ["lua"],
    "text/x-markdown": ["markdown", "md", "mkd"],
    "text/x-nfo": ["nfo"],
    "text/x-opml": ["opml"],
    "text/x-pascal": ["p", "pas"],
    "text/x-sass": ["sass"],
    "text/x-scss": ["scss"],
    "text/x-setext": ["etx"],
    "text/x-sfv": ["sfv"],
    "text/x-uuencode": ["uu"],
    "text/x-vcalendar": ["vcs"],
    "text/x-vcard": ["vcf"],
    "text/yaml": ["yaml", "yml"],
    "video/3gpp": ["3gp"],
    "video/3gpp2": ["3g2"],
    "video/h261": ["h261"],
    "video/h263": ["h263"],
    "video/h264": ["h264"],
    "video/jpeg": ["jpgv"],
    "video/jpm": ["jpm", "jpgm"],
    "video/mj2": ["mj2", "mjp2"],
    "video/mp2t": ["ts"],
    "video/mp4": ["mp4", "mp4v", "mpg4"],
    "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
    "video/ogg": ["ogv"],
    "video/quicktime": ["qt", "mov"],
    "video/vnd.dece.hd": ["uvh", "uvvh"],
    "video/vnd.dece.mobile": ["uvm", "uvvm"],
    "video/vnd.dece.pd": ["uvp", "uvvp"],
    "video/vnd.dece.sd": ["uvs", "uvvs"],
    "video/vnd.dece.video": ["uvv", "uvvv"],
    "video/vnd.dvb.file": ["dvb"],
    "video/vnd.fvt": ["fvt"],
    "video/vnd.mpegurl": ["mxu", "m4u"],
    "video/vnd.ms-playready.media.pyv": ["pyv"],
    "video/vnd.uvvu.mp4": ["uvu", "uvvu"],
    "video/vnd.vivo": ["viv"],
    "video/webm": ["webm"],
    "video/x-f4v": ["f4v"],
    "video/x-fli": ["fli"],
    "video/x-flv": ["flv"],
    "video/x-m4v": ["m4v"],
    "video/x-matroska": ["mkv", "mk3d", "mks"],
    "video/x-mng": ["mng"],
    "video/x-ms-asf": ["asf", "asx"],
    "video/x-ms-vob": ["vob"],
    "video/x-ms-wm": ["wm"],
    "video/x-ms-wmv": ["wmv"],
    "video/x-ms-wmx": ["wmx"],
    "video/x-ms-wvx": ["wvx"],
    "video/x-msvideo": ["avi"],
    "video/x-sgi-movie": ["movie"],
    "video/x-smv": ["smv"],
    "x-conference/x-cooltalk": ["ice"]
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14e", ["139", "e1", "14d", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var path = $__require('139');
    var fs = $__require('e1');
    function Mime() {
      this.types = Object.create(null);
      this.extensions = Object.create(null);
    }
    Mime.prototype.define = function(map) {
      for (var type in map) {
        var exts = map[type];
        for (var i = 0; i < exts.length; i++) {
          if (process.env.DEBUG_MIME && this.types[exts]) {
            console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' + this.types[exts] + ' to ' + type);
          }
          this.types[exts[i]] = type;
        }
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    Mime.prototype.load = function(file) {
      this._loading = file;
      var map = {},
          content = fs.readFileSync(file, 'ascii'),
          lines = content.split(/[\r\n]+/);
      lines.forEach(function(line) {
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
        map[fields.shift()] = fields;
      });
      this.define(map);
      this._loading = null;
    };
    Mime.prototype.lookup = function(path, fallback) {
      var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();
      return this.types[ext] || fallback || this.default_type;
    };
    Mime.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    var mime = new Mime();
    mime.define($__require('14d'));
    mime.default_type = mime.lookup('bin');
    mime.Mime = Mime;
    mime.charsets = {lookup: function(mimeType, fallback) {
        return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
      }};
    module.exports = mime;
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d0", ["14e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('14e');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14f", ["e1", "139", "148", "5a", "d0", "69"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var fs = $__require('e1');
  var path = $__require('139');
  var escapeRE = $__require('148');
  var assert = $__require('5a');
  var mime = $__require('d0');
  var errors = $__require('69');
  var MethodNotAllowedError = errors.MethodNotAllowedError;
  var NotAuthorizedError = errors.NotAuthorizedError;
  var ResourceNotFoundError = errors.ResourceNotFoundError;
  function serveStatic(options) {
    var opts = options || {};
    assert.object(opts, 'options');
    assert.string(opts.directory, 'options.directory');
    assert.optionalNumber(opts.maxAge, 'options.maxAge');
    assert.optionalObject(opts.match, 'options.match');
    assert.optionalString(opts.charSet, 'options.charSet');
    assert.optionalString(opts.file, 'options.file');
    var p = path.normalize(opts.directory).replace(/\\/g, '/');
    var re = new RegExp('^' + escapeRE(p) + '/?.*');
    function serveFileFromStats(file, err, stats, isGzip, req, res, next) {
      if (err) {
        next(new ResourceNotFoundError(err, '%s', req.path()));
        return;
      } else if (!stats.isFile()) {
        next(new ResourceNotFoundError('%s does not exist', req.path()));
        return;
      }
      if (res.handledGzip && isGzip) {
        res.handledGzip();
      }
      var fstream = fs.createReadStream(file + (isGzip ? '.gz' : ''));
      var maxAge = opts.maxAge === undefined ? 3600 : opts.maxAge;
      fstream.once('open', function(fd) {
        res.cache({maxAge: maxAge});
        res.set('Content-Length', stats.size);
        res.set('Content-Type', mime.lookup(file));
        res.set('Last-Modified', stats.mtime);
        if (opts.charSet) {
          var type = res.getHeader('Content-Type') + '; charset=' + opts.charSet;
          res.setHeader('Content-Type', type);
        }
        if (opts.etag) {
          res.set('ETag', opts.etag(stats, opts));
        }
        res.writeHead(200);
        fstream.pipe(res);
        fstream.once('end', function() {
          next(false);
        });
      });
    }
    function serveNormal(file, req, res, next) {
      fs.stat(file, function(err, stats) {
        if (!err && stats.isDirectory() && opts.default) {
          var filePath = path.join(file, opts.default);
          fs.stat(filePath, function(dirErr, dirStats) {
            serveFileFromStats(filePath, dirErr, dirStats, false, req, res, next);
          });
        } else {
          serveFileFromStats(file, err, stats, false, req, res, next);
        }
      });
    }
    function serve(req, res, next) {
      var file;
      if (opts.file) {
        file = path.join(opts.directory, decodeURIComponent(opts.file));
      } else {
        file = path.join(opts.directory, decodeURIComponent(req.path()));
      }
      if (req.method !== 'GET' && req.method !== 'HEAD') {
        next(new MethodNotAllowedError(req.method));
        return;
      }
      if (!re.test(file.replace(/\\/g, '/'))) {
        next(new NotAuthorizedError('%s', req.path()));
        return;
      }
      if (opts.match && !opts.match.test(file)) {
        next(new NotAuthorizedError('%s', req.path()));
        return;
      }
      if (opts.gzip && req.acceptsEncoding('gzip')) {
        fs.stat(file + '.gz', function(err, stats) {
          if (!err) {
            res.setHeader('Content-Encoding', 'gzip');
            serveFileFromStats(file, err, stats, true, req, res, next);
          } else {
            serveNormal(file, req, res, next);
          }
        });
      } else {
        serveNormal(file, req, res, next);
      }
    }
    return (serve);
  }
  module.exports = serveStatic;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("150", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  ;
  (function() {
    if (typeof module === 'object' && module.exports) {
      module.exports = LRUCache;
    } else {
      this.LRUCache = LRUCache;
    }
    function hOP(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    function naiveLength() {
      return 1;
    }
    var didTypeWarning = false;
    function typeCheckKey(key) {
      if (!didTypeWarning && typeof key !== 'string' && typeof key !== 'number') {
        didTypeWarning = true;
        console.error(new TypeError("LRU: key must be a string or number. Almost certainly a bug! " + typeof key).stack);
      }
    }
    function LRUCache(options) {
      if (!(this instanceof LRUCache))
        return new LRUCache(options);
      if (typeof options === 'number')
        options = {max: options};
      if (!options)
        options = {};
      this._max = options.max;
      if (!this._max || !(typeof this._max === "number") || this._max <= 0)
        this._max = Infinity;
      this._lengthCalculator = options.length || naiveLength;
      if (typeof this._lengthCalculator !== "function")
        this._lengthCalculator = naiveLength;
      this._allowStale = options.stale || false;
      this._maxAge = options.maxAge || null;
      this._dispose = options.dispose;
      this.reset();
    }
    Object.defineProperty(LRUCache.prototype, "max", {
      set: function(mL) {
        if (!mL || !(typeof mL === "number") || mL <= 0)
          mL = Infinity;
        this._max = mL;
        if (this._length > this._max)
          trim(this);
      },
      get: function() {
        return this._max;
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
      set: function(lC) {
        if (typeof lC !== "function") {
          this._lengthCalculator = naiveLength;
          this._length = this._itemCount;
          for (var key in this._cache) {
            this._cache[key].length = 1;
          }
        } else {
          this._lengthCalculator = lC;
          this._length = 0;
          for (var key in this._cache) {
            this._cache[key].length = this._lengthCalculator(this._cache[key].value);
            this._length += this._cache[key].length;
          }
        }
        if (this._length > this._max)
          trim(this);
      },
      get: function() {
        return this._lengthCalculator;
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "length", {
      get: function() {
        return this._length;
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "itemCount", {
      get: function() {
        return this._itemCount;
      },
      enumerable: true
    });
    LRUCache.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      var i = 0;
      var itemCount = this._itemCount;
      for (var k = this._mru - 1; k >= 0 && i < itemCount; k--)
        if (this._lruList[k]) {
          i++;
          var hit = this._lruList[k];
          if (isStale(this, hit)) {
            del(this, hit);
            if (!this._allowStale)
              hit = undefined;
          }
          if (hit) {
            fn.call(thisp, hit.value, hit.key, this);
          }
        }
    };
    LRUCache.prototype.keys = function() {
      var keys = new Array(this._itemCount);
      var i = 0;
      for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
        if (this._lruList[k]) {
          var hit = this._lruList[k];
          keys[i++] = hit.key;
        }
      return keys;
    };
    LRUCache.prototype.values = function() {
      var values = new Array(this._itemCount);
      var i = 0;
      for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
        if (this._lruList[k]) {
          var hit = this._lruList[k];
          values[i++] = hit.value;
        }
      return values;
    };
    LRUCache.prototype.reset = function() {
      if (this._dispose && this._cache) {
        for (var k in this._cache) {
          this._dispose(k, this._cache[k].value);
        }
      }
      this._cache = Object.create(null);
      this._lruList = Object.create(null);
      this._mru = 0;
      this._lru = 0;
      this._length = 0;
      this._itemCount = 0;
    };
    LRUCache.prototype.dump = function() {
      var arr = [];
      var i = 0;
      for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
        if (this._lruList[k]) {
          var hit = this._lruList[k];
          if (!isStale(this, hit)) {
            ++i;
            arr.push({
              k: hit.key,
              v: hit.value,
              e: hit.now + (hit.maxAge || 0)
            });
          }
        }
      return arr;
    };
    LRUCache.prototype.dumpLru = function() {
      return this._lruList;
    };
    LRUCache.prototype.set = function(key, value, maxAge) {
      maxAge = maxAge || this._maxAge;
      typeCheckKey(key);
      var now = maxAge ? Date.now() : 0;
      var len = this._lengthCalculator(value);
      if (hOP(this._cache, key)) {
        if (len > this._max) {
          del(this, this._cache[key]);
          return false;
        }
        if (this._dispose)
          this._dispose(key, this._cache[key].value);
        this._cache[key].now = now;
        this._cache[key].maxAge = maxAge;
        this._cache[key].value = value;
        this._length += (len - this._cache[key].length);
        this._cache[key].length = len;
        this.get(key);
        if (this._length > this._max)
          trim(this);
        return true;
      }
      var hit = new Entry(key, value, this._mru++, len, now, maxAge);
      if (hit.length > this._max) {
        if (this._dispose)
          this._dispose(key, value);
        return false;
      }
      this._length += hit.length;
      this._lruList[hit.lu] = this._cache[key] = hit;
      this._itemCount++;
      if (this._length > this._max)
        trim(this);
      return true;
    };
    LRUCache.prototype.has = function(key) {
      typeCheckKey(key);
      if (!hOP(this._cache, key))
        return false;
      var hit = this._cache[key];
      if (isStale(this, hit)) {
        return false;
      }
      return true;
    };
    LRUCache.prototype.get = function(key) {
      typeCheckKey(key);
      return get(this, key, true);
    };
    LRUCache.prototype.peek = function(key) {
      typeCheckKey(key);
      return get(this, key, false);
    };
    LRUCache.prototype.pop = function() {
      var hit = this._lruList[this._lru];
      del(this, hit);
      return hit || null;
    };
    LRUCache.prototype.del = function(key) {
      typeCheckKey(key);
      del(this, this._cache[key]);
    };
    LRUCache.prototype.load = function(arr) {
      this.reset();
      var now = Date.now();
      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        typeCheckKey(hit.k);
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) {
          this.set(hit.k, hit.v);
        } else {
          var maxAge = expiresAt - now;
          if (maxAge > 0)
            this.set(hit.k, hit.v, maxAge);
        }
      }
    };
    function get(self, key, doUse) {
      typeCheckKey(key);
      var hit = self._cache[key];
      if (hit) {
        if (isStale(self, hit)) {
          del(self, hit);
          if (!self._allowStale)
            hit = undefined;
        } else {
          if (doUse)
            use(self, hit);
        }
        if (hit)
          hit = hit.value;
      }
      return hit;
    }
    function isStale(self, hit) {
      if (!hit || (!hit.maxAge && !self._maxAge))
        return false;
      var stale = false;
      var diff = Date.now() - hit.now;
      if (hit.maxAge) {
        stale = diff > hit.maxAge;
      } else {
        stale = self._maxAge && (diff > self._maxAge);
      }
      return stale;
    }
    function use(self, hit) {
      shiftLU(self, hit);
      hit.lu = self._mru++;
      self._lruList[hit.lu] = hit;
    }
    function trim(self) {
      while (self._lru < self._mru && self._length > self._max)
        del(self, self._lruList[self._lru]);
    }
    function shiftLU(self, hit) {
      delete self._lruList[hit.lu];
      while (self._lru < self._mru && !self._lruList[self._lru])
        self._lru++;
    }
    function del(self, hit) {
      if (hit) {
        if (self._dispose)
          self._dispose(hit.key, hit.value);
        self._length -= hit.length;
        self._itemCount--;
        delete self._cache[hit.key];
        shiftLU(self, hit);
      }
    }
    function Entry(key, value, lu, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.lu = lu;
      this.length = length;
      this.now = now;
      if (maxAge)
        this.maxAge = maxAge;
    }
  })();
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("151", ["150"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('150');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("152", ["7d", "59", "155", "153", "154"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var http = $__require('7d');
  var util = $__require('59');
  var _ = $__require('155');
  var helpers = $__require('153');
  var HttpError = $__require('154');
  var httpErrors = _.reduce(http.STATUS_CODES, function(acc, desc, code) {
    var parsedCode = parseInt(code, 10);
    if (parsedCode >= 400) {
      var name = helpers.errNameFromDesc(desc);
      acc[name] = function() {
        HttpError.apply(this, arguments);
      };
      util.inherits(acc[name], HttpError);
      acc[name].displayName = name;
      acc[name].prototype.name = name;
      acc[name].prototype.statusCode = parsedCode;
    }
    return acc;
  }, {});
  module.exports = httpErrors;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("156", ["71", "59", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var mod_assert = $__require('71');
    var mod_util = $__require('59');
    exports.sprintf = jsSprintf;
    exports.printf = jsPrintf;
    function jsSprintf(fmt) {
      var regex = ['([^%]*)', '%', '([\'\\-+ #0]*?)', '([1-9]\\d*)?', '(\\.([1-9]\\d*))?', '[lhjztL]*?', '([diouxXfFeEgGaAcCsSp%jr])'].join('');
      var re = new RegExp(regex);
      var args = Array.prototype.slice.call(arguments, 1);
      var flags,
          width,
          precision,
          conversion;
      var left,
          pad,
          sign,
          arg,
          match;
      var ret = '';
      var argn = 1;
      mod_assert.equal('string', typeof(fmt));
      while ((match = re.exec(fmt)) !== null) {
        ret += match[1];
        fmt = fmt.substring(match[0].length);
        flags = match[2] || '';
        width = match[3] || 0;
        precision = match[4] || '';
        conversion = match[6];
        left = false;
        sign = false;
        pad = ' ';
        if (conversion == '%') {
          ret += '%';
          continue;
        }
        if (args.length === 0)
          throw (new Error('too few args to sprintf'));
        arg = args.shift();
        argn++;
        if (flags.match(/[\' #]/))
          throw (new Error('unsupported flags: ' + flags));
        if (precision.length > 0)
          throw (new Error('non-zero precision not supported'));
        if (flags.match(/-/))
          left = true;
        if (flags.match(/0/))
          pad = '0';
        if (flags.match(/\+/))
          sign = true;
        switch (conversion) {
          case 's':
            if (arg === undefined || arg === null)
              throw (new Error('argument ' + argn + ': attempted to print undefined or null ' + 'as a string'));
            ret += doPad(pad, width, left, arg.toString());
            break;
          case 'd':
            arg = Math.floor(arg);
          case 'f':
            sign = sign && arg > 0 ? '+' : '';
            ret += sign + doPad(pad, width, left, arg.toString());
            break;
          case 'x':
            ret += doPad(pad, width, left, arg.toString(16));
            break;
          case 'j':
            if (width === 0)
              width = 10;
            ret += mod_util.inspect(arg, false, width);
            break;
          case 'r':
            ret += dumpException(arg);
            break;
          default:
            throw (new Error('unsupported conversion: ' + conversion));
        }
      }
      ret += fmt;
      return (ret);
    }
    function jsPrintf() {
      process.stdout.write(jsSprintf.apply(this, arguments));
    }
    function doPad(chr, width, left, str) {
      var ret = str;
      while (ret.length < width) {
        if (left)
          ret += chr;
        else
          ret = chr + ret;
      }
      return (ret);
    }
    function dumpException(ex) {
      var ret;
      if (!(ex instanceof Error))
        throw (new Error(jsSprintf('invalid type for %%r: %j', ex)));
      ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;
      if (ex.cause && typeof(ex.cause) === 'function') {
        var cex = ex.cause();
        if (cex) {
          ret += '\nCaused by: ' + dumpException(cex);
        }
      }
      return (ret);
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("157", ["156"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('156');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("158", ["71", "59", "157", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var mod_assert = $__require('71');
    var mod_util = $__require('59');
    var mod_extsprintf = $__require('157');
    module.exports = VError;
    VError.VError = VError;
    VError.SError = SError;
    VError.WError = WError;
    VError.MultiError = MultiError;
    function VError(options) {
      var args,
          obj,
          causedBy,
          ctor,
          tailmsg;
      if (!(this instanceof VError)) {
        args = Array.prototype.slice.call(arguments, 0);
        obj = Object.create(VError.prototype);
        VError.apply(obj, arguments);
        return (obj);
      }
      if (options instanceof Error || typeof(options) === 'object') {
        args = Array.prototype.slice.call(arguments, 1);
      } else {
        args = Array.prototype.slice.call(arguments, 0);
        options = undefined;
      }
      if (!options || !options.strict) {
        args = args.map(function(a) {
          return (a === null ? 'null' : a === undefined ? 'undefined' : a);
        });
      }
      tailmsg = args.length > 0 ? mod_extsprintf.sprintf.apply(null, args) : '';
      this.jse_shortmsg = tailmsg;
      this.jse_summary = tailmsg;
      if (options) {
        causedBy = options.cause;
        if (!causedBy || !(options.cause instanceof Error))
          causedBy = options;
        if (causedBy && (causedBy instanceof Error)) {
          this.jse_cause = causedBy;
          this.jse_summary += ': ' + causedBy.message;
        }
      }
      this.message = this.jse_summary;
      Error.call(this, this.jse_summary);
      if (Error.captureStackTrace) {
        ctor = options ? options.constructorOpt : undefined;
        ctor = ctor || arguments.callee;
        Error.captureStackTrace(this, ctor);
      }
      return (this);
    }
    mod_util.inherits(VError, Error);
    VError.prototype.name = 'VError';
    VError.prototype.toString = function ve_toString() {
      var str = (this.hasOwnProperty('name') && this.name || this.constructor.name || this.constructor.prototype.name);
      if (this.message)
        str += ': ' + this.message;
      return (str);
    };
    VError.prototype.cause = function ve_cause() {
      return (this.jse_cause);
    };
    function SError() {
      var fmtargs,
          opts,
          key,
          args;
      opts = {};
      opts.constructorOpt = SError;
      if (arguments[0] instanceof Error) {
        opts.cause = arguments[0];
        fmtargs = Array.prototype.slice.call(arguments, 1);
      } else if (typeof(arguments[0]) == 'object') {
        for (key in arguments[0])
          opts[key] = arguments[0][key];
        fmtargs = Array.prototype.slice.call(arguments, 1);
      } else {
        fmtargs = Array.prototype.slice.call(arguments, 0);
      }
      opts.strict = true;
      args = [opts].concat(fmtargs);
      VError.apply(this, args);
    }
    mod_util.inherits(SError, VError);
    function MultiError(errors) {
      mod_assert.ok(errors.length > 0);
      this.ase_errors = errors;
      VError.call(this, errors[0], 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');
    }
    mod_util.inherits(MultiError, VError);
    function WError(options) {
      Error.call(this);
      var args,
          cause,
          ctor;
      if (typeof(options) === 'object') {
        args = Array.prototype.slice.call(arguments, 1);
      } else {
        args = Array.prototype.slice.call(arguments, 0);
        options = undefined;
      }
      if (args.length > 0) {
        this.message = mod_extsprintf.sprintf.apply(null, args);
      } else {
        this.message = '';
      }
      if (options) {
        if (options instanceof Error) {
          cause = options;
        } else {
          cause = options.cause;
          ctor = options.constructorOpt;
        }
      }
      Error.captureStackTrace(this, ctor || this.constructor);
      if (cause)
        this.cause(cause);
    }
    mod_util.inherits(WError, Error);
    WError.prototype.name = 'WError';
    WError.prototype.toString = function we_toString() {
      var str = (this.hasOwnProperty('name') && this.name || this.constructor.name || this.constructor.prototype.name);
      if (this.message)
        str += ': ' + this.message;
      if (this.we_cause && this.we_cause.message)
        str += '; caused by ' + this.we_cause.toString();
      return (str);
    };
    WError.prototype.cause = function we_cause(c) {
      if (c instanceof Error)
        this.we_cause = c;
      return (this.we_cause);
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("140", ["158"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('158');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("154", ["59", "140", "153"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var util = $__require('59');
  var WError = $__require('140').WError;
  var helpers = $__require('153');
  function HttpError() {
    var self = this;
    var parsed = helpers.parseVariadicArgs(arguments, true);
    var args = parsed.args;
    var options = parsed.options || {};
    WError.apply(self, args);
    if (!self.message) {
      self.message = (options.message || self.message) || '';
    }
    if (options.statusCode) {
      self.statusCode = options.statusCode;
    }
    self.body = {
      code: self.name,
      message: self.message || ''
    };
  }
  util.inherits(HttpError, WError);
  HttpError.displayName = 'HttpError';
  HttpError.prototype.name = 'HttpError';
  module.exports = HttpError;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("159", ["58", "59"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Stream = $__require('58');
  var util = $__require('59');
  var Response = module.exports = function(res) {
    this.offset = 0;
    this.readable = true;
  };
  util.inherits(Response, Stream);
  var capable = {
    streaming: true,
    status2: true
  };
  function parseHeaders(res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      if (line === '')
        continue;
      var m = line.match(/^([^:]+):\s*(.*)/);
      if (m) {
        var key = m[1].toLowerCase(),
            value = m[2];
        if (headers[key] !== undefined) {
          if (isArray(headers[key])) {
            headers[key].push(value);
          } else {
            headers[key] = [headers[key], value];
          }
        } else {
          headers[key] = value;
        }
      } else {
        headers[line] = true;
      }
    }
    return headers;
  }
  Response.prototype.getResponse = function(xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob')
      return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer')
      return xhr.response;
    return xhr.responseText;
  };
  Response.prototype.getHeader = function(key) {
    return this.headers[key.toLowerCase()];
  };
  Response.prototype.handle = function(res) {
    if (res.readyState === 2 && capable.status2) {
      try {
        this.statusCode = res.status;
        this.headers = parseHeaders(res);
      } catch (err) {
        capable.status2 = false;
      }
      if (capable.status2) {
        this.emit('ready');
      }
    } else if (capable.streaming && res.readyState === 3) {
      try {
        if (!this.statusCode) {
          this.statusCode = res.status;
          this.headers = parseHeaders(res);
          this.emit('ready');
        }
      } catch (err) {}
      try {
        this._emitData(res);
      } catch (err) {
        capable.streaming = false;
      }
    } else if (res.readyState === 4) {
      if (!this.statusCode) {
        this.statusCode = res.status;
        this.emit('ready');
      }
      this._emitData(res);
      if (res.error) {
        this.emit('error', this.getResponse(res));
      } else
        this.emit('end');
      this.emit('close');
    }
  };
  Response.prototype._emitData = function(res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
      this.emit('data', new Uint8Array(respBody, this.offset));
      this.offset = respBody.byteLength;
      return;
    }
    if (respBody.length > this.offset) {
      this.emit('data', respBody.slice(this.offset));
      this.offset = respBody.length;
    }
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("15a", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function() {
    var object = typeof exports != 'undefined' ? exports : this;
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    function InvalidCharacterError(message) {
      this.message = message;
    }
    InvalidCharacterError.prototype = new Error;
    InvalidCharacterError.prototype.name = 'InvalidCharacterError';
    object.btoa || (object.btoa = function(input) {
      for (var block,
          charCode,
          idx = 0,
          map = chars,
          output = ''; input.charAt(idx | 0) || (map = '=', idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
        charCode = input.charCodeAt(idx += 3 / 4);
        if (charCode > 0xFF) {
          throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
        }
        block = block << 8 | charCode;
      }
      return output;
    });
    object.atob || (object.atob = function(input) {
      input = input.replace(/=+$/, '');
      if (input.length % 4 == 1) {
        throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
      }
      for (var bc = 0,
          bs,
          buffer,
          idx = 0,
          output = ''; buffer = input.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
        buffer = chars.indexOf(buffer);
      }
      return output;
    });
  }());
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("15b", ["15a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('15a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("15c", ["58", "159", "15b", "ad"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Stream = $__require('58');
  var Response = $__require('159');
  var Base64 = $__require('15b');
  var inherits = $__require('ad');
  var Request = module.exports = function(xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    self.uri = (params.protocol || 'http:') + '//' + params.host + (params.port ? ':' + params.port : '') + (params.path || '/');
    ;
    if (typeof params.withCredentials === 'undefined') {
      params.withCredentials = true;
    }
    try {
      xhr.withCredentials = params.withCredentials;
    } catch (e) {}
    if (params.responseType)
      try {
        xhr.responseType = params.responseType;
      } catch (e) {}
    xhr.open(params.method || 'GET', self.uri, true);
    xhr.onerror = function(event) {
      self.emit('error', new Error('Network error'));
    };
    self._headers = {};
    if (params.headers) {
      var keys = objectKeys(params.headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!self.isSafeRequestHeader(key))
          continue;
        var value = params.headers[key];
        self.setHeader(key, value);
      }
    }
    if (params.auth) {
      this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }
    var res = new Response;
    res.on('close', function() {
      self.emit('close');
    });
    res.on('ready', function() {
      self.emit('response', res);
    });
    res.on('error', function(err) {
      self.emit('error', err);
    });
    xhr.onreadystatechange = function() {
      if (xhr.__aborted)
        return;
      res.handle(xhr);
    };
  };
  inherits(Request, Stream);
  Request.prototype.setHeader = function(key, value) {
    this._headers[key.toLowerCase()] = value;
  };
  Request.prototype.getHeader = function(key) {
    return this._headers[key.toLowerCase()];
  };
  Request.prototype.removeHeader = function(key) {
    delete this._headers[key.toLowerCase()];
  };
  Request.prototype.write = function(s) {
    this.body.push(s);
  };
  Request.prototype.destroy = function(s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
  };
  Request.prototype.end = function(s) {
    if (s !== undefined)
      this.body.push(s);
    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = this._headers[key];
      if (isArray(value)) {
        for (var j = 0; j < value.length; j++) {
          this.xhr.setRequestHeader(key, value[j]);
        }
      } else
        this.xhr.setRequestHeader(key, value);
    }
    if (this.body.length === 0) {
      this.xhr.send('');
    } else if (typeof this.body[0] === 'string') {
      this.xhr.send(this.body.join(''));
    } else if (isArray(this.body[0])) {
      var body = [];
      for (var i = 0; i < this.body.length; i++) {
        body.push.apply(body, this.body[i]);
      }
      this.xhr.send(body);
    } else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
      var len = 0;
      for (var i = 0; i < this.body.length; i++) {
        len += this.body[i].length;
      }
      var body = new (this.body[0].constructor)(len);
      var k = 0;
      for (var i = 0; i < this.body.length; i++) {
        var b = this.body[i];
        for (var j = 0; j < b.length; j++) {
          body[k++] = b[j];
        }
      }
      this.xhr.send(body);
    } else if (isXHR2Compatible(this.body[0])) {
      this.xhr.send(this.body[0]);
    } else {
      var body = '';
      for (var i = 0; i < this.body.length; i++) {
        body += this.body[i].toString();
      }
      this.xhr.send(body);
    }
  };
  Request.unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "content-transfer-encoding", "date", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];
  Request.prototype.isSafeRequestHeader = function(headerName) {
    if (!headerName)
      return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
  };
  var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for (var key in obj)
      keys.push(key);
    return keys;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
  };
  var indexOf = function(xs, x) {
    if (xs.indexOf)
      return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  };
  var isXHR2Compatible = function(obj) {
    if (typeof Blob !== 'undefined' && obj instanceof Blob)
      return true;
    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer)
      return true;
    if (typeof FormData !== 'undefined' && obj instanceof FormData)
      return true;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("15d", ["9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function(root) {
      var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
      var freeModule = typeof module == 'object' && module && !module.nodeType && module;
      var freeGlobal = typeof global == 'object' && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode,
          maxInt = 2147483647,
          base = 36,
          tMin = 1,
          tMax = 26,
          skew = 38,
          damp = 700,
          initialBias = 72,
          initialN = 128,
          delimiter = '-',
          regexPunycode = /^xn--/,
          regexNonASCII = /[^\x20-\x7E]/,
          regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
          errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
          },
          baseMinusTMin = base - tMin,
          floor = Math.floor,
          stringFromCharCode = String.fromCharCode,
          key;
      function error(type) {
        throw RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
          result = parts[0] + '@';
          string = parts[1];
        }
        string = string.replace(regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = map(labels, fn).join('.');
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [],
            counter = 0,
            length = string.length,
            value,
            extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
              output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = '';
          if (value > 0xFFFF) {
            value -= 0x10000;
            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
            value = 0xDC00 | value & 0x3FF;
          }
          output += stringFromCharCode(value);
          return output;
        }).join('');
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [],
            inputLength = input.length,
            out,
            i = 0,
            n = initialN,
            bias = initialBias,
            basic,
            j,
            index,
            oldi,
            w,
            k,
            digit,
            t,
            baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 0x80) {
            error('not-basic');
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error('invalid-input');
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error('overflow');
            }
            i += digit * w;
            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error('overflow');
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error('overflow');
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n,
            delta,
            handledCPCount,
            basicLength,
            bias,
            j,
            m,
            q,
            k,
            t,
            currentValue,
            output = [],
            inputLength,
            handledCPCountPlusOne,
            baseMinusT,
            qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 0x80) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error('overflow');
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error('overflow');
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join('');
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
        });
      }
      punycode = {
        'version': '1.3.2',
        'ucs2': {
          'decode': ucs2decode,
          'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
      };
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define('punycode', function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    }(this));
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("15e", ["15d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('15d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("15f", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  module.exports = function(qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};
    if (typeof qs !== 'string' || qs.length === 0) {
      return obj;
    }
    var regexp = /\+/g;
    qs = qs.split(sep);
    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
      maxKeys = options.maxKeys;
    }
    var len = qs.length;
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }
    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr,
          vstr,
          k,
          v;
      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = '';
      }
      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);
      if (!hasOwnProperty(obj, k)) {
        obj[k] = v;
      } else if (Array.isArray(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }
    return obj;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("160", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var stringifyPrimitive = function(v) {
    switch (typeof v) {
      case 'string':
        return v;
      case 'boolean':
        return v ? 'true' : 'false';
      case 'number':
        return isFinite(v) ? v : '';
      default:
        return '';
    }
  };
  module.exports = function(obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
      obj = undefined;
    }
    if (typeof obj === 'object') {
      return Object.keys(obj).map(function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (Array.isArray(obj[k])) {
          return obj[k].map(function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);
    }
    if (!name)
      return '';
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("161", ["15f", "160"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.decode = exports.parse = $__require('15f');
  exports.encode = exports.stringify = $__require('160');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("130", ["161"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('161');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("162", ["15e", "130"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var punycode = $__require('15e');
  exports.parse = urlParse;
  exports.resolve = urlResolve;
  exports.resolveObject = urlResolveObject;
  exports.format = urlFormat;
  exports.Url = Url;
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,
      delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
      unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
      autoEscape = ['\''].concat(unwise),
      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
      hostEndingChars = ['/', '?', '#'],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
      unsafeProtocol = {
        'javascript': true,
        'javascript:': true
      },
      hostlessProtocol = {
        'javascript': true,
        'javascript:': true
      },
      slashedProtocol = {
        'http': true,
        'https': true,
        'ftp': true,
        'gopher': true,
        'file': true,
        'http:': true,
        'https:': true,
        'ftp:': true,
        'gopher:': true,
        'file:': true
      },
      querystring = $__require('130');
  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && isObject(url) && url instanceof Url)
      return url;
    var u = new Url;
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
  }
  Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    if (!isString(url)) {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    }
    var rest = url;
    rest = rest.trim();
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === '//';
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
      var hostEnd = -1;
      for (var i = 0; i < hostEndingChars.length; i++) {
        var hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      var auth,
          atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf('@');
      } else {
        atSign = rest.lastIndexOf('@', hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = decodeURIComponent(auth);
      }
      hostEnd = -1;
      for (var i = 0; i < nonHostChars.length; i++) {
        var hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      if (hostEnd === -1)
        hostEnd = rest.length;
      this.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost();
      this.hostname = this.hostname || '';
      var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i = 0,
            l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part)
            continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = '';
            for (var j = 0,
                k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                newpart += 'x';
              } else {
                newpart += part[j];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = '/' + notHost.join('.') + rest;
              }
              this.hostname = validParts.join('.');
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = '';
      } else {
        this.hostname = this.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        var domainArray = this.hostname.split('.');
        var newOut = [];
        for (var i = 0; i < domainArray.length; ++i) {
          var s = domainArray[i];
          newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
        }
        this.hostname = newOut.join('.');
      }
      var p = this.port ? ':' + this.port : '';
      var h = this.hostname || '';
      this.host = h + p;
      this.href += this.host;
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        if (rest[0] !== '/') {
          rest = '/' + rest;
        }
      }
    }
    if (!unsafeProtocol[lowerProto]) {
      for (var i = 0,
          l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }
    var hash = rest.indexOf('#');
    if (hash !== -1) {
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
      this.search = rest.substr(qm);
      this.query = rest.substr(qm + 1);
      if (parseQueryString) {
        this.query = querystring.parse(this.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      this.search = '';
      this.query = {};
    }
    if (rest)
      this.pathname = rest;
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = '/';
    }
    if (this.pathname || this.search) {
      var p = this.pathname || '';
      var s = this.search || '';
      this.path = p + s;
    }
    this.href = this.format();
    return this;
  };
  function urlFormat(obj) {
    if (isString(obj))
      obj = urlParse(obj);
    if (!(obj instanceof Url))
      return Url.prototype.format.call(obj);
    return obj.format();
  }
  Url.prototype.format = function() {
    var auth = this.auth || '';
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ':');
      auth += '@';
    }
    var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = '';
    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
      if (this.port) {
        host += ':' + this.port;
      }
    }
    if (this.query && isObject(this.query) && Object.keys(this.query).length) {
      query = querystring.stringify(this.query);
    }
    var search = this.search || (query && ('?' + query)) || '';
    if (protocol && protocol.substr(-1) !== ':')
      protocol += ':';
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = '//' + (host || '');
      if (pathname && pathname.charAt(0) !== '/')
        pathname = '/' + pathname;
    } else if (!host) {
      host = '';
    }
    if (hash && hash.charAt(0) !== '#')
      hash = '#' + hash;
    if (search && search.charAt(0) !== '?')
      search = '?' + search;
    pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
    search = search.replace('#', '%23');
    return protocol + host + pathname + search + hash;
  };
  function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
  }
  Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };
  function urlResolveObject(source, relative) {
    if (!source)
      return relative;
    return urlParse(source, false, true).resolveObject(relative);
  }
  Url.prototype.resolveObject = function(relative) {
    if (isString(relative)) {
      var rel = new Url();
      rel.parse(relative, false, true);
      relative = rel;
    }
    var result = new Url();
    Object.keys(this).forEach(function(k) {
      result[k] = this[k];
    }, this);
    result.hash = relative.hash;
    if (relative.href === '') {
      result.href = result.format();
      return result;
    }
    if (relative.slashes && !relative.protocol) {
      Object.keys(relative).forEach(function(k) {
        if (k !== 'protocol')
          result[k] = relative[k];
      });
      if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
        result.path = result.pathname = '/';
      }
      result.href = result.format();
      return result;
    }
    if (relative.protocol && relative.protocol !== result.protocol) {
      if (!slashedProtocol[relative.protocol]) {
        Object.keys(relative).forEach(function(k) {
          result[k] = relative[k];
        });
        result.href = result.format();
        return result;
      }
      result.protocol = relative.protocol;
      if (!relative.host && !hostlessProtocol[relative.protocol]) {
        var relPath = (relative.pathname || '').split('/');
        while (relPath.length && !(relative.host = relPath.shift()))
          ;
        if (!relative.host)
          relative.host = '';
        if (!relative.hostname)
          relative.hostname = '';
        if (relPath[0] !== '')
          relPath.unshift('');
        if (relPath.length < 2)
          relPath.unshift('');
        result.pathname = relPath.join('/');
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.query = relative.query;
      result.host = relative.host || '';
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result.port = relative.port;
      if (result.pathname || result.search) {
        var p = result.pathname || '';
        var s = result.search || '';
        result.path = p + s;
      }
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    }
    var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
        isRelAbs = (relative.host || relative.pathname && relative.pathname.charAt(0) === '/'),
        mustEndAbs = (isRelAbs || isSourceAbs || (result.host && relative.pathname)),
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];
    if (psychotic) {
      result.hostname = '';
      result.port = null;
      if (result.host) {
        if (srcPath[0] === '')
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = '';
      if (relative.protocol) {
        relative.hostname = null;
        relative.port = null;
        if (relative.host) {
          if (relPath[0] === '')
            relPath[0] = relative.host;
          else
            relPath.unshift(relative.host);
        }
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
    }
    if (isRelAbs) {
      result.host = (relative.host || relative.host === '') ? relative.host : result.host;
      result.hostname = (relative.hostname || relative.hostname === '') ? relative.hostname : result.hostname;
      result.search = relative.search;
      result.query = relative.query;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
      result.query = relative.query;
    } else if (!isNullOrUndefined(relative.search)) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result.query = relative.query;
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
      }
      result.href = result.format();
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      if (result.search) {
        result.path = '/' + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = ((result.host || relative.host) && (last === '.' || last === '..') || last === '');
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
      last = srcPath[i];
      if (last == '.') {
        srcPath.splice(i, 1);
      } else if (last === '..') {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (; up--; up) {
        srcPath.unshift('..');
      }
    }
    if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
      srcPath.unshift('');
    }
    if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
      srcPath.push('');
    }
    var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    mustEndAbs = mustEndAbs || (result.host && srcPath.length);
    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift('');
    }
    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join('/');
    }
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  };
  Url.prototype.parseHost = function() {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ':') {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host)
      this.hostname = host;
  };
  function isString(arg) {
    return typeof arg === "string";
  }
  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("163", ["162"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('162');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("164", ["163"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('url') : $__require('163');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("68", ["164"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('164');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("165", ["1a", "15c", "68"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if ($__System._nodeRequire) {
    module.exports = $__System._nodeRequire('http');
  } else {
    var http = module.exports;
    var EventEmitter = $__require('1a').EventEmitter;
    var Request = $__require('15c');
    var url = $__require('68');
    http.request = function(params, cb) {
      if (typeof params === 'string') {
        params = url.parse(params);
      }
      if (!params)
        params = {};
      if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
      }
      if (!params.host && params.hostname) {
        params.host = params.hostname;
      }
      if (!params.protocol) {
        if (params.scheme) {
          params.protocol = params.scheme + ':';
        } else {
          params.protocol = window.location.protocol;
        }
      }
      if (!params.host) {
        params.host = window.location.hostname || window.location.host;
      }
      if (/:/.test(params.host)) {
        if (!params.port) {
          params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
      }
      if (!params.port)
        params.port = params.protocol == 'https:' ? 443 : 80;
      var req = new Request(new xhrHttp, params);
      if (cb)
        req.on('response', cb);
      return req;
    };
    http.get = function(params, cb) {
      params.method = 'GET';
      var req = http.request(params, cb);
      req.end();
      return req;
    };
    http.Agent = function() {};
    http.Agent.defaultMaxSockets = 4;
    var xhrHttp = (function() {
      if (typeof window === 'undefined') {
        throw new Error('no window object present');
      } else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
      } else if (window.ActiveXObject) {
        var axs = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP'];
        for (var i = 0; i < axs.length; i++) {
          try {
            var ax = new (window.ActiveXObject)(axs[i]);
            return function() {
              if (ax) {
                var ax_ = ax;
                ax = null;
                return ax_;
              } else {
                return new (window.ActiveXObject)(axs[i]);
              }
            };
          } catch (e) {}
        }
        throw new Error('ajax not supported in this browser');
      } else {
        throw new Error('ajax not supported in this browser');
      }
    })();
    http.STATUS_CODES = {
      100: 'Continue',
      101: 'Switching Protocols',
      102: 'Processing',
      200: 'OK',
      201: 'Created',
      202: 'Accepted',
      203: 'Non-Authoritative Information',
      204: 'No Content',
      205: 'Reset Content',
      206: 'Partial Content',
      207: 'Multi-Status',
      300: 'Multiple Choices',
      301: 'Moved Permanently',
      302: 'Moved Temporarily',
      303: 'See Other',
      304: 'Not Modified',
      305: 'Use Proxy',
      307: 'Temporary Redirect',
      400: 'Bad Request',
      401: 'Unauthorized',
      402: 'Payment Required',
      403: 'Forbidden',
      404: 'Not Found',
      405: 'Method Not Allowed',
      406: 'Not Acceptable',
      407: 'Proxy Authentication Required',
      408: 'Request Time-out',
      409: 'Conflict',
      410: 'Gone',
      411: 'Length Required',
      412: 'Precondition Failed',
      413: 'Request Entity Too Large',
      414: 'Request-URI Too Large',
      415: 'Unsupported Media Type',
      416: 'Requested Range Not Satisfiable',
      417: 'Expectation Failed',
      418: 'I\'m a teapot',
      422: 'Unprocessable Entity',
      423: 'Locked',
      424: 'Failed Dependency',
      425: 'Unordered Collection',
      426: 'Upgrade Required',
      428: 'Precondition Required',
      429: 'Too Many Requests',
      431: 'Request Header Fields Too Large',
      500: 'Internal Server Error',
      501: 'Not Implemented',
      502: 'Bad Gateway',
      503: 'Service Unavailable',
      504: 'Gateway Time-out',
      505: 'HTTP Version Not Supported',
      506: 'Variant Also Negotiates',
      507: 'Insufficient Storage',
      509: 'Bandwidth Limit Exceeded',
      510: 'Not Extended',
      511: 'Network Authentication Required'
    };
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7d", ["165"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('165');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("166", ["9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function() {
      var undefined;
      var VERSION = '3.10.1';
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256;
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
      var LARGE_ARRAY_SIZE = 200;
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;
      var FUNC_ERROR_TEXT = 'Expected a function';
      var PLACEHOLDER = '__lodash_placeholder__';
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
      var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
      var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reHasHexPrefix = /^0[xX]/;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^\d+$/;
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
        return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
      var contextProps = ['Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number', 'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite', 'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcC': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xeC': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss'
      };
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
      var objectTypes = {
        'function': true,
        'object': true
      };
      var regexpEscapes = {
        '0': 'x30',
        '1': 'x31',
        '2': 'x32',
        '3': 'x33',
        '4': 'x34',
        '5': 'x35',
        '6': 'x36',
        '7': 'x37',
        '8': 'x38',
        '9': 'x39',
        'A': 'x41',
        'B': 'x42',
        'C': 'x43',
        'D': 'x44',
        'E': 'x45',
        'F': 'x46',
        'a': 'x61',
        'b': 'x62',
        'c': 'x63',
        'd': 'x64',
        'e': 'x65',
        'f': 'x66',
        'n': 'x6e',
        'r': 'x72',
        't': 'x74',
        'u': 'x75',
        'v': 'x76',
        'x': 'x78'
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
      var freeSelf = objectTypes[typeof self] && self && self.Object && self;
      var freeWindow = objectTypes[typeof window] && window && window.Object && window;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;
          var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;
          if ((value > other && !othIsNull) || !valIsReflexive || (valIsNull && !othIsUndef && othIsReflexive) || (valIsUndef && othIsReflexive)) {
            return 1;
          }
          if ((value < other && !valIsNull) || !othIsReflexive || (othIsNull && !valIsUndef && valIsReflexive) || (othIsUndef && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
      function baseFindIndex(array, predicate, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIsFunction(value) {
        return typeof value == 'function' || false;
      }
      function baseToString(value) {
        return value == null ? '' : (value + '');
      }
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * ((order === 'asc' || order === true) ? 1 : -1);
          }
        }
        return object.index - other.index;
      }
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
      function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
        if (leadingChar) {
          chr = regexpEscapes[chr];
        } else if (whitespaceChar) {
          chr = stringEscapes[chr];
        }
        return '\\' + chr;
      }
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 || (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
        var arrayProto = Array.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;
        var fnToString = Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = root._;
        var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var ArrayBuffer = context.ArrayBuffer,
            clearTimeout = context.clearTimeout,
            parseFloat = context.parseFloat,
            pow = Math.pow,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = getNative(context, 'Set'),
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = context.Uint8Array,
            WeakMap = getNative(context, 'WeakMap');
        var nativeCeil = Math.ceil,
            nativeCreate = getNative(Object, 'create'),
            nativeFloor = Math.floor,
            nativeIsArray = getNative(Array, 'isArray'),
            nativeIsFinite = context.isFinite,
            nativeKeys = getNative(Object, 'keys'),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = getNative(Date, 'now'),
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var metaMap = WeakMap && new WeakMap;
        var realNames = {};
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        lodash.templateSettings = {
          'escape': reEscape,
          'evaluate': reEvaluate,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = [];
        }
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = arrayCopy(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = arrayCopy(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = arrayCopy(this.__views__);
          return result;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
            return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
          }
          var result = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
                value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
        function MapCache() {
          this.__data__ = {};
        }
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
        function SetCache(values) {
          var length = values ? values.length : 0;
          this.data = {
            'hash': nativeCreate(null),
            'set': new Set
          };
          while (length--) {
            this.push(values[length]);
          }
        }
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
          return result ? 0 : -1;
        }
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
        function arrayConcat(array, other) {
          var index = -1,
              length = array.length,
              othIndex = -1,
              othLength = other.length,
              result = Array(length + othLength);
          while (++index < length) {
            result[index] = array[index];
          }
          while (++othIndex < othLength) {
            result[index++] = other[othIndex];
          }
          return result;
        }
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayExtremum(array, iteratee, comparator, exValue) {
          var index = -1,
              length = array.length,
              computed = exValue,
              result = computed;
          while (++index < length) {
            var value = array[index],
                current = +iteratee(value);
            if (comparator(current, computed)) {
              computed = current;
              result = value;
            }
          }
          return result;
        }
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1,
              length = values.length,
              offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function arraySum(array, iteratee) {
          var length = array.length,
              result = 0;
          while (length--) {
            result += +iteratee(array[length]) || 0;
          }
          return result;
        }
        function assignDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (objectValue === undefined || !hasOwnProperty.call(object, key)) ? sourceValue : objectValue;
        }
        function assignWith(object, source, customizer) {
          var index = -1,
              props = keys(source),
              length = props.length;
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
            if ((result === result ? (result !== value) : (value === value)) || (value === undefined && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
        function baseAssign(object, source) {
          return source == null ? object : baseCopy(source, keys(source), object);
        }
        function baseAt(collection, props) {
          var index = -1,
              isNil = collection == null,
              isArr = !isNil && isArrayLike(collection),
              length = isArr ? collection.length : 0,
              propsLength = props.length,
              result = Array(propsLength);
          while (++index < propsLength) {
            var key = props[index];
            if (isArr) {
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = isNil ? undefined : collection[key];
            }
          }
          return result;
        }
        function baseCopy(source, props, object) {
          object || (object = {});
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseAssign(result, value);
              }
            } else {
              return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : (object ? value : {});
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
        var baseCreate = (function() {
          function object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              object.prototype = prototype;
              var result = new object;
              object.prototype = undefined;
            }
            return result || {};
          };
        }());
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined, args);
          }, wait);
        }
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
              valuesLength = values.length;
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer: while (++index < length) {
            var value = array[index];
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (indexOf(values, value, 0) < 0) {
              result.push(value);
            }
          }
          return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
        function baseExtremum(collection, iteratee, comparator, exValue) {
          var computed = exValue,
              result = computed;
          baseEach(collection, function(value, index, collection) {
            var current = +iteratee(value, index, collection);
            if (comparator(current, computed) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end >>> 0);
          start >>>= 0;
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
        function baseFlatten(array, isDeep, isStrict, result) {
          result || (result = []);
          var index = -1,
              length = array.length;
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) {
              if (isDeep) {
                baseFlatten(value, isDeep, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
        function baseGet(object, path, pathKey) {
          if (object == null) {
            return;
          }
          if (pathKey !== undefined && pathKey in toObject(object)) {
            path = [pathKey];
          }
          var index = 0,
              length = path.length;
          while (object != null && index < length) {
            object = object[path[index++]];
          }
          return (index && index == length) ? object : undefined;
        }
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          if (!isLoose) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
              return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          stackA.push(object);
          stackB.push(other);
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
          stackA.pop();
          stackB.pop();
          return result;
        }
        function baseIsMatch(object, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = toObject(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            var key = matchData[0][0],
                value = matchData[0][1];
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === value && (value !== undefined || (key in toObject(object)));
            };
          }
          return function(object) {
            return baseIsMatch(object, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          var isArr = isArray(path),
              isCommon = isKey(path) && isStrictComparable(srcValue),
              pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            if (object == null) {
              return false;
            }
            var key = pathKey;
            object = toObject(object);
            if ((isArr || !isCommon) && !(key in object)) {
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              key = last(path);
              object = toObject(object);
            }
            return object[key] === srcValue ? (srcValue !== undefined || (key in object)) : baseIsEqual(srcValue, object[key], undefined, true);
          };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
              props = isSrcArr ? undefined : keys(source);
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            } else {
              var value = object[key],
                  result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                  isCommon = result === undefined;
              if (isCommon) {
                result = srcValue;
              }
              if ((result !== undefined || (isSrcArr && !(key in object))) && (isCommon || (result === result ? (result !== value) : (value === value)))) {
                object[key] = result;
              }
            }
          });
          return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;
          if (isCommon) {
            result = srcValue;
            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value) ? value : (isArrayLike(value) ? arrayCopy(value) : []);
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value) ? toPlainObject(value) : (isPlainObject(value) ? value : {});
            } else {
              isCommon = false;
            }
          }
          stackA.push(srcValue);
          stackB.push(result);
          if (isCommon) {
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? (result !== value) : (value === value)) {
            object[key] = result;
          }
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
        function basePropertyDeep(path) {
          var pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            return baseGet(object, path, pathKey);
          };
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0;
          while (length--) {
            var index = indexes[length];
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return array;
        }
        function baseRandom(min, max) {
          return min + nativeFloor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function baseSome(collection, predicate) {
          var result;
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSortByOrder(collection, iteratees, orders) {
          var callback = getCallback(),
              index = -1;
          iteratees = arrayMap(iteratees, function(iteratee) {
            return callback(iteratee);
          });
          var result = baseMap(collection, function(value) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return {
              'criteria': criteria,
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function baseSum(collection, iteratee) {
          var result = 0;
          baseEach(collection, function(value, index, collection) {
            result += +iteratee(value, index, collection) || 0;
          });
          return result;
        }
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
              seen = isLarge ? createCache() : null,
              result = [];
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer: while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (indexOf(seen, computed, 0) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
          return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
          while (++index < length) {
            var action = actions[index];
            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
          }
          return result;
        }
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
              if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsNull) {
              setLow = isReflexive && isDef && (retHighest || computed != null);
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || isDef);
            } else if (computed == null) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (thisArg === undefined) {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            case 5:
              return function(value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
              };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
        function bufferClone(buffer) {
          var result = new ArrayBuffer(buffer.byteLength),
              view = new Uint8Array(result);
          view.set(new Uint8Array(buffer));
          return result;
        }
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(leftLength + argsLength);
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createAssigner(assigner) {
          return restParam(function(object, sources) {
            var index = -1,
                length = object == null ? 0 : sources.length,
                customizer = length > 2 ? sources[length - 2] : undefined,
                guard = length > 2 ? sources[2] : undefined,
                thisArg = length > 1 ? sources[length - 1] : undefined;
            if (typeof customizer == 'function') {
              customizer = bindCallback(customizer, thisArg, 5);
              length -= 2;
            } else {
              customizer = typeof thisArg == 'function' ? thisArg : undefined;
              length -= (customizer ? 1 : 0);
            }
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              return eachFunc(collection, iteratee);
            }
            var index = fromRight ? length : -1,
                iterable = toObject(collection);
            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var iterable = toObject(object),
                props = keysFunc(object),
                length = props.length,
                index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length)) {
              var key = props[index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(thisArg, arguments);
          }
          return wrapper;
        }
        function createCache(values) {
          return (nativeCreate && Set) ? new SetCache(values) : null;
        }
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
        function createCtorWrapper(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor;
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createCurry(flag) {
          function curryFunc(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
              arity = undefined;
            }
            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryFunc.placeholder;
            return result;
          }
          return curryFunc;
        }
        function createDefaults(assigner, customizer) {
          return restParam(function(args) {
            var object = args[0];
            if (object == null) {
              return object;
            }
            args.push(customizer);
            return assigner.apply(undefined, args);
          });
        }
        function createExtremum(comparator, exValue) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = undefined;
            }
            iteratee = getCallback(iteratee, thisArg, 3);
            if (iteratee.length == 1) {
              collection = isArray(collection) ? collection : toIterable(collection);
              var result = arrayExtremum(collection, iteratee, comparator, exValue);
              if (!(collection.length && result === exValue)) {
                return result;
              }
            }
            return baseExtremum(collection, iteratee, comparator, exValue);
          };
        }
        function createFind(eachFunc, fromRight) {
          return function(collection, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            if (isArray(collection)) {
              var index = baseFindIndex(collection, predicate, fromRight);
              return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, eachFunc);
          };
        }
        function createFindIndex(fromRight) {
          return function(array, predicate, thisArg) {
            if (!(array && array.length)) {
              return -1;
            }
            predicate = getCallback(predicate, thisArg, 3);
            return baseFindIndex(array, predicate, fromRight);
          };
        }
        function createFindKey(objectFunc) {
          return function(object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, objectFunc, true);
          };
        }
        function createFlow(fromRight) {
          return function() {
            var wrapper,
                length = arguments.length,
                index = fromRight ? length : -1,
                leftIndex = 0,
                funcs = Array(length);
            while ((fromRight ? index-- : ++index < length)) {
              var func = funcs[leftIndex++] = arguments[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? -1 : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;
              if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];
              if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          };
        }
        function createForEach(arrayFunc, eachFunc) {
          return function(collection, iteratee, thisArg) {
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
          };
        }
        function createForIn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee, keysIn);
          };
        }
        function createForOwn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee);
          };
        }
        function createObjectMapper(isMapKeys) {
          return function(object, iteratee, thisArg) {
            var result = {};
            iteratee = getCallback(iteratee, thisArg, 3);
            baseForOwn(object, function(value, key, object) {
              var mapped = iteratee(value, key, object);
              key = isMapKeys ? mapped : key;
              value = isMapKeys ? value : mapped;
              result[key] = value;
            });
            return result;
          };
        }
        function createPadDir(fromRight) {
          return function(string, length, chars) {
            string = baseToString(string);
            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
          };
        }
        function createPartial(flag) {
          var partialFunc = restParam(function(func, partials) {
            var holders = replaceHolders(partials, partialFunc.placeholder);
            return createWrapper(func, flag, undefined, partials, holders);
          });
          return partialFunc;
        }
        function createReduce(arrayFunc, eachFunc) {
          return function(collection, iteratee, accumulator, thisArg) {
            var initFromArray = arguments.length < 3;
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
          };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG,
              Ctor = isBindKey ? undefined : createCtorWrapper(func);
          function wrapper() {
            var length = arguments.length,
                index = length,
                args = Array(length);
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : undefined,
                    newHoldersRight = isCurry ? undefined : argsHolders,
                    newPartials = isCurry ? args : undefined,
                    newPartialsRight = isCurry ? undefined : args;
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                    result = createHybridWrapper.apply(undefined, newData);
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtorWrapper(func);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createPadding(string, length, chars) {
          var strLength = string.length;
          length = +length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength);
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            precision = precision === undefined ? 0 : (+precision || 0);
            if (precision) {
              precision = pow(10, precision);
              return func(number * precision) / precision;
            }
            return func(number);
          };
        }
        function createSortedIndex(retHighest) {
          return function(array, value, iteratee, thisArg) {
            var callback = getCallback(iteratee);
            return (iteratee == null && callback === baseCallback) ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
          };
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
          if (data) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null ? (isBindKey ? 0 : func.length) : (nativeMax(arity - length, 0) || 0);
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length;
          if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
            return false;
          }
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index],
                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
            if (result !== undefined) {
              if (result) {
                continue;
              }
              return false;
            }
            if (isLoose) {
              if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
                return false;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
              return false;
            }
          }
          return true;
        }
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              return +object == +other;
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case numberTag:
              return (object != +object) ? other != +other : object == +other;
            case regexpTag:
            case stringTag:
              return object == (other + '');
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
          if (objLength != othLength && !isLoose) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var skipCtor = isLoose;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key],
                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;
            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
              return false;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (!skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result = func.name,
              array = realNames[result],
              length = array ? array.length : 0;
          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
        var getLength = baseProperty('length');
        function getMatchData(object) {
          var result = pairs(object),
              length = result.length;
          while (length--) {
            result[length][2] = isStrictComparable(result[length][1]);
          }
          return result;
        }
        function getNative(object, key) {
          var value = object == null ? undefined : object[key];
          return isNative(value) ? value : undefined;
        }
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
            switch (data.type) {
              case 'drop':
                start += size;
                break;
              case 'dropRight':
                end -= size;
                break;
              case 'take':
                end = nativeMin(end, start + size);
                break;
              case 'takeRight':
                start = nativeMax(start, end - size);
                break;
            }
          }
          return {
            'start': start,
            'end': end
          };
        }
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
        function invokePath(object, path, args) {
          if (object != null && !isKey(path, object)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            path = last(path);
          }
          var func = object == null ? object : object[path];
          return func == null ? undefined : func.apply(object, args);
        }
        function isArrayLike(value) {
          return value != null && isLength(getLength(value));
        }
        function isIndex(value, length) {
          value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
            var other = object[index];
            return value === value ? (value === other) : (other !== other);
          }
          return false;
        }
        function isKey(value, object) {
          var type = typeof value;
          if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
            return true;
          }
          if (isArray(value)) {
            return false;
          }
          var result = !reIsDeepProp.test(value);
          return result || (object != null && value in toObject(object));
        }
        function isLaziable(func) {
          var funcName = getFuncName(func);
          if (!(funcName in LazyWrapper.prototype)) {
            return false;
          }
          var other = lodash[funcName];
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < ARY_FLAG;
          var isCombo = (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) || (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) || (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function mergeDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
        }
        function pickByArray(object, props) {
          object = toObject(object);
          var index = -1,
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length;
          var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));
          var index = -1,
              result = [];
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isArrayLike(value)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
        function toPath(value) {
          if (isArray(value)) {
            return value;
          }
          var result = [];
          baseToString(value).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        }
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(nativeFloor(size) || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(nativeCeil(length / size));
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        var difference = restParam(function(array, values) {
          return (isObjectLike(array) && isArrayLike(array)) ? baseDifference(array, baseFlatten(values, false, true)) : [];
        });
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true) : [];
        }
        function dropWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        var findIndex = createFindIndex();
        var findLastIndex = createFindIndex(true);
        function first(array) {
          return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
          } else if (fromIndex) {
            var index = binaryIndex(array, value);
            if (index < length && (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
              return index;
            }
            return -1;
          }
          return baseIndexOf(array, value, fromIndex || 0);
        }
        function initial(array) {
          return dropRight(array, 1);
        }
        var intersection = restParam(function(arrays) {
          var othLength = arrays.length,
              othIndex = othLength,
              caches = Array(length),
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              result = [];
          while (othIndex--) {
            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
          }
          var array = arrays[0],
              index = -1,
              length = array ? array.length : 0,
              seen = caches[0];
          outer: while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
              var othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        });
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull() {
          var args = arguments,
              array = args[0];
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = args.length;
          while (++index < length) {
            var fromIndex = 0,
                value = args[index];
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        var pullAt = restParam(function(array, indexes) {
          indexes = baseFlatten(indexes);
          var result = baseAt(array, indexes);
          basePullAt(array, indexes.sort(baseCompareAscending));
          return result;
        });
        function remove(array, predicate, thisArg) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }
        function rest(array) {
          return drop(array, 1);
        }
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
        var sortedIndex = createSortedIndex();
        var sortedLastIndex = createSortedIndex(true);
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true) : [];
        }
        function takeWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3)) : [];
        }
        var union = restParam(function(arrays) {
          return baseUniq(baseFlatten(arrays, false, true));
        });
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
            isSorted = false;
          }
          var callback = getCallback();
          if (!(iteratee == null && callback === baseCallback)) {
            iteratee = callback(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() == baseIndexOf) ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var index = -1,
              length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLike(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          var result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
        function unzipWith(array, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          iteratee = bindCallback(iteratee, thisArg, 4);
          return arrayMap(result, function(group) {
            return arrayReduce(group, iteratee, undefined, true);
          });
        }
        var without = restParam(function(array, values) {
          return isArrayLike(array) ? baseDifference(array, values) : [];
        });
        function xor() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArrayLike(array)) {
              var result = result ? arrayPush(baseDifference(result, array), baseDifference(array, result)) : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
        var zip = restParam(unzip);
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        var zipWith = restParam(function(arrays) {
          var length = arrays.length,
              iteratee = length > 2 ? arrays[length - 2] : undefined,
              thisArg = length > 1 ? arrays[length - 1] : undefined;
          if (length > 2 && typeof iteratee == 'function') {
            length -= 2;
          } else {
            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
            thisArg = undefined;
          }
          arrays.length = length;
          return unzipWith(arrays, iteratee, thisArg);
        });
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        var wrapperConcat = restParam(function(values) {
          values = baseFlatten(values);
          return this.thru(function(array) {
            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
          });
        });
        function wrapperPlant(value) {
          var result,
              parent = this;
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          var interceptor = function(value) {
            return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
          };
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(interceptor);
        }
        function wrapperToString() {
          return (this.value() + '');
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var at = restParam(function(collection, props) {
          return baseAt(collection, baseFlatten(props));
        });
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
        var find = createFind(baseEach);
        var findLast = createFind(baseEachRight, true);
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
        var forEach = createForEach(arrayEach, baseEach);
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
        function includes(collection, target, fromIndex, guard) {
          var length = collection ? getLength(collection) : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
            fromIndex = 0;
          } else {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection)) ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1) : (!!length && getIndexOf(collection, target, fromIndex) > -1);
        }
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        var invoke = restParam(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value) {
            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
          });
          return result;
        });
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function pluck(collection, path) {
          return map(collection, property(path));
        }
        var reduce = createReduce(arrayReduce, baseEach);
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;
          n = nativeMin(n < 0 ? 0 : (+n || 0), length);
          while (++index < n) {
            var rand = baseRandom(index, lastIndex),
                value = result[rand];
            result[rand] = result[index];
            result[index] = value;
          }
          result.length = n;
          return result;
        }
        function shuffle(collection) {
          return sample(collection, POSITIVE_INFINITY);
        }
        function size(collection) {
          var length = collection ? getLength(collection) : 0;
          return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
          if (collection == null) {
            return [];
          }
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          var index = -1;
          iteratee = getCallback(iteratee, thisArg, 3);
          var result = baseMap(collection, function(value, key, collection) {
            return {
              'criteria': iteratee(value, key, collection),
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, compareAscending);
        }
        var sortByAll = restParam(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var guard = iteratees[2];
          if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
            iteratees.length = 1;
          }
          return baseSortByOrder(collection, baseFlatten(iteratees), []);
        });
        function sortByOrder(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (guard && isIterateeCall(iteratees, orders, guard)) {
            orders = undefined;
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseSortByOrder(collection, iteratees, orders);
        }
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function() {
          return new Date().getTime();
        };
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = undefined;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }
        var bind = restParam(function(func, thisArg, partials) {
          var bitmask = BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        });
        var bindAll = restParam(function(object, methodNames) {
          methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
          var index = -1,
              length = methodNames.length;
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        });
        var bindKey = restParam(function(object, key, partials) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        });
        var curry = createCurry(CURRY_FLAG);
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = !!options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            lastCalled = 0;
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
          function complete(isCalled, id) {
            if (id) {
              clearTimeout(id);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (isCalled) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = undefined;
              }
            }
          }
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              complete(trailingCall, maxTimeoutId);
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
          function maxDelayed() {
            complete(trailing, timeoutId);
          }
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = undefined;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
        var defer = restParam(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = restParam(function(func, wait, args) {
          return baseDelay(func, wait, args);
        });
        var flow = createFlow();
        var flowRight = createFlow(true);
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
        var modArgs = restParam(function(func, transforms) {
          transforms = baseFlatten(transforms);
          if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = transforms.length;
          return restParam(function(args) {
            var index = nativeMin(args.length, length);
            while (index--) {
              args[index] = transforms[index](args[index]);
            }
            return func.apply(this, args);
          });
        });
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var partial = createPartial(PARTIAL_FLAG);
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
        var rearg = restParam(function(func, indexes) {
          return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
        });
        function restParam(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);
            while (++index < length) {
              rest[index] = args[start + index];
            }
            switch (start) {
              case 0:
                return func.call(this, rest);
              case 1:
                return func.call(this, args[0], rest);
              case 2:
                return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
          };
        }
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': +wait,
            'trailing': trailing
          });
        }
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          } else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          return typeof customizer == 'function' ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1)) : baseClone(value, isDeep);
        }
        function cloneDeep(value, customizer, thisArg) {
          return typeof customizer == 'function' ? baseClone(value, true, bindCallback(customizer, thisArg, 1)) : baseClone(value, true);
        }
        function gt(value, other) {
          return value > other;
        }
        function gte(value, other) {
          return value >= other;
        }
        function isArguments(value) {
          return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        }
        var isArray = nativeIsArray || function(value) {
          return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };
        function isBoolean(value) {
          return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
        }
        function isDate(value) {
          return isObjectLike(value) && objToString.call(value) == dateTag;
        }
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || (isObjectLike(value) && isFunction(value.splice)))) {
            return !value.length;
          }
          return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
          return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
        }
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }
        function isFunction(value) {
          return isObject(value) && objToString.call(value) == funcTag;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == 'object' || type == 'function');
        }
        function isMatch(object, source, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          return baseIsMatch(object, getMatchData(source), customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (isFunction(value)) {
            return reIsNative.test(fnToString.call(value));
          }
          return isObjectLike(value) && reIsHostCtor.test(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
        }
        function isPlainObject(value) {
          var Ctor;
          if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) || (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          var result;
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return result === undefined || hasOwnProperty.call(value, result);
        }
        function isRegExp(value) {
          return isObject(value) && objToString.call(value) == regexpTag;
        }
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
        }
        function isTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
        function isUndefined(value) {
          return value === undefined;
        }
        function lt(value, other) {
          return value < other;
        }
        function lte(value, other) {
          return value <= other;
        }
        function toArray(value) {
          var length = value ? getLength(value) : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
        var merge = createAssigner(baseMerge);
        var assign = createAssigner(function(object, source, customizer) {
          return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
        });
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = undefined;
          }
          return properties ? baseAssign(result, properties) : result;
        }
        var defaults = createDefaults(assign, assignDefaults);
        var defaultsDeep = createDefaults(merge, mergeDefaults);
        var findKey = createFindKey(baseForOwn);
        var findLastKey = createFindKey(baseForOwnRight);
        var forIn = createForIn(baseFor);
        var forInRight = createForIn(baseForRight);
        var forOwn = createForOwn(baseForOwn);
        var forOwnRight = createForOwn(baseForOwnRight);
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
          return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
          if (object == null) {
            return false;
          }
          var result = hasOwnProperty.call(object, path);
          if (!result && !isKey(path)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            if (object == null) {
              return false;
            }
            path = last(path);
            result = hasOwnProperty.call(object, path);
          }
          return result || (isLength(object.length) && isIndex(path, object.length) && (isArray(object) || isArguments(object)));
        }
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = undefined;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index],
                value = object[key];
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            } else {
              result[value] = key;
            }
          }
          return result;
        }
        var keys = !nativeKeys ? shimKeys : function(object) {
          var Ctor = object == null ? undefined : object.constructor;
          if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && isArrayLike(object))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = (length && isLength(length) && (isArray(object) || isArguments(object)) && length) || 0;
          var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;
          while (++index < length) {
            result[index] = (index + '');
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        var mapKeys = createObjectMapper(true);
        var mapValues = createObjectMapper();
        var omit = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          if (typeof props[0] != 'function') {
            var props = arrayMap(baseFlatten(props), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          var predicate = bindCallback(props[0], props[1], 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        });
        function pairs(object) {
          object = toObject(object);
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
        var pick = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          return typeof props[0] == 'function' ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
        });
        function result(object, path, defaultValue) {
          var result = object == null ? undefined : object[path];
          if (result === undefined) {
            if (object != null && !isKey(path, object)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              result = object == null ? undefined : object[last(path)];
            }
            result = result === undefined ? defaultValue : result;
          }
          return isFunction(result) ? result.call(object) : result;
        }
        function set(object, path, value) {
          if (object == null) {
            return object;
          }
          var pathKey = (path + '');
          path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);
          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
          while (nested != null && ++index < length) {
            var key = path[index];
            if (isObject(nested)) {
              if (index == lastIndex) {
                nested[key] = value;
              } else if (nested[key] == null) {
                nested[key] = isIndex(path[index + 1]) ? [] : {};
              }
            }
            nested = nested[key];
          }
          return object;
        }
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          return baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
          start = +start || 0;
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= nativeMin(start, end) && value < nativeMax(start, end);
        }
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = undefined;
          }
          var noMin = min == null,
              noMax = max == null;
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            } else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
          var length = string.length;
          position = position === undefined ? length : nativeMin(position < 0 ? 0 : (+position || 0), length);
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string)) ? string.replace(reRegExpChars, escapeRegExpChar) : (string || '(?:)');
        }
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = nativeFloor(mid),
              rightLength = nativeCeil(mid);
          chars = createPadding('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
        var padLeft = createPadDir();
        var padRight = createPadDir(true);
        function parseInt(string, radix, guard) {
          if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          string = trim(string);
          return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            string += string;
          } while (n);
          return result;
        }
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
          return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
          var settings = lodash.templateSettings;
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = undefined;
          }
          string = baseToString(string);
          options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
          var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? (+options.length || 0) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = undefined;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
        var attempt = restParam(function(func, args) {
          try {
            return func.apply(undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = undefined;
          }
          return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function identity(value) {
          return value;
        }
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, true));
        }
        var method = restParam(function(path, args) {
          return function(object) {
            return invokePath(object, path, args);
          };
        });
        var methodOf = restParam(function(object, args) {
          return function(path) {
            return invokePath(object, path, args);
          };
        });
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj ? keys(source) : undefined,
                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                        actions = result.__actions__ = arrayCopy(this.__actions__);
                    actions.push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }(func));
            }
          }
          return object;
        }
        function noConflict() {
          root._ = oldDash;
          return this;
        }
        function noop() {}
        function property(path) {
          return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return baseGet(object, toPath(path), path + '');
          };
        }
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = undefined;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function times(n, iteratee, thisArg) {
          n = nativeFloor(n);
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
        function add(augend, addend) {
          return (+augend || 0) + (+addend || 0);
        }
        var ceil = createRound('ceil');
        var floor = createRound('floor');
        var max = createExtremum(gt, NEGATIVE_INFINITY);
        var min = createExtremum(lt, POSITIVE_INFINITY);
        var round = createRound('round');
        function sum(collection, iteratee, thisArg) {
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          return iteratee.length == 1 ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee) : baseSum(collection, iteratee);
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.modArgs = modArgs;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.set = set;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipWith = zipWith;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.floor = floor;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.eq = isEqual;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
        lodash.sample = sample;
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
        lodash.VERSION = VERSION;
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__;
            if (filtered && !index) {
              return new LazyWrapper(this);
            }
            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);
            var result = this.clone();
            if (filtered) {
              result.__takeCount__ = nativeMin(result.__takeCount__, n);
            } else {
              result.__views__.push({
                'size': n,
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type != LAZY_MAP_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getCallback(iteratee, thisArg, 1),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : property;
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 1);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
          return this.reverse().takeWhile(predicate, thisArg).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(POSITIVE_INFINITY);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName),
              lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var args = retUnwrapped ? [1] : arguments,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              isLazy = useLazy = false;
            }
            var interceptor = function(value) {
              return (retUnwrapped && chainAll) ? lodashFunc(value, 1)[0] : lodashFunc.apply(undefined, arrayPush([value], args));
            };
            var action = {
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            },
                onlyLazy = isLazy && !isHybrid;
            if (retUnwrapped && !chainAll) {
              if (onlyLazy) {
                value = value.clone();
                value.__actions__.push(action);
                return func.call(value);
              }
              return lodashFunc.call(undefined, this.value())[0];
            }
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push(action);
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
        arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
          var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name,
                names = realNames[key] || (realNames[key] = []);
            names.push({
              'name': methodName,
              'func': lodashFunc
            });
          }
        });
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.concat = wrapperConcat;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("155", ["166"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('166');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("153", ["7d", "155", "5a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var http = $__require('7d');
  var _ = $__require('155');
  var assert = $__require('5a');
  function parseVariadicArgs(ctorArgs, werrorSuper) {
    function parse() {
      var args = _.toArray(arguments);
      var options = null;
      if (arguments[0] instanceof Error) {
        if (_.isPlainObject(arguments[1])) {
          options = arguments[1] || {};
          if (werrorSuper === true) {
            args = [arguments[0]];
          }
        }
      } else if (_.isPlainObject(arguments[0])) {
        options = arguments[0] || {};
        if (werrorSuper === true) {
          args = _.rest(args);
        }
        assert.optionalObject(options, 'options');
        assert.optionalString(options.message, 'options.message');
        assert.optionalNumber(options.statusCode, 'options.statusCode');
      }
      return {
        args: args,
        options: options
      };
    }
    return parse.apply(null, ctorArgs);
  }
  function errNameFromCode(code) {
    assert.number(code, 'code');
    var errorDesc = http.STATUS_CODES[code] || http.STATUS_CODES[500];
    return errNameFromDesc(errorDesc);
  }
  function errNameFromDesc(desc) {
    assert.string(desc, 'desc');
    var pieces = desc.split(/\s+/);
    var name = _.reduce(pieces, function(acc, piece) {
      var normalizedPiece = _.capitalize(piece.toLowerCase());
      return acc + normalizedPiece;
    }, '');
    name = name.replace(/\W+/g, '');
    if (!_.endsWith(name, 'Error')) {
      name += 'Error';
    }
    return name;
  }
  module.exports.errNameFromCode = errNameFromCode;
  module.exports.errNameFromDesc = errNameFromDesc;
  module.exports.parseVariadicArgs = parseVariadicArgs;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("167", ["59", "154", "153"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var util = $__require('59');
  var HttpError = $__require('154');
  var helpers = $__require('153');
  function RestError() {
    var self = this;
    var parsed = helpers.parseVariadicArgs(arguments);
    var args = parsed.args;
    var options = parsed.options || {};
    HttpError.apply(this, args);
    self.restCode = options.restCode || self.restCode;
    self.body = {
      code: self.restCode,
      message: self.message || ''
    };
  }
  util.inherits(RestError, HttpError);
  RestError.displayName = 'RestError';
  RestError.prototype.name = 'RestError';
  RestError.prototype.restCode = 'Error';
  module.exports = RestError;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("168", ["59", "155", "167"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var util = $__require('59');
  var _ = $__require('155');
  var RestError = $__require('167');
  var CODES = {
    BadDigest: 400,
    BadMethod: 405,
    ConnectTimeout: 408,
    Internal: 500,
    InvalidArgument: 409,
    InvalidContent: 400,
    InvalidCredentials: 401,
    InvalidHeader: 400,
    InvalidVersion: 400,
    MissingParameter: 409,
    NotAuthorized: 403,
    PreconditionFailed: 412,
    RequestExpired: 400,
    RequestThrottled: 429,
    ResourceNotFound: 404,
    WrongAccept: 406
  };
  var restErrors = _.reduce(CODES, function(acc, statusCode, errorCode) {
    var name = errorCode + 'Error';
    acc[name] = function() {
      RestError.apply(this, arguments);
    };
    util.inherits(acc[name], RestError);
    acc[name].displayName = name;
    acc[name].prototype.name = name;
    acc[name].prototype.statusCode = statusCode;
    acc[name].prototype.restCode = errorCode;
    return acc;
  }, {});
  module.exports = restErrors;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("169", ["59", "155", "5a", "153", "154", "167", "152", "168"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var util = $__require('59');
  var _ = $__require('155');
  var assert = $__require('5a');
  var helpers = $__require('153');
  var HttpError = $__require('154');
  var RestError = $__require('167');
  var httpErrors = $__require('152');
  var restErrors = $__require('168');
  function makeErrFromCode(statusCode) {
    assert.number(statusCode, 'statusCode');
    assert.equal(statusCode >= 400, true);
    var args = _.rest(_.toArray(arguments));
    var name = helpers.errNameFromCode(statusCode);
    var ErrCtor = httpErrors[name];
    assert.func(ErrCtor);
    return makeInstance(ErrCtor, makeErrFromCode, args);
  }
  function makeConstructor(name, defaults) {
    assert.string(name, 'name');
    assert.optionalObject(defaults, 'defaults');
    assert.equal(typeof module.exports[name], 'undefined', 'Constructor already exists!');
    var ErrCtor = function() {
      RestError.apply(this, arguments);
    };
    util.inherits(ErrCtor, RestError);
    ErrCtor.displayName = name;
    ErrCtor.prototype.name = name;
    _.assign(ErrCtor.prototype, defaults);
    module.exports[name] = ErrCtor;
  }
  function makeInstance(constructor, constructorOpt, args) {
    function F() {
      return constructor.apply(this, args);
    }
    F.prototype = constructor.prototype;
    var errInstance = new F();
    Error.captureStackTrace(errInstance, constructorOpt);
    return errInstance;
  }
  module.exports = _.assign({}, httpErrors, restErrors, {
    HttpError: HttpError,
    RestError: RestError,
    makeConstructor: makeConstructor,
    makeErrFromCode: makeErrFromCode,
    codeToHttpError: makeErrFromCode
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("69", ["169"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('169');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("16a", ["59", "5a", "151", "69"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var sprintf = $__require('59').format;
  var assert = $__require('5a');
  var LRU = $__require('151');
  var errors = $__require('69');
  var TooManyRequestsError = errors.TooManyRequestsError;
  var MESSAGE = 'You have exceeded your request rate of %s r/s.';
  function xor() {
    var x = false;
    for (var i = 0; i < arguments.length; i++) {
      if (arguments[i] && !x) {
        x = true;
      } else if (arguments[i] && x) {
        return (false);
      }
    }
    return (x);
  }
  function TokenBucket(options) {
    assert.object(options, 'options');
    assert.number(options.capacity, 'options.capacity');
    assert.number(options.fillRate, 'options.fillRate');
    this.tokens = this.capacity = options.capacity;
    this.fillRate = options.fillRate;
    this.time = Date.now();
  }
  TokenBucket.prototype.consume = function consume(tokens) {
    if (tokens <= this._fill()) {
      this.tokens -= tokens;
      return (true);
    }
    return (false);
  };
  TokenBucket.prototype._fill = function _fill() {
    var now = Date.now();
    if (now < this.time) {
      this.time = now - 1000;
    }
    if (this.tokens < this.capacity) {
      var delta = this.fillRate * ((now - this.time) / 1000);
      this.tokens = Math.min(this.capacity, this.tokens + delta);
    }
    this.time = now;
    return (this.tokens);
  };
  function TokenTable(options) {
    assert.object(options, 'options');
    this.table = new LRU(options.size || 10000);
  }
  TokenTable.prototype.put = function put(key, value) {
    this.table.set(key, value);
  };
  TokenTable.prototype.get = function get(key) {
    return (this.table.get(key));
  };
  function throttle(options) {
    assert.object(options, 'options');
    assert.number(options.burst, 'options.burst');
    assert.number(options.rate, 'options.rate');
    if (!xor(options.ip, options.xff, options.username)) {
      throw new Error('(ip ^ username ^ xff)');
    }
    var table = options.tokensTable || new TokenTable({size: options.maxKeys});
    function rateLimit(req, res, next) {
      var attr;
      var burst = options.burst;
      var rate = options.rate;
      if (options.ip) {
        attr = req.connection.remoteAddress;
      } else if (options.xff) {
        attr = req.headers['x-forwarded-for'];
      } else if (options.username) {
        attr = req.username;
      } else {
        req.log.warn({config: options}, 'Invalid throttle configuration');
        return (next());
      }
      if (!attr) {
        return (next());
      }
      if (options.overrides && options.overrides[attr] && options.overrides[attr].burst !== undefined && options.overrides[attr].rate !== undefined) {
        burst = options.overrides[attr].burst;
        rate = options.overrides[attr].rate;
      }
      if (!rate || !burst) {
        return (next());
      }
      var bucket = table.get(attr);
      if (!bucket) {
        bucket = new TokenBucket({
          capacity: burst,
          fillRate: rate
        });
        table.put(attr, bucket);
      }
      req.log.trace('Throttle(%s): num_tokens= %d', attr, bucket.tokens);
      if (!bucket.consume(1)) {
        req.log.info({
          address: req.connection.remoteAddress || '?',
          method: req.method,
          url: req.url,
          user: req.username || '?'
        }, 'Throttling');
        var msg = sprintf(MESSAGE, rate);
        return (next(new TooManyRequestsError(msg)));
      }
      return (next());
    }
    return (rateLimit);
  }
  module.exports = throttle;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("16b", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function pauseStream(stream) {
    function _buffer(chunk) {
      stream.__buffered.push(chunk);
    }
    function _catchEnd(chunk) {
      stream.__rstfyEnded = true;
    }
    stream.__rstfyEnded = false;
    stream.__rstfyPaused = true;
    stream.__buffered = [];
    stream.on('data', _buffer);
    stream.once('end', _catchEnd);
    stream.pause();
    stream._resume = stream.resume;
    stream.resume = function _rstfy_resume() {
      if (!stream.__rstfyPaused) {
        return;
      }
      stream.removeListener('data', _buffer);
      stream.removeListener('end', _catchEnd);
      stream.__buffered.forEach(stream.emit.bind(stream, 'data'));
      stream.__buffered.length = 0;
      stream._resume();
      stream.resume = stream._resume;
      if (stream.__rstfyEnded) {
        stream.emit('end');
      }
    };
  }
  module.exports = function pause() {
    function prePause(req, res, next) {
      pauseStream(req);
      next();
    }
    return (prePause);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("16c", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function strip(path) {
    var cur;
    var next;
    var str = '';
    for (var i = 0; i < path.length; i++) {
      cur = path.charAt(i);
      if (i !== path.length - 1) {
        next = path.charAt(i + 1);
      }
      if (cur === '/' && (next === '/' || (next === '?' && i > 0))) {
        continue;
      }
      str += cur;
    }
    return (str);
  }
  function sanitizePath(options) {
    function _sanitizePath(req, res, next) {
      req.url = strip(req.url);
      next();
    }
    return (_sanitizePath);
  }
  module.exports = sanitizePath;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("16d", ["71", "58", "59", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var assert = $__require('71');
    var Stream = $__require('58').Stream;
    var util = $__require('59');
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    function _capitalize(str) {
      return (str.charAt(0).toUpperCase() + str.slice(1));
    }
    function _toss(name, expected, oper, arg, actual) {
      throw new assert.AssertionError({
        message: util.format('%s (%s) is required', name, expected),
        actual: (actual === undefined) ? typeof(arg) : actual(arg),
        expected: expected,
        operator: oper || '===',
        stackStartFunction: _toss.caller
      });
    }
    function _getClass(arg) {
      return (Object.prototype.toString.call(arg).slice(8, -1));
    }
    function noop() {}
    var types = {
      bool: {check: function(arg) {
          return typeof(arg) === 'boolean';
        }},
      func: {check: function(arg) {
          return typeof(arg) === 'function';
        }},
      string: {check: function(arg) {
          return typeof(arg) === 'string';
        }},
      object: {check: function(arg) {
          return typeof(arg) === 'object' && arg !== null;
        }},
      number: {check: function(arg) {
          return typeof(arg) === 'number' && !isNaN(arg) && isFinite(arg);
        }},
      buffer: {
        check: function(arg) {
          return Buffer.isBuffer(arg);
        },
        operator: 'Buffer.isBuffer'
      },
      array: {
        check: function(arg) {
          return Array.isArray(arg);
        },
        operator: 'Array.isArray'
      },
      stream: {
        check: function(arg) {
          return arg instanceof Stream;
        },
        operator: 'instanceof',
        actual: _getClass
      },
      date: {
        check: function(arg) {
          return arg instanceof Date;
        },
        operator: 'instanceof',
        actual: _getClass
      },
      regexp: {
        check: function(arg) {
          return arg instanceof RegExp;
        },
        operator: 'instanceof',
        actual: _getClass
      },
      uuid: {
        check: function(arg) {
          return typeof(arg) === 'string' && UUID_REGEXP.test(arg);
        },
        operator: 'isUUID'
      }
    };
    function _setExports(ndebug) {
      var keys = Object.keys(types);
      var out;
      if (process.env.NODE_NDEBUG) {
        out = noop;
      } else {
        out = function(arg, msg) {
          if (!arg) {
            _toss(msg, 'true', arg);
          }
        };
      }
      keys.forEach(function(k) {
        if (ndebug) {
          out[k] = noop;
          return;
        }
        var type = types[k];
        out[k] = function(arg, msg) {
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = 'optional' + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        out[name] = function(arg, msg) {
          if (arg === undefined || arg === null) {
            return;
          }
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = 'arrayOf' + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = '[' + k + ']';
        out[name] = function(arg, msg) {
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      keys.forEach(function(k) {
        var name = 'optionalArrayOf' + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = '[' + k + ']';
        out[name] = function(arg, msg) {
          if (arg === undefined || arg === null) {
            return;
          }
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      Object.keys(assert).forEach(function(k) {
        if (k === 'AssertionError') {
          out[k] = assert[k];
          return;
        }
        if (ndebug) {
          out[k] = noop;
          return;
        }
        out[k] = assert[k];
      });
      out._setExports = _setExports;
      return out;
    }
    module.exports = _setExports(process.env.NODE_NDEBUG);
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5a", ["16d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('16d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("16e", ["5a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('5a');
  function userAgentConnection(options) {
    var opts = options || {};
    assert.optionalObject(opts, 'options');
    assert.optionalObject(opts.userAgentRegExp, 'options.userAgentRegExp');
    var re = opts.userAgentRegExp;
    if (!re) {
      re = /^curl.+/;
    }
    function handleUserAgent(req, res, next) {
      var ua = req.headers['user-agent'];
      if (ua && re.test(ua)) {
        res.setHeader('Connection', 'close');
      }
      if (req.method === 'HEAD') {
        res.once('header', res.removeHeader.bind(res, 'content-length'));
      }
      next();
    }
    return (handleUserAgent);
  }
  module.exports = userAgentConnection;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("16f", ["dd", "e3", "f7", "109", "10e", "10f", "110", "10c", "113", "114", "116", "10b", "10d", "145", "146", "14f", "16a", "16b", "16c", "16e"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    acceptParser: $__require('dd'),
    auditLogger: $__require('e3'),
    authorizationParser: $__require('f7'),
    bodyParser: $__require('109'),
    conditionalRequest: $__require('10e'),
    dateParser: $__require('10f'),
    jsonp: $__require('110'),
    urlEncodedBodyParser: $__require('10c'),
    requestLogger: $__require('113'),
    gzipResponse: $__require('114'),
    fullResponse: $__require('116'),
    jsonBodyParser: $__require('10b'),
    multipartBodyParser: $__require('10d'),
    queryParser: $__require('145'),
    requestExpiry: $__require('146'),
    serveStatic: $__require('14f'),
    throttle: $__require('16a'),
    pre: {
      pause: $__require('16b'),
      sanitizePath: $__require('16c'),
      userAgentConnection: $__require('16e')
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("170", ["16f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('16f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("171", ["9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var DTraceProvider;
    function DTraceProviderStub() {}
    DTraceProviderStub.prototype.addProbe = function(name) {
      var p = {'fire': function() {}};
      this[name] = p;
      return (p);
    };
    DTraceProviderStub.prototype.enable = function() {};
    DTraceProviderStub.prototype.fire = function() {};
    DTraceProviderStub.prototype.disable = function() {};
    var builds = ['Release', 'default', 'Debug'];
    for (var i in builds) {
      try {
        var binding = $__require('./build/' + builds[i] + '/DTraceProviderBindings');
        DTraceProvider = binding.DTraceProvider;
        break;
      } catch (e) {
        if (process.platform == 'darwin' || process.platform == 'solaris' || process.platform == 'freebsd') {
          console.error(e);
        }
      }
    }
    if (!DTraceProvider) {
      DTraceProvider = DTraceProviderStub;
    }
    exports.DTraceProvider = DTraceProvider;
    exports.createDTraceProvider = function(name, module) {
      if (arguments.length == 2)
        return (new exports.DTraceProvider(name, module));
      return (new exports.DTraceProvider(name));
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("172", ["171"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('171');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("173", ["172"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ID = 0;
  var MAX_INT = Math.pow(2, 32) - 1;
  var PROVIDER;
  var PROBES = {
    'recv-text': ['int', 'char *', 'char *', 'char *', 'int'],
    'recv-binary': ['int', 'char *', 'char *', 'char *', 'int'],
    'recv-close': ['int', 'char *', 'char *', 'char *', 'int'],
    'send-text': ['int', 'char *', 'char *', 'char *', 'int'],
    'send-binary': ['int', 'char *', 'char *', 'char *', 'int'],
    'send-close': ['int', 'char *', 'char *', 'char *', 'int'],
    'read-buffer': ['int', 'char *', 'char *', 'char *', 'int'],
    'start': ['int', 'char *', 'char *', 'char *'],
    'end': ['int', 'char *', 'char *', 'char *', 'char *']
  };
  function exportStaticProvider() {
    if (PROVIDER)
      return (PROVIDER);
    try {
      var mod_dtrace = $__require('172');
      PROVIDER = mod_dtrace.createDTraceProvider('watershed');
    } catch (e) {
      PROVIDER = {
        fire: function() {},
        enable: function() {},
        addProbe: function() {
          var p = {fire: function() {}};
          return (p);
        },
        removeProbe: function() {},
        disable: function() {}
      };
    }
    PROVIDER._watershed_probes = {};
    Object.keys(PROBES).forEach(function(probename) {
      var args = PROBES[probename].splice(0);
      args.unshift(probename);
      var probe = PROVIDER.addProbe.apply(PROVIDER, args);
      PROVIDER._watershed_probes[probename] = probe;
    });
    PROVIDER.enable();
    PROVIDER.nextId = function nextId() {
      if (++ID >= MAX_INT)
        ID = 1;
      return (ID);
    };
    return (PROVIDER);
  }
  module.exports = exportStaticProvider();
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("174", ["1a", "58", "59", "fc", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    module.exports = Readable;
    Readable.ReadableState = ReadableState;
    var EE = $__require('1a').EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = $__require('58');
    var util = $__require('59');
    var StringDecoder;
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.calledRead = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.objectMode = !!options.objectMode;
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = $__require('fc').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk) {
      var state = this._readableState;
      if (typeof chunk === 'string' && !state.objectMode)
        chunk = new Buffer(chunk, arguments[1]);
      return readableAddChunk(this, state, chunk, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      if (typeof chunk === 'string' && !state.objectMode)
        chunk = new Buffer(chunk, arguments[1]);
      return readableAddChunk(this, state, chunk, true);
    };
    function readableAddChunk(stream, state, chunk, addToFront) {
      state.reading = false;
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null || chunk === undefined) {
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
        maybeReadMore(stream, state);
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = $__require('fc').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
    };
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (isNaN(n) || n === null) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && state.length >= state.highWaterMark) {
        emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      if (state.length - n <= state.highWaterMark)
        doRead = true;
      if (state.ended || state.reading)
        doRead = false;
      if (doRead) {
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer.isBuffer(chunk) && 'string' !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode && !er) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    function onEofChunk(stream, state) {
      state.ended = true;
      if (state.decoder && state.decoder.end) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      stream.emit('readable');
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once('end', endFn);
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        if (readable !== src)
          return;
        cleanup();
      }
      function onend() {
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      function cleanup() {
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
      function onerror(er) {
        unpipe();
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      dest.once('error', onerror);
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
      function unpipe() {
        src.unpipe(dest);
      }
      dest.emit('pipe', src);
      if (!state.flowing) {
        this.on('readable', pipeOnReadable);
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
      function write(dest, i, list) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
      while (state.pipesCount && null !== (chunk = src.read())) {
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          state.pipes.forEach(write);
        src.emit('data', chunk);
        if (state.awaitDrain > 0)
          return;
      }
      if (state.pipesCount === 0) {
        state.flowing = false;
        if (EE.listenerCount(src, 'data') > 0)
          emitDataEvents(src);
        return;
      }
      state.ranOut = true;
    }
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
      var i = state.pipes.indexOf(dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit('unpipe', this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === 'data' && !this._readableState.flowing)
        emitDataEvents(this);
      if (ev === 'readable' && !this._readableState.reading)
        this.read(0);
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit('resume');
    };
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit('pause');
    };
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
      if (state.flowing) {
        throw new Error('Cannot switch to old mode now.');
      }
      var paused = startPaused || false;
      var readable = false;
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
      stream.on('readable', function() {
        readable = true;
        var c;
        while (!paused && (null !== (c = stream.read())))
          stream.emit('data', c);
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
      stream.pause = function() {
        paused = true;
        this.emit('pause');
      };
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit('readable');
          });
        else
          this.read(0);
        this.emit('resume');
      };
      stream.emit('readable');
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on('end', function() {
        state.ended = true;
        if (state.decoder && state.decoder.end) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
        self.push(null);
      });
      stream.on('data', function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (!chunk || !chunk.length)
          return;
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (typeof stream[i] === 'function' && typeof this[i] === 'undefined') {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      events.forEach(function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
      self._read = function(n) {
        if (paused) {
          stream.resume();
          paused = false;
        }
      };
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
          var c = 0;
          for (var i = 0,
              l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        state.endEmitted = true;
        process.nextTick(function() {
          stream.readable = false;
          stream.emit('end');
        });
      }
    }
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("175", ["176", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    function compare(a, b) {
      if (a === b) {
        return 0;
      }
      var x = a.length;
      var y = b.length;
      for (var i = 0,
          len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    }
    function isBuffer(b) {
      if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
        return global.Buffer.isBuffer(b);
      }
      return !!(b != null && b._isBuffer);
    }
    var util = $__require('176');
    var hasOwn = Object.prototype.hasOwnProperty;
    var pSlice = Array.prototype.slice;
    var functionsHaveNames = (function() {
      return function foo() {}.name === 'foo';
    }());
    function pToString(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isView(arrbuf) {
      if (isBuffer(arrbuf)) {
        return false;
      }
      if (typeof global.ArrayBuffer !== 'function') {
        return false;
      }
      if (typeof ArrayBuffer.isView === 'function') {
        return ArrayBuffer.isView(arrbuf);
      }
      if (!arrbuf) {
        return false;
      }
      if (arrbuf instanceof DataView) {
        return true;
      }
      if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
        return true;
      }
      return false;
    }
    var assert = module.exports = ok;
    var regex = /\s*function\s+([^\(\s]*)\s*/;
    function getName(func) {
      if (!util.isFunction(func)) {
        return;
      }
      if (functionsHaveNames) {
        return func.name;
      }
      var str = func.toString();
      var match = str.match(regex);
      return match && match[1];
    }
    assert.AssertionError = function AssertionError(options) {
      this.name = 'AssertionError';
      this.actual = options.actual;
      this.expected = options.expected;
      this.operator = options.operator;
      if (options.message) {
        this.message = options.message;
        this.generatedMessage = false;
      } else {
        this.message = getMessage(this);
        this.generatedMessage = true;
      }
      var stackStartFunction = options.stackStartFunction || fail;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, stackStartFunction);
      } else {
        var err = new Error();
        if (err.stack) {
          var out = err.stack;
          var fn_name = getName(stackStartFunction);
          var idx = out.indexOf('\n' + fn_name);
          if (idx >= 0) {
            var next_line = out.indexOf('\n', idx + 1);
            out = out.substring(next_line + 1);
          }
          this.stack = out;
        }
      }
    };
    util.inherits(assert.AssertionError, Error);
    function truncate(s, n) {
      if (typeof s === 'string') {
        return s.length < n ? s : s.slice(0, n);
      } else {
        return s;
      }
    }
    function inspect(something) {
      if (functionsHaveNames || !util.isFunction(something)) {
        return util.inspect(something);
      }
      var rawname = getName(something);
      var name = rawname ? ': ' + rawname : '';
      return '[Function' + name + ']';
    }
    function getMessage(self) {
      return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
    }
    function fail(actual, expected, message, operator, stackStartFunction) {
      throw new assert.AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: operator,
        stackStartFunction: stackStartFunction
      });
    }
    assert.fail = fail;
    function ok(value, message) {
      if (!value)
        fail(value, true, message, '==', assert.ok);
    }
    assert.ok = ok;
    assert.equal = function equal(actual, expected, message) {
      if (actual != expected)
        fail(actual, expected, message, '==', assert.equal);
    };
    assert.notEqual = function notEqual(actual, expected, message) {
      if (actual == expected) {
        fail(actual, expected, message, '!=', assert.notEqual);
      }
    };
    assert.deepEqual = function deepEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'deepEqual', assert.deepEqual);
      }
    };
    assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
      }
    };
    function _deepEqual(actual, expected, strict, memos) {
      if (actual === expected) {
        return true;
      } else if (isBuffer(actual) && isBuffer(expected)) {
        return compare(actual, expected) === 0;
      } else if (util.isDate(actual) && util.isDate(expected)) {
        return actual.getTime() === expected.getTime();
      } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
        return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
      } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
        return strict ? actual === expected : actual == expected;
      } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
        return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
      } else if (isBuffer(actual) !== isBuffer(expected)) {
        return false;
      } else {
        memos = memos || {
          actual: [],
          expected: []
        };
        var actualIndex = memos.actual.indexOf(actual);
        if (actualIndex !== -1) {
          if (actualIndex === memos.expected.indexOf(expected)) {
            return true;
          }
        }
        memos.actual.push(actual);
        memos.expected.push(expected);
        return objEquiv(actual, expected, strict, memos);
      }
    }
    function isArguments(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    function objEquiv(a, b, strict, actualVisitedObjects) {
      if (a === null || a === undefined || b === null || b === undefined)
        return false;
      if (util.isPrimitive(a) || util.isPrimitive(b))
        return a === b;
      if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
        return false;
      var aIsArgs = isArguments(a);
      var bIsArgs = isArguments(b);
      if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
        return false;
      if (aIsArgs) {
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b, strict);
      }
      var ka = objectKeys(a);
      var kb = objectKeys(b);
      var key,
          i;
      if (ka.length !== kb.length)
        return false;
      ka.sort();
      kb.sort();
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] !== kb[i])
          return false;
      }
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
          return false;
      }
      return true;
    }
    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
      }
    };
    assert.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
      }
    }
    assert.strictEqual = function strictEqual(actual, expected, message) {
      if (actual !== expected) {
        fail(actual, expected, message, '===', assert.strictEqual);
      }
    };
    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (actual === expected) {
        fail(actual, expected, message, '!==', assert.notStrictEqual);
      }
    };
    function expectedException(actual, expected) {
      if (!actual || !expected) {
        return false;
      }
      if (Object.prototype.toString.call(expected) == '[object RegExp]') {
        return expected.test(actual);
      }
      try {
        if (actual instanceof expected) {
          return true;
        }
      } catch (e) {}
      if (Error.isPrototypeOf(expected)) {
        return false;
      }
      return expected.call({}, actual) === true;
    }
    function _tryBlock(block) {
      var error;
      try {
        block();
      } catch (e) {
        error = e;
      }
      return error;
    }
    function _throws(shouldThrow, block, expected, message) {
      var actual;
      if (typeof block !== 'function') {
        throw new TypeError('"block" argument must be a function');
      }
      if (typeof expected === 'string') {
        message = expected;
        expected = null;
      }
      actual = _tryBlock(block);
      message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');
      if (shouldThrow && !actual) {
        fail(actual, expected, 'Missing expected exception' + message);
      }
      var userProvidedMessage = typeof message === 'string';
      var isUnwantedException = !shouldThrow && util.isError(actual);
      var isUnexpectedException = !shouldThrow && actual && !expected;
      if ((isUnwantedException && userProvidedMessage && expectedException(actual, expected)) || isUnexpectedException) {
        fail(actual, expected, 'Got unwanted exception' + message);
      }
      if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) {
        throw actual;
      }
    }
    assert.throws = function(block, error, message) {
      _throws(true, block, error, message);
    };
    assert.doesNotThrow = function(block, error, message) {
      _throws(false, block, error, message);
    };
    assert.ifError = function(err) {
      if (err)
        throw err;
    };
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj) {
        if (hasOwn.call(obj, key))
          keys.push(key);
      }
      return keys;
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("177", ["175"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('175');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("178", ["177"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('assert') : $__require('177');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("71", ["178"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('178');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("179", ["59", "71", "58", "17a", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    module.exports = Writable;
    Writable.WritableState = WritableState;
    var util = $__require('59');
    var assert = $__require('71');
    var Stream = $__require('58');
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
      this.objectMode = !!options.objectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.length = 0;
      this.writing = false;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
    }
    function Writable(options) {
      if (!(this instanceof Writable) && !(this instanceof $__require('17a')))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      stream.emit('error', er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer.isBuffer(chunk) && 'string' !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (!encoding)
        encoding = 'utf8';
      if (typeof cb !== 'function')
        cb = function() {};
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      return ret;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      state.needDrain = !ret;
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
      stream.emit('error', er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = finishMaybe(stream, state);
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, len, chunk, encoding, cb);
        if (state.writing) {
          c++;
          break;
        }
      }
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (typeof chunk !== 'undefined' && chunk !== null)
        this.write(chunk, encoding);
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function finishMaybe(stream, state) {
      if (state.ending && state.length === 0 && !state.finished) {
        state.finished = true;
        stream.emit('finish');
      }
      return state.finished;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("17a", ["59", "174", "179", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    module.exports = Duplex;
    var util = $__require('59');
    var Readable = $__require('174');
    var Writable = $__require('179');
    util.inherits(Duplex, Readable);
    Object.keys(Writable.prototype).forEach(function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once('end', onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("17b", ["17a", "59", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    module.exports = Transform;
    var Duplex = $__require('17a');
    var util = $__require('59');
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      var ts = this;
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== undefined)
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      var ts = this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once('finish', function() {
        if ('function' === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk);
    };
    Transform.prototype._transform = function(chunk, output, cb) {
      throw new Error('not implemented');
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
      return stream.push(null);
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("17c", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("17d", ["17c", "ad", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%')
          return '%';
        if (i >= len)
          return x;
        switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (isUndefined(global.process)) {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnviron;
    exports.debuglog = function(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
          array = false,
          braces = ['{', '}'];
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0,
          l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name,
          str,
          desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = $__require('17c');
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }
    exports.log = function() {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = $__require('ad');
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("176", ["17d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('17d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("17e", ["176"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('util') : $__require('176');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("59", ["17e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('17e');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("17f", ["17b", "59"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = PassThrough;
  var Transform = $__require('17b');
  var util = $__require('59');
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("180", ["174", "179", "17a", "17b", "17f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports = module.exports = $__require('174');
  exports.Readable = exports;
  exports.Writable = $__require('179');
  exports.Duplex = $__require('17a');
  exports.Transform = $__require('17b');
  exports.PassThrough = $__require('17f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("181", ["180"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('180');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("182", ["cd", "71", "1a", "59", "58", "173", "181", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var crypto = $__require('cd');
    var assert = $__require('71');
    var EventEmitter = $__require('1a').EventEmitter;
    var util = $__require('59');
    var stream = $__require('58');
    var dtrace = $__require('173');
    var WRAP_SOCKETS = false;
    if (!stream.Readable) {
      WRAP_SOCKETS = true;
      stream = $__require('181');
    }
    var MAGIC_WEBSOCKET_UUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
    var NONCE_LENGTH = 16;
    var OPCODE = {
      CONT: 0x0,
      TEXT: 0x1,
      BINARY: 0x2,
      CLOSE: 0x8,
      PING: 0x9,
      PONG: 0xA
    };
    var CLOSECODE = {
      NORMAL: 1000,
      GOING_AWAY: 1001,
      PROTOCOL_ERROR: 1002,
      UNACCEPTABLE: 1003,
      MALFORMED: 1007,
      POLICY_VIOLATION: 1008,
      TOO_BIG: 1009,
      MISSING_EXTENSION: 1010,
      UNEXPECTED_ERROR: 1011
    };
    function _sha1(str) {
      var hash = crypto.createHash('sha1');
      hash.update(str);
      return (hash.digest('base64'));
    }
    function _generateResponse(wskey) {
      var wsaccept = _sha1(wskey + MAGIC_WEBSOCKET_UUID);
      return (['HTTP/1.1 101 The Watershed Moment', 'Upgrade: websocket', 'Connection: Upgrade', 'Sec-WebSocket-Accept: ' + wsaccept].join('\r\n') + '\r\n\r\n');
    }
    ;
    function _wrapSocket(socket) {
      var ret = socket;
      if (WRAP_SOCKETS) {
        ret = new stream.Readable();
        ret.wrap(socket);
        socket.resume();
      }
      return (ret);
    }
    function _findCloseCode(code) {
      var keys = Object.keys(CLOSECODE);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (CLOSECODE[key] === code)
          return (key);
      }
      return (null);
    }
    function Watershed() {}
    Watershed.prototype.generateKey = function generateKey() {
      return crypto.randomBytes(NONCE_LENGTH).toString('base64');
    };
    Watershed.prototype.accept = function accept(req, socket, head, detached) {
      var remote = socket.remoteAddress + ':' + socket.remotePort;
      var local = socket.localAddress + ':' + socket.localPort;
      socket = _wrapSocket(socket);
      if (head && head.length > 0)
        socket.unshift(head);
      var upgrade = req.headers['upgrade'];
      if (!upgrade || upgrade.toLowerCase() !== 'websocket')
        throw (new Error('Missing Upgrade Header'));
      var wskey = req.headers['sec-websocket-key'];
      if (!wskey)
        throw (new Error('Missing Sec-WebSocket-Key Header'));
      var wsver = req.headers['sec-websocket-version'];
      if (wsver && wsver !== '13')
        throw (new Error('Unsupported Sec-WebSocket-Version'));
      socket.write(_generateResponse(wskey));
      if (detached === true) {
        return (socket);
      }
      var options = {
        remoteMustMask: true,
        localShouldMask: false,
        type: 'accept',
        remote: remote,
        local: local
      };
      return (new WatershedConnection(options, socket));
    };
    Watershed.prototype.connect = function connect(res, socket, head, wskey, detached) {
      var remote = socket.remoteAddress + ':' + socket.remotePort;
      var local = socket.localAddress + ':' + socket.localPort;
      socket = _wrapSocket(socket);
      if (head && head.length > 0)
        socket.unshift(head);
      var connection = res.headers['connection'];
      if (!connection || connection.toLowerCase() !== 'upgrade')
        throw (new Error('Missing Connection Header'));
      var upgrade = res.headers['upgrade'];
      if (!upgrade || upgrade.toLowerCase() !== 'websocket')
        throw (new Error('Missing Upgrade Header'));
      var wsaccept = res.headers['sec-websocket-accept'];
      if (!wsaccept || wsaccept !== _sha1(wskey + MAGIC_WEBSOCKET_UUID))
        throw (new Error('Missing Sec-WebSocket-Accept Header'));
      var wsver = res.headers['sec-websocket-version'];
      if (wsver && wsver !== '13')
        throw (new Error('Unsupported Sec-WebSocket-Version'));
      if (detached === true) {
        return (socket);
      }
      var options = {
        remoteMustMask: false,
        localShouldMask: true,
        type: 'connect',
        remote: remote,
        local: local
      };
      return (new WatershedConnection(options, socket));
    };
    function WatershedConnection(options, socket) {
      var self = this;
      EventEmitter.call(this);
      self._id = dtrace.nextId();
      self._data = new Buffer(0);
      self._stats = {
        receivedFrames: 0,
        sentFrames: 0
      };
      self._close_written = false;
      self._close_received = false;
      self._end_emitted = false;
      self._close_code = null;
      self._close_reason = null;
      self._options = options;
      self._socket = socket;
      self._remote = options.remote;
      self._local = options.local;
      self._check_for_http_header = true;
      dtrace._watershed_probes['start'].fire(function() {
        return ([self._id, self._remote, self._local, options.type]);
      });
      self.on('end', function(code, reason) {
        dtrace._watershed_probes['end'].fire(function() {
          return ([self._id, self._remote, self._local, self._close_code, self._close_reason]);
        });
      });
      self._outofconstructor = false;
      process.nextTick(function() {
        self._outofconstructor = true;
        self._ws_readFromSocket();
      });
      self._socket.on('readable', function() {
        if (!self._outofconstructor)
          return;
        self._ws_readFromSocket();
      });
      self._socket.on('end', function() {
        if (!self._close_received)
          self.emit('connectionReset');
        if (self._end_emitted)
          return;
        self._end_emitted = true;
        self.emit('end', self._close_code, self._close_reason);
      });
      self._socket.on('error', function(err) {
        if (self._end_emitted)
          return;
        self._end_emitted = true;
        if (err.code === 'ECONNRESET' || err.code === 'EPIPE') {
          if (!self._close_received)
            self.emit('connectionReset');
          self.emit('end', self._close_code, self._close_reason);
          return;
        }
        self.emit('error', err);
        self.emit('end');
      });
    }
    util.inherits(WatershedConnection, EventEmitter);
    WatershedConnection.prototype.end = function end(reason) {
      if (this._close_written)
        return;
      this._close_written = true;
      this._ws_writeClose(CLOSECODE.NORMAL, reason);
    };
    WatershedConnection.prototype.destroy = function destroy() {
      if (this._socket !== null) {
        this._socket.removeAllListeners();
        this._socket.destroy();
        this._socket = null;
      }
      if (!this._end_emitted) {
        this.emit('end', this._close_code, this._close_reason);
        this._end_emitted = true;
      }
    };
    WatershedConnection.prototype.send = function send(data) {
      assert(typeof(data) === 'string' || Buffer.isBuffer(data));
      if (Buffer.isBuffer(data)) {
        this._ws_writeBinary(data);
      } else {
        this._ws_writeText(data);
      }
    };
    WatershedConnection.prototype._ws_readFromSocket = function _ws_readFromSocket() {
      while (!this._end_emitted) {
        if (this._ws_readFrame()) {
          this._stats.receivedFrames++;
        } else {
          break;
        }
      }
    };
    WatershedConnection.prototype._ws_pullup = function _ws_pullup(len) {
      var self = this;
      var buf;
      if (this._data.length >= len)
        return (true);
      buf = this._socket.read(len !== null ? len - this._data.length : null);
      if (buf === null)
        return (false);
      dtrace._watershed_probes['read-buffer'].fire(function() {
        return ([self._id, self._remote, self._local, buf.toString('binary'), buf.length]);
      });
      this._data = Buffer.concat([this._data, buf], this._data.length + buf.length);
      return (true);
    };
    WatershedConnection.prototype._ws_writeBinary = function _ws_writeBinary(buffer) {
      var self = this;
      assert(Buffer.isBuffer(buffer));
      dtrace._watershed_probes['send-binary'].fire(function() {
        return ([self._id, self._remote, self._local, buffer.toString('binary'), buffer.length]);
      });
      this._ws_writeFrameCommon(OPCODE.BINARY, buffer);
    };
    WatershedConnection.prototype._ws_writeText = function _ws_writeText(text) {
      var self = this;
      assert(typeof(text) === 'string');
      dtrace._watershed_probes['send-text'].fire(function() {
        return ([self._id, self._remote, self._local, text, text.length]);
      });
      this._ws_writeFrameCommon(OPCODE.TEXT, new Buffer(text, 'utf8'));
    };
    WatershedConnection.prototype._ws_writeClose = function _ws_writeClose(code, reason) {
      var self = this;
      var buf;
      assert(code >= 1000);
      if (reason) {
        assert(typeof(reason) === 'string');
        buf = new Buffer(2 + Buffer.byteLength(reason, 'utf8'));
        buf.write(reason, 2);
      } else {
        buf = new Buffer(2);
      }
      buf.writeUInt16BE(code, 0);
      dtrace._watershed_probes['send-close'].fire(function() {
        return ([self._id, self._remote, self._local, buf.toString('binary'), buf.length]);
      });
      this._ws_writeFrameCommon(OPCODE.CLOSE, buf);
    };
    WatershedConnection.prototype._ws_writePing = function _ws_writePing(nonce) {
      this._ws_writeFrameCommon(OPCODE.PING, nonce);
    };
    WatershedConnection.prototype._ws_writePong = function _ws_writePong(nonce) {
      this._ws_writeFrameCommon(OPCODE.PONG, nonce);
    };
    WatershedConnection.prototype._ws_writeFrameCommon = function _ws_writeFrameCommon(opcode, data) {
      var maskbuf = null;
      var hdr;
      var obj = {
        fin: true,
        opcode: opcode
      };
      assert(Buffer.isBuffer(data));
      if (this._options.localShouldMask) {
        maskbuf = new Buffer(4);
        for (var i = 0; i < maskbuf.length; i++) {
          maskbuf[i] = Math.floor(Math.random * 256);
        }
        for (var i = 0; i < data.length; i++) {
          data[i] = data[i] ^ maskbuf[i % maskbuf.length];
        }
      }
      if (data.length <= 125) {
        hdr = new Buffer(2);
        obj.len0 = data.length;
      } else if (data.length <= 0xffff) {
        hdr = new Buffer(2 + 2);
        obj.len0 = 126;
        hdr.writeUInt16BE(data.length, 2);
      } else if (data.length <= 0xffffffff) {
        hdr = new Buffer(2 + 8);
        obj.len0 = 127;
        hdr.writeUInt32BE(0, 2);
        hdr.writeUInt32BE(data.length, 6);
      } else {
        throw (new Error('Frame payload must have length less ' + 'than 32-bits'));
      }
      var w0 = obj.fin ? (1 << 15) : 0;
      w0 |= (obj.opcode << 8) & 0x0f00;
      w0 |= obj.len0 & 0x007f;
      w0 |= maskbuf !== null ? (1 << 7) : 0;
      hdr.writeUInt16BE(w0, 0);
      this._socket.write(hdr);
      if (maskbuf !== null)
        this._socket.write(maskbuf);
      this._socket.write(data);
      this._stats.sentFrames++;
    };
    WatershedConnection.prototype._ws_readFrame = function _ws_readFrame() {
      var self = this;
      var pos = 0;
      if (!this._ws_pullup(pos + 2))
        return (false);
      var w0 = this._data.readUInt16BE(pos);
      pos += 2;
      if (this._check_for_http_header) {
        if (this._data.toString('utf8', 0, 2) === 'HT') {
          throw (new Error('POSSIBLE NODE/STREAMS BUG'));
        }
      }
      var obj = {
        fin: !!(w0 & (1 << 15)),
        opcode: (w0 & 0x0f00) >> 8,
        mask: !!(w0 & (1 << 7)),
        len0: w0 & 0x007f,
        maskbytes: []
      };
      if (this._options.remoteMustMask && !obj.mask) {
        this._end_emitted = true;
        this.emit('error', new Error('Client did not Mask according ' + 'to the RFC.'));
        this.emit('end');
        this._socket.end();
        return (false);
      }
      if (!obj.fin) {
        this.end();
        return (false);
      }
      assert(obj.len0 >= 0 && obj.len0 <= 127);
      if (obj.len0 <= 125) {
        obj.len = obj.len0;
      } else if (obj.len0 === 126) {
        if (!this._ws_pullup(pos + 2))
          return (false);
        obj.len = this._data.readUInt16BE(pos);
        pos += 2;
      } else {
        if (!this._ws_pullup(pos + 4))
          return (false);
        obj.len = this._data.readUInt32BE(pos);
        pos += 4;
        if (obj.len !== 0) {
          this._end_emitted = true;
          this.emit('error', new Error('Client tried to send ' + 'too long a frame.'));
          this.emit('end');
          this._socket.end();
          return (false);
        }
        if (!this._ws_pullup(pos + 4))
          return (false);
        obj.len = this._data.readUInt32BE(pos);
        pos += 4;
      }
      if (obj.mask) {
        if (!this._ws_pullup(pos + 4))
          return (false);
        for (var i = 0; i < 4; i++) {
          obj.maskbytes.push(this._data.readUInt8(pos));
          pos++;
        }
      }
      if (!this._ws_pullup(pos + obj.len))
        return (false);
      obj.payload = this._data.slice(pos, pos + obj.len);
      pos += obj.len;
      if (obj.mask) {
        for (var i = 0; i < obj.payload.length; i++) {
          obj.payload[i] = obj.payload[i] ^ obj.maskbytes[i % 4];
        }
      }
      if (obj.opcode === OPCODE.CLOSE)
        this._close_received = true;
      if (obj.opcode === OPCODE.TEXT) {
        var stringOut = obj.payload.toString('utf8');
        dtrace._watershed_probes['recv-text'].fire(function() {
          return ([self._id, self._remote, self._local, stringOut, stringOut.length]);
        });
        this.emit('text', stringOut);
      } else if (obj.opcode === OPCODE.BINARY) {
        dtrace._watershed_probes['recv-binary'].fire(function() {
          return ([self._id, self._remote, self._local, obj.payload.toString('binary'), obj.payload.length]);
        });
        this.emit('binary', obj.payload);
      } else if (obj.opcode === OPCODE.PING) {
        this.emit('ping', obj.payload);
        this._ws_writePong(payload);
      } else if (obj.opcode === OPCODE.PONG) {
        this.emit('pong', obj.payload);
      } else if (obj.opcode === OPCODE.CLOSE) {
        dtrace._watershed_probes['recv-close'].fire(function() {
          return ([self._id, self._remote, self._local, obj.payload.toString('binary'), obj.payload.length]);
        });
        if (obj.payload.length >= 2) {
          this._close_code = _findCloseCode(obj.payload.readUInt16BE(0));
          this._close_reason = obj.payload.toString('utf8', 2);
        }
        this.end();
        this._socket.end();
      }
      this._data = this._data.slice(pos);
      return (true);
    };
    module.exports = {Watershed: Watershed};
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("183", ["182"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('182');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("184", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.readUInt32BE = function readUInt32BE(bytes, off) {
    var res = (bytes[0 + off] << 24) | (bytes[1 + off] << 16) | (bytes[2 + off] << 8) | bytes[3 + off];
    return res >>> 0;
  };
  exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
    bytes[0 + off] = value >>> 24;
    bytes[1 + off] = (value >>> 16) & 0xff;
    bytes[2 + off] = (value >>> 8) & 0xff;
    bytes[3 + off] = value & 0xff;
  };
  exports.ip = function ip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    for (var i = 6; i >= 0; i -= 2) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= (inR >>> (j + i)) & 1;
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= (inL >>> (j + i)) & 1;
      }
    }
    for (var i = 6; i >= 0; i -= 2) {
      for (var j = 1; j <= 25; j += 8) {
        outR <<= 1;
        outR |= (inR >>> (j + i)) & 1;
      }
      for (var j = 1; j <= 25; j += 8) {
        outR <<= 1;
        outR |= (inL >>> (j + i)) & 1;
      }
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  exports.rip = function rip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    for (var i = 0; i < 4; i++) {
      for (var j = 24; j >= 0; j -= 8) {
        outL <<= 1;
        outL |= (inR >>> (j + i)) & 1;
        outL <<= 1;
        outL |= (inL >>> (j + i)) & 1;
      }
    }
    for (var i = 4; i < 8; i++) {
      for (var j = 24; j >= 0; j -= 8) {
        outR <<= 1;
        outR |= (inR >>> (j + i)) & 1;
        outR <<= 1;
        outR |= (inL >>> (j + i)) & 1;
      }
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  exports.pc1 = function pc1(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    for (var i = 7; i >= 5; i--) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= (inR >> (j + i)) & 1;
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= (inL >> (j + i)) & 1;
      }
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var i = 1; i <= 3; i++) {
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= (inR >> (j + i)) & 1;
      }
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= (inL >> (j + i)) & 1;
      }
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  exports.r28shl = function r28shl(num, shift) {
    return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
  };
  var pc2table = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
  exports.pc2 = function pc2(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    var len = pc2table.length >>> 1;
    for (var i = 0; i < len; i++) {
      outL <<= 1;
      outL |= (inL >>> pc2table[i]) & 0x1;
    }
    for (var i = len; i < pc2table.length; i++) {
      outR <<= 1;
      outR |= (inR >>> pc2table[i]) & 0x1;
    }
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  exports.expand = function expand(r, out, off) {
    var outL = 0;
    var outR = 0;
    outL = ((r & 1) << 5) | (r >>> 27);
    for (var i = 23; i >= 15; i -= 4) {
      outL <<= 6;
      outL |= (r >>> i) & 0x3f;
    }
    for (var i = 11; i >= 3; i -= 4) {
      outR |= (r >>> i) & 0x3f;
      outR <<= 6;
    }
    outR |= ((r & 0x1f) << 1) | (r >>> 31);
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };
  var sTable = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
  exports.substitute = function substitute(inL, inR) {
    var out = 0;
    for (var i = 0; i < 4; i++) {
      var b = (inL >>> (18 - i * 6)) & 0x3f;
      var sb = sTable[i * 0x40 + b];
      out <<= 4;
      out |= sb;
    }
    for (var i = 0; i < 4; i++) {
      var b = (inR >>> (18 - i * 6)) & 0x3f;
      var sb = sTable[4 * 0x40 + i * 0x40 + b];
      out <<= 4;
      out |= sb;
    }
    return out >>> 0;
  };
  var permuteTable = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
  exports.permute = function permute(num) {
    var out = 0;
    for (var i = 0; i < permuteTable.length; i++) {
      out <<= 1;
      out |= (num >>> permuteTable[i]) & 0x1;
    }
    return out >>> 0;
  };
  exports.padSplit = function padSplit(num, size, group) {
    var str = num.toString(2);
    while (str.length < size)
      str = '0' + str;
    var out = [];
    for (var i = 0; i < size; i += group)
      out.push(str.slice(i, i + group));
    return out.join(' ');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("185", ["af", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var assert = $__require('af');
    function Cipher(options) {
      this.options = options;
      this.type = this.options.type;
      this.blockSize = 8;
      this._init();
      this.buffer = new Array(this.blockSize);
      this.bufferOff = 0;
    }
    module.exports = Cipher;
    Cipher.prototype._init = function _init() {};
    Cipher.prototype.update = function update(data) {
      if (data.length === 0)
        return [];
      if (this.type === 'decrypt')
        return this._updateDecrypt(data);
      else
        return this._updateEncrypt(data);
    };
    Cipher.prototype._buffer = function _buffer(data, off) {
      var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
      for (var i = 0; i < min; i++)
        this.buffer[this.bufferOff + i] = data[off + i];
      this.bufferOff += min;
      return min;
    };
    Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
      this._update(this.buffer, 0, out, off);
      this.bufferOff = 0;
      return this.blockSize;
    };
    Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
      var out = new Array(count * this.blockSize);
      if (this.bufferOff !== 0) {
        inputOff += this._buffer(data, inputOff);
        if (this.bufferOff === this.buffer.length)
          outputOff += this._flushBuffer(out, outputOff);
      }
      var max = data.length - ((data.length - inputOff) % this.blockSize);
      for (; inputOff < max; inputOff += this.blockSize) {
        this._update(data, inputOff, out, outputOff);
        outputOff += this.blockSize;
      }
      for (; inputOff < data.length; inputOff++, this.bufferOff++)
        this.buffer[this.bufferOff] = data[inputOff];
      return out;
    };
    Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
      var out = new Array(count * this.blockSize);
      for (; count > 0; count--) {
        inputOff += this._buffer(data, inputOff);
        outputOff += this._flushBuffer(out, outputOff);
      }
      inputOff += this._buffer(data, inputOff);
      return out;
    };
    Cipher.prototype.final = function final(buffer) {
      var first;
      if (buffer)
        first = this.update(buffer);
      var last;
      if (this.type === 'encrypt')
        last = this._finalEncrypt();
      else
        last = this._finalDecrypt();
      if (first)
        return first.concat(last);
      else
        return last;
    };
    Cipher.prototype._pad = function _pad(buffer, off) {
      if (off === 0)
        return false;
      while (off < buffer.length)
        buffer[off++] = 0;
      return true;
    };
    Cipher.prototype._finalEncrypt = function _finalEncrypt() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var out = new Array(this.blockSize);
      this._update(this.buffer, 0, out, 0);
      return out;
    };
    Cipher.prototype._unpad = function _unpad(buffer) {
      return buffer;
    };
    Cipher.prototype._finalDecrypt = function _finalDecrypt() {
      assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
      var out = new Array(this.blockSize);
      this._flushBuffer(out, 0);
      return this._unpad(out);
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("186", ["af", "ad", "187"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('af');
  var inherits = $__require('ad');
  var des = $__require('187');
  var utils = des.utils;
  var Cipher = des.Cipher;
  function DESState() {
    this.tmp = new Array(2);
    this.keys = null;
  }
  function DES(options) {
    Cipher.call(this, options);
    var state = new DESState();
    this._desState = state;
    this.deriveKeys(state, options.key);
  }
  inherits(DES, Cipher);
  module.exports = DES;
  DES.create = function create(options) {
    return new DES(options);
  };
  var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  DES.prototype.deriveKeys = function deriveKeys(state, key) {
    state.keys = new Array(16 * 2);
    assert.equal(key.length, this.blockSize, 'Invalid key length');
    var kL = utils.readUInt32BE(key, 0);
    var kR = utils.readUInt32BE(key, 4);
    utils.pc1(kL, kR, state.tmp, 0);
    kL = state.tmp[0];
    kR = state.tmp[1];
    for (var i = 0; i < state.keys.length; i += 2) {
      var shift = shiftTable[i >>> 1];
      kL = utils.r28shl(kL, shift);
      kR = utils.r28shl(kR, shift);
      utils.pc2(kL, kR, state.keys, i);
    }
  };
  DES.prototype._update = function _update(inp, inOff, out, outOff) {
    var state = this._desState;
    var l = utils.readUInt32BE(inp, inOff);
    var r = utils.readUInt32BE(inp, inOff + 4);
    utils.ip(l, r, state.tmp, 0);
    l = state.tmp[0];
    r = state.tmp[1];
    if (this.type === 'encrypt')
      this._encrypt(state, l, r, state.tmp, 0);
    else
      this._decrypt(state, l, r, state.tmp, 0);
    l = state.tmp[0];
    r = state.tmp[1];
    utils.writeUInt32BE(out, l, outOff);
    utils.writeUInt32BE(out, r, outOff + 4);
  };
  DES.prototype._pad = function _pad(buffer, off) {
    var value = buffer.length - off;
    for (var i = off; i < buffer.length; i++)
      buffer[i] = value;
    return true;
  };
  DES.prototype._unpad = function _unpad(buffer) {
    var pad = buffer[buffer.length - 1];
    for (var i = buffer.length - pad; i < buffer.length; i++)
      assert.equal(buffer[i], pad);
    return buffer.slice(0, buffer.length - pad);
  };
  DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
    var l = lStart;
    var r = rStart;
    for (var i = 0; i < state.keys.length; i += 2) {
      var keyL = state.keys[i];
      var keyR = state.keys[i + 1];
      utils.expand(r, state.tmp, 0);
      keyL ^= state.tmp[0];
      keyR ^= state.tmp[1];
      var s = utils.substitute(keyL, keyR);
      var f = utils.permute(s);
      var t = r;
      r = (l ^ f) >>> 0;
      l = t;
    }
    utils.rip(r, l, out, off);
  };
  DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
    var l = rStart;
    var r = lStart;
    for (var i = state.keys.length - 2; i >= 0; i -= 2) {
      var keyL = state.keys[i];
      var keyR = state.keys[i + 1];
      utils.expand(l, state.tmp, 0);
      keyL ^= state.tmp[0];
      keyR ^= state.tmp[1];
      var s = utils.substitute(keyL, keyR);
      var f = utils.permute(s);
      var t = l;
      l = (r ^ f) >>> 0;
      r = t;
    }
    utils.rip(l, r, out, off);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("188", ["af", "ad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('af');
  var inherits = $__require('ad');
  var proto = {};
  function CBCState(iv) {
    assert.equal(iv.length, 8, 'Invalid IV length');
    this.iv = new Array(8);
    for (var i = 0; i < this.iv.length; i++)
      this.iv[i] = iv[i];
  }
  function instantiate(Base) {
    function CBC(options) {
      Base.call(this, options);
      this._cbcInit();
    }
    inherits(CBC, Base);
    var keys = Object.keys(proto);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      CBC.prototype[key] = proto[key];
    }
    CBC.create = function create(options) {
      return new CBC(options);
    };
    return CBC;
  }
  exports.instantiate = instantiate;
  proto._cbcInit = function _cbcInit() {
    var state = new CBCState(this.options.iv);
    this._cbcState = state;
  };
  proto._update = function _update(inp, inOff, out, outOff) {
    var state = this._cbcState;
    var superProto = this.constructor.super_.prototype;
    var iv = state.iv;
    if (this.type === 'encrypt') {
      for (var i = 0; i < this.blockSize; i++)
        iv[i] ^= inp[inOff + i];
      superProto._update.call(this, iv, 0, out, outOff);
      for (var i = 0; i < this.blockSize; i++)
        iv[i] = out[outOff + i];
    } else {
      superProto._update.call(this, inp, inOff, out, outOff);
      for (var i = 0; i < this.blockSize; i++)
        out[outOff + i] ^= iv[i];
      for (var i = 0; i < this.blockSize; i++)
        iv[i] = inp[inOff + i];
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("189", ["af", "ad", "187"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var assert = $__require('af');
  var inherits = $__require('ad');
  var des = $__require('187');
  var Cipher = des.Cipher;
  var DES = des.DES;
  function EDEState(type, key) {
    assert.equal(key.length, 24, 'Invalid key length');
    var k1 = key.slice(0, 8);
    var k2 = key.slice(8, 16);
    var k3 = key.slice(16, 24);
    if (type === 'encrypt') {
      this.ciphers = [DES.create({
        type: 'encrypt',
        key: k1
      }), DES.create({
        type: 'decrypt',
        key: k2
      }), DES.create({
        type: 'encrypt',
        key: k3
      })];
    } else {
      this.ciphers = [DES.create({
        type: 'decrypt',
        key: k3
      }), DES.create({
        type: 'encrypt',
        key: k2
      }), DES.create({
        type: 'decrypt',
        key: k1
      })];
    }
  }
  function EDE(options) {
    Cipher.call(this, options);
    var state = new EDEState(this.type, this.options.key);
    this._edeState = state;
  }
  inherits(EDE, Cipher);
  module.exports = EDE;
  EDE.create = function create(options) {
    return new EDE(options);
  };
  EDE.prototype._update = function _update(inp, inOff, out, outOff) {
    var state = this._edeState;
    state.ciphers[0]._update(inp, inOff, out, outOff);
    state.ciphers[1]._update(out, outOff, out, outOff);
    state.ciphers[2]._update(out, outOff, out, outOff);
  };
  EDE.prototype._pad = DES.prototype._pad;
  EDE.prototype._unpad = DES.prototype._unpad;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("187", ["184", "185", "186", "188", "189"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.utils = $__require('184');
  exports.Cipher = $__require('185');
  exports.DES = $__require('186');
  exports.CBC = $__require('188');
  exports.EDE = $__require('189');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("18a", ["187"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('187');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("18b", ["18c", "18a", "ad", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var CipherBase = $__require('18c');
    var des = $__require('18a');
    var inherits = $__require('ad');
    var modes = {
      'des-ede3-cbc': des.CBC.instantiate(des.EDE),
      'des-ede3': des.EDE,
      'des-ede-cbc': des.CBC.instantiate(des.EDE),
      'des-ede': des.EDE,
      'des-cbc': des.CBC.instantiate(des.DES),
      'des-ecb': des.DES
    };
    modes.des = modes['des-cbc'];
    modes.des3 = modes['des-ede3-cbc'];
    module.exports = DES;
    inherits(DES, CipherBase);
    function DES(opts) {
      CipherBase.call(this);
      var modeName = opts.mode.toLowerCase();
      var mode = modes[modeName];
      var type;
      if (opts.decrypt) {
        type = 'decrypt';
      } else {
        type = 'encrypt';
      }
      var key = opts.key;
      if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
        key = Buffer.concat([key, key.slice(0, 8)]);
      }
      var iv = opts.iv;
      this._des = mode.create({
        key: key,
        iv: iv,
        type: type
      });
    }
    DES.prototype._update = function(data) {
      return new Buffer(this._des.update(data));
    };
    DES.prototype._final = function() {
      return new Buffer(this._des.final());
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("18d", ["18b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('18b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("18e", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports['des-ecb'] = {
    key: 8,
    iv: 0
  };
  exports['des-cbc'] = exports.des = {
    key: 8,
    iv: 8
  };
  exports['des-ede3-cbc'] = exports.des3 = {
    key: 24,
    iv: 8
  };
  exports['des-ede3'] = {
    key: 24,
    iv: 0
  };
  exports['des-ede-cbc'] = {
    key: 16,
    iv: 8
  };
  exports['des-ede'] = {
    key: 16,
    iv: 0
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("18f", ["190", "191", "18d", "18e", "192"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ebtk = $__require('190');
  var aes = $__require('191');
  var DES = $__require('18d');
  var desModes = $__require('18e');
  var aesModes = $__require('192');
  function createCipher(suite, password) {
    var keyLen,
        ivLen;
    suite = suite.toLowerCase();
    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError('invalid suite type');
    }
    var keys = ebtk(password, false, keyLen, ivLen);
    return createCipheriv(suite, keys.key, keys.iv);
  }
  function createDecipher(suite, password) {
    var keyLen,
        ivLen;
    suite = suite.toLowerCase();
    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError('invalid suite type');
    }
    var keys = ebtk(password, false, keyLen, ivLen);
    return createDecipheriv(suite, keys.key, keys.iv);
  }
  function createCipheriv(suite, key, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) {
      return aes.createCipheriv(suite, key, iv);
    } else if (desModes[suite]) {
      return new DES({
        key: key,
        iv: iv,
        mode: suite
      });
    } else {
      throw new TypeError('invalid suite type');
    }
  }
  function createDecipheriv(suite, key, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) {
      return aes.createDecipheriv(suite, key, iv);
    } else if (desModes[suite]) {
      return new DES({
        key: key,
        iv: iv,
        mode: suite,
        decrypt: true
      });
    } else {
      throw new TypeError('invalid suite type');
    }
  }
  exports.createCipher = exports.Cipher = createCipher;
  exports.createCipheriv = exports.Cipheriv = createCipheriv;
  exports.createDecipher = exports.Decipher = createDecipher;
  exports.createDecipheriv = exports.Decipheriv = createDecipheriv;
  function getCiphers() {
    return Object.keys(desModes).concat(aes.getCiphers());
  }
  exports.listCiphers = exports.getCiphers = getCiphers;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("193", ["18f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('18f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("194", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "modp1": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
      "gen": "02",
      "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("195", ["197", "196"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var bn = $__require('197');
  var brorand = $__require('196');
  function MillerRabin(rand) {
    this.rand = rand || new brorand.Rand();
  }
  module.exports = MillerRabin;
  MillerRabin.create = function create(rand) {
    return new MillerRabin(rand);
  };
  MillerRabin.prototype._rand = function _rand(n) {
    var len = n.bitLength();
    var buf = this.rand.generate(Math.ceil(len / 8));
    buf[0] |= 3;
    var mask = len & 0x7;
    if (mask !== 0)
      buf[buf.length - 1] >>= 7 - mask;
    return new bn(buf);
  };
  MillerRabin.prototype.test = function test(n, k, cb) {
    var len = n.bitLength();
    var red = bn.mont(n);
    var rone = new bn(1).toRed(red);
    if (!k)
      k = Math.max(1, (len / 48) | 0);
    var n1 = n.subn(1);
    var n2 = n1.subn(1);
    for (var s = 0; !n1.testn(s); s++) {}
    var d = n.shrn(s);
    var rn1 = n1.toRed(red);
    var prime = true;
    for (; k > 0; k--) {
      var a = this._rand(n2);
      if (cb)
        cb(a);
      var x = a.toRed(red).redPow(d);
      if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
        continue;
      for (var i = 1; i < s; i++) {
        x = x.redSqr();
        if (x.cmp(rone) === 0)
          return false;
        if (x.cmp(rn1) === 0)
          break;
      }
      if (i === s)
        return false;
    }
    return prime;
  };
  MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
    var len = n.bitLength();
    var red = bn.mont(n);
    var rone = new bn(1).toRed(red);
    if (!k)
      k = Math.max(1, (len / 48) | 0);
    var n1 = n.subn(1);
    var n2 = n1.subn(1);
    for (var s = 0; !n1.testn(s); s++) {}
    var d = n.shrn(s);
    var rn1 = n1.toRed(red);
    for (; k > 0; k--) {
      var a = this._rand(n2);
      var g = n.gcd(a);
      if (g.cmpn(1) !== 0)
        return g;
      var x = a.toRed(red).redPow(d);
      if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
        continue;
      for (var i = 1; i < s; i++) {
        x = x.redSqr();
        if (x.cmp(rone) === 0)
          return x.fromRed().subn(1).gcd(n);
        if (x.cmp(rn1) === 0)
          break;
      }
      if (i === s) {
        x = x.redSqr();
        return x.fromRed().subn(1).gcd(n);
      }
    }
    return false;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("198", ["195"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('195');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("199", ["19a", "197", "198"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var randomBytes = $__require('19a');
  module.exports = findPrime;
  findPrime.simpleSieve = simpleSieve;
  findPrime.fermatTest = fermatTest;
  var BN = $__require('197');
  var TWENTYFOUR = new BN(24);
  var MillerRabin = $__require('198');
  var millerRabin = new MillerRabin();
  var ONE = new BN(1);
  var TWO = new BN(2);
  var FIVE = new BN(5);
  var SIXTEEN = new BN(16);
  var EIGHT = new BN(8);
  var TEN = new BN(10);
  var THREE = new BN(3);
  var SEVEN = new BN(7);
  var ELEVEN = new BN(11);
  var FOUR = new BN(4);
  var TWELVE = new BN(12);
  var primes = null;
  function _getPrimes() {
    if (primes !== null)
      return primes;
    var limit = 0x100000;
    var res = [];
    res[0] = 2;
    for (var i = 1,
        k = 3; k < limit; k += 2) {
      var sqrt = Math.ceil(Math.sqrt(k));
      for (var j = 0; j < i && res[j] <= sqrt; j++)
        if (k % res[j] === 0)
          break;
      if (i !== j && res[j] <= sqrt)
        continue;
      res[i++] = k;
    }
    primes = res;
    return res;
  }
  function simpleSieve(p) {
    var primes = _getPrimes();
    for (var i = 0; i < primes.length; i++)
      if (p.modn(primes[i]) === 0) {
        if (p.cmpn(primes[i]) === 0) {
          return true;
        } else {
          return false;
        }
      }
    return true;
  }
  function fermatTest(p) {
    var red = BN.mont(p);
    return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
  }
  function findPrime(bits, gen) {
    if (bits < 16) {
      if (gen === 2 || gen === 5) {
        return new BN([0x8c, 0x7b]);
      } else {
        return new BN([0x8c, 0x27]);
      }
    }
    gen = new BN(gen);
    var num,
        n2;
    while (true) {
      num = new BN(randomBytes(Math.ceil(bits / 8)));
      while (num.bitLength() > bits) {
        num.ishrn(1);
      }
      if (num.isEven()) {
        num.iadd(ONE);
      }
      if (!num.testn(1)) {
        num.iadd(TWO);
      }
      if (!gen.cmp(TWO)) {
        while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
          num.iadd(FOUR);
        }
      } else if (!gen.cmp(FIVE)) {
        while (num.mod(TEN).cmp(THREE)) {
          num.iadd(FOUR);
        }
      }
      n2 = num.shrn(1);
      if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
        return num;
      }
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("19b", ["197", "198", "199", "19a", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var BN = $__require('197');
    var MillerRabin = $__require('198');
    var millerRabin = new MillerRabin();
    var TWENTYFOUR = new BN(24);
    var ELEVEN = new BN(11);
    var TEN = new BN(10);
    var THREE = new BN(3);
    var SEVEN = new BN(7);
    var primes = $__require('199');
    var randomBytes = $__require('19a');
    module.exports = DH;
    function setPublicKey(pub, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(pub)) {
        pub = new Buffer(pub, enc);
      }
      this._pub = new BN(pub);
      return this;
    }
    function setPrivateKey(priv, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(priv)) {
        priv = new Buffer(priv, enc);
      }
      this._priv = new BN(priv);
      return this;
    }
    var primeCache = {};
    function checkPrime(prime, generator) {
      var gen = generator.toString('hex');
      var hex = [gen, prime.toString(16)].join('_');
      if (hex in primeCache) {
        return primeCache[hex];
      }
      var error = 0;
      if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
        error += 1;
        if (gen === '02' || gen === '05') {
          error += 8;
        } else {
          error += 4;
        }
        primeCache[hex] = error;
        return error;
      }
      if (!millerRabin.test(prime.shrn(1))) {
        error += 2;
      }
      var rem;
      switch (gen) {
        case '02':
          if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
            error += 8;
          }
          break;
        case '05':
          rem = prime.mod(TEN);
          if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
            error += 8;
          }
          break;
        default:
          error += 4;
      }
      primeCache[hex] = error;
      return error;
    }
    function DH(prime, generator, malleable) {
      this.setGenerator(generator);
      this.__prime = new BN(prime);
      this._prime = BN.mont(this.__prime);
      this._primeLen = prime.length;
      this._pub = undefined;
      this._priv = undefined;
      this._primeCode = undefined;
      if (malleable) {
        this.setPublicKey = setPublicKey;
        this.setPrivateKey = setPrivateKey;
      } else {
        this._primeCode = 8;
      }
    }
    Object.defineProperty(DH.prototype, 'verifyError', {
      enumerable: true,
      get: function() {
        if (typeof this._primeCode !== 'number') {
          this._primeCode = checkPrime(this.__prime, this.__gen);
        }
        return this._primeCode;
      }
    });
    DH.prototype.generateKeys = function() {
      if (!this._priv) {
        this._priv = new BN(randomBytes(this._primeLen));
      }
      this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
      return this.getPublicKey();
    };
    DH.prototype.computeSecret = function(other) {
      other = new BN(other);
      other = other.toRed(this._prime);
      var secret = other.redPow(this._priv).fromRed();
      var out = new Buffer(secret.toArray());
      var prime = this.getPrime();
      if (out.length < prime.length) {
        var front = new Buffer(prime.length - out.length);
        front.fill(0);
        out = Buffer.concat([front, out]);
      }
      return out;
    };
    DH.prototype.getPublicKey = function getPublicKey(enc) {
      return formatReturnValue(this._pub, enc);
    };
    DH.prototype.getPrivateKey = function getPrivateKey(enc) {
      return formatReturnValue(this._priv, enc);
    };
    DH.prototype.getPrime = function(enc) {
      return formatReturnValue(this.__prime, enc);
    };
    DH.prototype.getGenerator = function(enc) {
      return formatReturnValue(this._gen, enc);
    };
    DH.prototype.setGenerator = function(gen, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(gen)) {
        gen = new Buffer(gen, enc);
      }
      this.__gen = gen;
      this._gen = new BN(gen);
      return this;
    };
    function formatReturnValue(bn, enc) {
      var buf = new Buffer(bn.toArray());
      if (!enc) {
        return buf;
      } else {
        return buf.toString(enc);
      }
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("19c", ["199", "194", "19b", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var generatePrime = $__require('199');
    var primes = $__require('194');
    var DH = $__require('19b');
    function getDiffieHellman(mod) {
      var prime = new Buffer(primes[mod].prime, 'hex');
      var gen = new Buffer(primes[mod].gen, 'hex');
      return new DH(prime, gen);
    }
    var ENCODINGS = {
      'binary': true,
      'hex': true,
      'base64': true
    };
    function createDiffieHellman(prime, enc, generator, genc) {
      if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
        return createDiffieHellman(prime, 'binary', enc, generator);
      }
      enc = enc || 'binary';
      genc = genc || 'binary';
      generator = generator || new Buffer([2]);
      if (!Buffer.isBuffer(generator)) {
        generator = new Buffer(generator, genc);
      }
      if (typeof prime === 'number') {
        return new DH(generatePrime(prime, generator), generator, true);
      }
      if (!Buffer.isBuffer(prime)) {
        prime = new Buffer(prime, enc);
      }
      return new DH(prime, generator, true);
    }
    exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
    exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("19d", ["19c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('19c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("19e", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    exports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha224',
      id: new Buffer('302d300d06096086480165030402040500041c', 'hex')
    };
    exports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha256',
      id: new Buffer('3031300d060960864801650304020105000420', 'hex')
    };
    exports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha384',
      id: new Buffer('3041300d060960864801650304020205000430', 'hex')
    };
    exports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha512',
      id: new Buffer('3051300d060960864801650304020305000440', 'hex')
    };
    exports['RSA-SHA1'] = {
      sign: 'rsa',
      hash: 'sha1',
      id: new Buffer('3021300906052b0e03021a05000414', 'hex')
    };
    exports['ecdsa-with-SHA1'] = {
      sign: 'ecdsa',
      hash: 'sha1',
      id: new Buffer('', 'hex')
    };
    exports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {
      sign: 'dsa',
      hash: 'sha1',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA224'] = exports['DSA-WITH-SHA224'] = {
      sign: 'dsa',
      hash: 'sha224',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA256'] = exports['DSA-WITH-SHA256'] = {
      sign: 'dsa',
      hash: 'sha256',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA384'] = exports['DSA-WITH-SHA384'] = {
      sign: 'dsa',
      hash: 'sha384',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA512'] = exports['DSA-WITH-SHA512'] = {
      sign: 'dsa',
      hash: 'sha512',
      id: new Buffer('', 'hex')
    };
    exports['DSA-RIPEMD160'] = {
      sign: 'dsa',
      hash: 'rmd160',
      id: new Buffer('', 'hex')
    };
    exports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {
      sign: 'rsa',
      hash: 'rmd160',
      id: new Buffer('3021300906052b2403020105000414', 'hex')
    };
    exports['RSA-MD5'] = exports.md5WithRSAEncryption = {
      sign: 'rsa',
      hash: 'md5',
      id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("19f", ["1a1", "1a2", "1a0", "1a3", "1a4", "197", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var createHmac = $__require('1a1');
    var crt = $__require('1a2');
    var curves = $__require('1a0');
    var elliptic = $__require('1a3');
    var parseKeys = $__require('1a4');
    var BN = $__require('197');
    var EC = elliptic.ec;
    function sign(hash, key, hashType, signType) {
      var priv = parseKeys(key);
      if (priv.curve) {
        if (signType !== 'ecdsa')
          throw new Error('wrong private key type');
        return ecSign(hash, priv);
      } else if (priv.type === 'dsa') {
        if (signType !== 'dsa') {
          throw new Error('wrong private key type');
        }
        return dsaSign(hash, priv, hashType);
      } else {
        if (signType !== 'rsa')
          throw new Error('wrong private key type');
      }
      var len = priv.modulus.byteLength();
      var pad = [0, 1];
      while (hash.length + pad.length + 1 < len) {
        pad.push(0xff);
      }
      pad.push(0x00);
      var i = -1;
      while (++i < hash.length) {
        pad.push(hash[i]);
      }
      var out = crt(pad, priv);
      return out;
    }
    function ecSign(hash, priv) {
      var curveId = curves[priv.curve.join('.')];
      if (!curveId)
        throw new Error('unknown curve ' + priv.curve.join('.'));
      var curve = new EC(curveId);
      var key = curve.genKeyPair();
      key._importPrivate(priv.privateKey);
      var out = key.sign(hash);
      return new Buffer(out.toDER());
    }
    function dsaSign(hash, priv, algo) {
      var x = priv.params.priv_key;
      var p = priv.params.p;
      var q = priv.params.q;
      var g = priv.params.g;
      var r = new BN(0);
      var k;
      var H = bits2int(hash, q).mod(q);
      var s = false;
      var kv = getKey(x, q, hash, algo);
      while (s === false) {
        k = makeKey(q, kv, algo);
        r = makeR(g, k, p, q);
        s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
        if (!s.cmpn(0)) {
          s = false;
          r = new BN(0);
        }
      }
      return toDER(r, s);
    }
    function toDER(r, s) {
      r = r.toArray();
      s = s.toArray();
      if (r[0] & 0x80) {
        r = [0].concat(r);
      }
      if (s[0] & 0x80) {
        s = [0].concat(s);
      }
      var total = r.length + s.length + 4;
      var res = [0x30, total, 0x02, r.length];
      res = res.concat(r, [0x02, s.length], s);
      return new Buffer(res);
    }
    function getKey(x, q, hash, algo) {
      x = new Buffer(x.toArray());
      if (x.length < q.byteLength()) {
        var zeros = new Buffer(q.byteLength() - x.length);
        zeros.fill(0);
        x = Buffer.concat([zeros, x]);
      }
      var hlen = hash.length;
      var hbits = bits2octets(hash, q);
      var v = new Buffer(hlen);
      v.fill(1);
      var k = new Buffer(hlen);
      k.fill(0);
      k = createHmac(algo, k).update(v).update(new Buffer([0])).update(x).update(hbits).digest();
      v = createHmac(algo, k).update(v).digest();
      k = createHmac(algo, k).update(v).update(new Buffer([1])).update(x).update(hbits).digest();
      v = createHmac(algo, k).update(v).digest();
      return {
        k: k,
        v: v
      };
    }
    function bits2int(obits, q) {
      var bits = new BN(obits);
      var shift = (obits.length << 3) - q.bitLength();
      if (shift > 0) {
        bits.ishrn(shift);
      }
      return bits;
    }
    function bits2octets(bits, q) {
      bits = bits2int(bits, q);
      bits = bits.mod(q);
      var out = new Buffer(bits.toArray());
      if (out.length < q.byteLength()) {
        var zeros = new Buffer(q.byteLength() - out.length);
        zeros.fill(0);
        out = Buffer.concat([zeros, out]);
      }
      return out;
    }
    function makeKey(q, kv, algo) {
      var t,
          k;
      do {
        t = new Buffer('');
        while (t.length * 8 < q.bitLength()) {
          kv.v = createHmac(algo, kv.k).update(kv.v).digest();
          t = Buffer.concat([t, kv.v]);
        }
        k = bits2int(t, q);
        kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([0])).digest();
        kv.v = createHmac(algo, kv.k).update(kv.v).digest();
      } while (k.cmp(q) !== -1);
      return k;
    }
    function makeR(g, k, p, q) {
      return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
    }
    module.exports = sign;
    module.exports.getKey = getKey;
    module.exports.makeKey = makeKey;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a0", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports['1.3.132.0.10'] = 'secp256k1';
  exports['1.3.132.0.33'] = 'p224';
  exports['1.2.840.10045.3.1.1'] = 'p192';
  exports['1.2.840.10045.3.1.7'] = 'p256';
  exports['1.3.132.0.34'] = 'p384';
  exports['1.3.132.0.35'] = 'p521';
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a5", ["1a0", "1a3", "1a4", "197", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var curves = $__require('1a0');
    var elliptic = $__require('1a3');
    var parseKeys = $__require('1a4');
    var BN = $__require('197');
    var EC = elliptic.ec;
    function verify(sig, hash, key, signType) {
      var pub = parseKeys(key);
      if (pub.type === 'ec') {
        if (signType !== 'ecdsa') {
          throw new Error('wrong public key type');
        }
        return ecVerify(sig, hash, pub);
      } else if (pub.type === 'dsa') {
        if (signType !== 'dsa') {
          throw new Error('wrong public key type');
        }
        return dsaVerify(sig, hash, pub);
      } else {
        if (signType !== 'rsa') {
          throw new Error('wrong public key type');
        }
      }
      var len = pub.modulus.byteLength();
      var pad = [1];
      var padNum = 0;
      while (hash.length + pad.length + 2 < len) {
        pad.push(0xff);
        padNum++;
      }
      pad.push(0x00);
      var i = -1;
      while (++i < hash.length) {
        pad.push(hash[i]);
      }
      pad = new Buffer(pad);
      var red = BN.mont(pub.modulus);
      sig = new BN(sig).toRed(red);
      sig = sig.redPow(new BN(pub.publicExponent));
      sig = new Buffer(sig.fromRed().toArray());
      var out = 0;
      if (padNum < 8) {
        out = 1;
      }
      len = Math.min(sig.length, pad.length);
      if (sig.length !== pad.length) {
        out = 1;
      }
      i = -1;
      while (++i < len) {
        out |= (sig[i] ^ pad[i]);
      }
      return out === 0;
    }
    function ecVerify(sig, hash, pub) {
      var curveId = curves[pub.data.algorithm.curve.join('.')];
      if (!curveId)
        throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'));
      var curve = new EC(curveId);
      var pubkey = pub.data.subjectPrivateKey.data;
      return curve.verify(hash, sig, pubkey);
    }
    function dsaVerify(sig, hash, pub) {
      var p = pub.data.p;
      var q = pub.data.q;
      var g = pub.data.g;
      var y = pub.data.pub_key;
      var unpacked = parseKeys.signature.decode(sig, 'der');
      var s = unpacked.s;
      var r = unpacked.r;
      checkValue(s, q);
      checkValue(r, q);
      var montp = BN.mont(p);
      var w = s.invm(q);
      var v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
      return !v.cmp(r);
    }
    function checkValue(b, q) {
      if (b.cmpn(0) <= 0) {
        throw new Error('invalid sig');
      }
      if (b.cmp(q) >= q) {
        throw new Error('invalid sig');
      }
    }
    module.exports = verify;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a6", ["19e", "1a7", "ad", "19f", "58", "1a5", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var _algos = $__require('19e');
    var createHash = $__require('1a7');
    var inherits = $__require('ad');
    var sign = $__require('19f');
    var stream = $__require('58');
    var verify = $__require('1a5');
    var algos = {};
    Object.keys(_algos).forEach(function(key) {
      algos[key] = algos[key.toLowerCase()] = _algos[key];
    });
    function Sign(algorithm) {
      stream.Writable.call(this);
      var data = algos[algorithm];
      if (!data) {
        throw new Error('Unknown message digest');
      }
      this._hashType = data.hash;
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    inherits(Sign, stream.Writable);
    Sign.prototype._write = function _write(data, _, done) {
      this._hash.update(data);
      done();
    };
    Sign.prototype.update = function update(data, enc) {
      if (typeof data === 'string') {
        data = new Buffer(data, enc);
      }
      this._hash.update(data);
      return this;
    };
    Sign.prototype.sign = function signMethod(key, enc) {
      this.end();
      var hash = this._hash.digest();
      var sig = sign(Buffer.concat([this._tag, hash]), key, this._hashType, this._signType);
      return enc ? sig.toString(enc) : sig;
    };
    function Verify(algorithm) {
      stream.Writable.call(this);
      var data = algos[algorithm];
      if (!data) {
        throw new Error('Unknown message digest');
      }
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    inherits(Verify, stream.Writable);
    Verify.prototype._write = function _write(data, _, done) {
      this._hash.update(data);
      done();
    };
    Verify.prototype.update = function update(data, enc) {
      if (typeof data === 'string') {
        data = new Buffer(data, enc);
      }
      this._hash.update(data);
      return this;
    };
    Verify.prototype.verify = function verifyMethod(key, sig, enc) {
      if (typeof sig === 'string') {
        sig = new Buffer(sig, enc);
      }
      this.end();
      var hash = this._hash.digest();
      return verify(sig, Buffer.concat([this._tag, hash]), key, this._signType);
    };
    function createSign(algorithm) {
      return new Sign(algorithm);
    }
    function createVerify(algorithm) {
      return new Verify(algorithm);
    }
    module.exports = {
      Sign: createSign,
      Verify: createVerify,
      createSign: createSign,
      createVerify: createVerify
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a8", ["1a6"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1a6');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a9", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "name": "elliptic",
    "version": "6.3.2",
    "description": "EC cryptography",
    "main": "lib/elliptic.js",
    "files": ["lib"],
    "scripts": {
      "jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
      "jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
      "lint": "npm run jscs && npm run jshint",
      "unit": "istanbul test _mocha --reporter=spec test/index.js",
      "test": "npm run lint && npm run unit",
      "version": "grunt dist && git add dist/"
    },
    "repository": {
      "type": "git",
      "url": "git@github.com:indutny/elliptic"
    },
    "keywords": ["EC", "Elliptic", "curve", "Cryptography"],
    "author": "Fedor Indutny <fedor@indutny.com>",
    "license": "MIT",
    "bugs": {"url": "https://github.com/indutny/elliptic/issues"},
    "homepage": "https://github.com/indutny/elliptic",
    "devDependencies": {
      "brfs": "^1.4.3",
      "coveralls": "^2.11.3",
      "grunt": "^0.4.5",
      "grunt-browserify": "^5.0.0",
      "grunt-contrib-connect": "^1.0.0",
      "grunt-contrib-copy": "^1.0.0",
      "grunt-contrib-uglify": "^1.0.1",
      "grunt-mocha-istanbul": "^3.0.1",
      "grunt-saucelabs": "^8.6.2",
      "istanbul": "^0.4.2",
      "jscs": "^2.9.0",
      "jshint": "^2.6.0",
      "mocha": "^2.1.0"
    },
    "dependencies": {
      "bn.js": "^4.4.0",
      "brorand": "^1.0.1",
      "hash.js": "^1.0.0",
      "inherits": "^2.0.1"
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1aa", ["197"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var utils = exports;
  var BN = $__require('197');
  utils.assert = function assert(val, msg) {
    if (!val)
      throw new Error(msg || 'Assertion failed');
  };
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== 'string') {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
    return res;
  }
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return '0' + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;
  utils.encode = function encode(arr, enc) {
    if (enc === 'hex')
      return toHex(arr);
    else
      return arr;
  };
  function getNAF(num, w) {
    var naf = [];
    var ws = 1 << (w + 1);
    var k = num.clone();
    while (k.cmpn(1) >= 0) {
      var z;
      if (k.isOdd()) {
        var mod = k.andln(ws - 1);
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf.push(z);
      var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
      for (var i = 1; i < shift; i++)
        naf.push(0);
      k.iushrn(shift);
    }
    return naf;
  }
  utils.getNAF = getNAF;
  function getJSF(k1, k2) {
    var jsf = [[], []];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = (k1.andln(3) + d1) & 3;
      var m24 = (k2.andln(3) + d2) & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        var m8 = (k1.andln(7) + d1) & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        var m8 = (k2.andln(7) + d2) & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF;
  function cachedProperty(obj, name, computer) {
    var key = '_' + name;
    obj.prototype[name] = function cachedProperty() {
      return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new BN(bytes, 'hex', 'le');
  }
  utils.intFromLE = intFromLE;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ab", ["@empty"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var r;
  module.exports = function rand(len) {
    if (!r)
      r = new Rand(null);
    return r.generate(len);
  };
  function Rand(rand) {
    this.rand = rand;
  }
  module.exports.Rand = Rand;
  Rand.prototype.generate = function generate(len) {
    return this._rand(len);
  };
  if (typeof window === 'object') {
    if (window.crypto && window.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        window.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (window.msCrypto && window.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        window.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else {
      Rand.prototype._rand = function() {
        throw new Error('Not implemented yet');
      };
    }
  } else {
    try {
      var crypto = $__require('@empty');
      Rand.prototype._rand = function _rand(n) {
        return crypto.randomBytes(n);
      };
    } catch (e) {
      Rand.prototype._rand = function _rand(n) {
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++)
          res[i] = this.rand.getByte();
        return res;
      };
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("196", ["1ab"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1ab');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ac", ["1ae", "1ad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hash = $__require('1ae');
  var elliptic = $__require('1ad');
  var utils = elliptic.utils;
  var assert = utils.assert;
  function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG))
      return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this.reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils.toArray(options.entropy, options.entropyEnc);
    var nonce = utils.toArray(options.nonce, options.nonceEnc);
    var pers = utils.toArray(options.pers, options.persEnc);
    assert(entropy.length >= (this.minEntropy / 8), 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._init(entropy, nonce, pers);
  }
  module.exports = HmacDRBG;
  HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i = 0; i < this.V.length; i++) {
      this.K[i] = 0x00;
      this.V[i] = 0x01;
    }
    this._update(seed);
    this.reseed = 1;
    this.reseedInterval = 0x1000000000000;
  };
  HmacDRBG.prototype._hmac = function hmac() {
    return new hash.hmac(this.hash, this.K);
  };
  HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([0x00]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;
    this.K = this._hmac().update(this.V).update([0x01]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    if (typeof entropyEnc !== 'string') {
      addEnc = add;
      add = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils.toBuffer(entropy, entropyEnc);
    add = utils.toBuffer(add, addEnc);
    assert(entropy.length >= (this.minEntropy / 8), 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._update(entropy.concat(add || []));
    this.reseed = 1;
  };
  HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this.reseed > this.reseedInterval)
      throw new Error('Reseed is required');
    if (typeof enc !== 'string') {
      addEnc = add;
      add = enc;
      enc = null;
    }
    if (add) {
      add = utils.toArray(add, addEnc);
      this._update(add);
    }
    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this.reseed++;
    return utils.encode(res, enc);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1af", ["197", "1ad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var BN = $__require('197');
  var elliptic = $__require('1ad');
  var utils = elliptic.utils;
  var getNAF = utils.getNAF;
  var getJSF = utils.getJSF;
  var assert = utils.assert;
  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN(conf.p, 16);
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  module.exports = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error('Not implemented');
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error('Not implemented');
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1);
    var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    var repr = [];
    for (var j = 0; j < naf.length; j += doubles.step) {
      var nafW = 0;
      for (var k = j + doubles.step - 1; k >= j; k--)
        nafW = (nafW << 1) + naf[k];
      repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for (var i = I; i > 0; i--) {
      for (var j = 0; j < repr.length; j++) {
        var nafW = repr[j];
        if (nafW === i)
          b = b.mixedAdd(doubles.points[j]);
        else if (nafW === -i)
          b = b.mixedAdd(doubles.points[j].neg());
      }
      a = a.add(b);
    }
    return a.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k, w);
    var acc = this.jpoint(null, null, null);
    for (var i = naf.length - 1; i >= 0; i--) {
      for (var k = 0; i >= 0 && naf[i] === 0; i--)
        k++;
      if (i >= 0)
        k++;
      acc = acc.dblp(k);
      if (i < 0)
        break;
      var z = naf[i];
      assert(z !== 0);
      if (p.type === 'affine') {
        if (z > 0)
          acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
        else
          acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
      } else {
        if (z > 0)
          acc = acc.add(wnd[(z - 1) >> 1]);
        else
          acc = acc.add(wnd[(-z - 1) >> 1].neg());
      }
    }
    return p.type === 'affine' ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max = 0;
    for (var i = 0; i < len; i++) {
      var p = points[i];
      var nafPoints = p._getNAFPoints(defW);
      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    }
    for (var i = len - 1; i >= 1; i -= 2) {
      var a = i - 1;
      var b = i;
      if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a]);
        naf[b] = getNAF(coeffs[b], wndWidth[b]);
        max = Math.max(naf[a].length, max);
        max = Math.max(naf[b].length, max);
        continue;
      }
      var comb = [points[a], null, null, points[b]];
      if (points[a].y.cmp(points[b].y) === 0) {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].add(points[b].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      }
      var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3];
      var jsf = getJSF(coeffs[a], coeffs[b]);
      max = Math.max(jsf[0].length, max);
      naf[a] = new Array(max);
      naf[b] = new Array(max);
      for (var j = 0; j < max; j++) {
        var ja = jsf[0][j] | 0;
        var jb = jsf[1][j] | 0;
        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (var i = max; i >= 0; i--) {
      var k = 0;
      while (i >= 0) {
        var zero = true;
        for (var j = 0; j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k++;
        i--;
      }
      if (i >= 0)
        k++;
      acc = acc.dblp(k);
      if (i < 0)
        break;
      for (var j = 0; j < len; j++) {
        var z = tmp[j];
        var p;
        if (z === 0)
          continue;
        else if (z > 0)
          p = wnd[j][(z - 1) >> 1];
        else if (z < 0)
          p = wnd[j][(-z - 1) >> 1].neg();
        if (p.type === 'affine')
          acc = acc.mixedAdd(p);
        else
          acc = acc.add(p);
      }
    }
    for (var i = 0; i < len; i++)
      wnd[i] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error('Not implemented');
  };
  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils.toArray(bytes, enc);
    var len = this.p.byteLength();
    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
      if (bytes[0] === 0x06)
        assert(bytes[bytes.length - 1] % 2 === 0);
      else if (bytes[0] === 0x07)
        assert(bytes[bytes.length - 1] % 2 === 1);
      var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
      return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) {
      return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    }
    throw new Error('Unknown point format');
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray('be', len);
    if (compact)
      return [this.getY().isEven() ? 0x02 : 0x03].concat(x);
    return [0x04].concat(x, this.getY().toArray('be', len));
  };
  BasePoint.prototype.encode = function encode(enc, compact) {
    return utils.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i = 0; i < power; i += step) {
      for (var j = 0; j < step; j++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step: step,
      points: doubles
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for (var i = 1; i < max; i++)
      res[i] = res[i - 1].add(dbl);
    return {
      wnd: wnd,
      points: res
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for (var i = 0; i < k; i++)
      r = r.dbl();
    return r;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b0", ["1b1", "1ad", "197", "ad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var curve = $__require('1b1');
  var elliptic = $__require('1ad');
  var BN = $__require('197');
  var inherits = $__require('ad');
  var Base = curve.base;
  var assert = elliptic.utils.assert;
  function ShortCurve(conf) {
    Base.call(this, 'short', conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits(ShortCurve, Base);
  module.exports = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BN(vec.a, 16),
          b: new BN(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta: beta,
      lambda: lambda,
      basis: basis
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red = num === this.p ? this.red : BN.mont(num);
    var tinv = new BN(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [l1, l2];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN(1);
    var y1 = new BN(0);
    var x2 = new BN(0);
    var y2 = new BN(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while (u.cmpn(0) !== 0) {
      var q = v.div(u);
      r = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      var y = y2.sub(q.mul(y1));
      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i === 2) {
        break;
      }
      prevR = r;
      v = u;
      u = r;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b2 = b2.neg();
    }
    return [{
      a: a1,
      b: b1
    }, {
      a: a2,
      b: b2
    }];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return {
      k1: k1,
      k2: k2
    };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error('invalid point');
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf)
      return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i = 0; i < points.length; i++) {
      var split = this._endoSplit(coeffs[i]);
      var p = points[i];
      var beta = p._getBeta();
      if (split.k1.negative) {
        split.k1.ineg();
        p = p.neg(true);
      }
      if (split.k2.negative) {
        split.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i * 2] = p;
      npoints[i * 2 + 1] = beta;
      ncoeffs[i * 2] = split.k1;
      ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    for (var j = 0; j < i * 2; j++) {
      npoints[j] = null;
      ncoeffs[j] = null;
    }
    return res;
  };
  function Point(curve, x, y, isRed) {
    Base.BasePoint.call(this, curve, 'affine');
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits(Point, Base.BasePoint);
  ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
  };
  Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve = this.curve;
      var endoMul = function(p) {
        return curve.point(p.x.redMul(curve.endo.beta), p.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === 'string')
      obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;
    function obj2point(obj) {
      return curve.point(obj[0], obj[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point.prototype.add = function add(p) {
    if (this.inf)
      return p;
    if (p.inf)
      return this;
    if (this.eq(p))
      return this.dbl();
    if (this.neg().eq(p))
      return this.curve.point(null, null);
    if (this.x.cmp(p.x) === 0)
      return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0)
      c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point.prototype.mul = function mul(k) {
    k = new BN(k, 16);
    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k]);
    else
      return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  };
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p) {
        return p.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint(curve, x, y, z) {
    Base.BasePoint.call(this, curve, 'jacobian');
    if (x === null && y === null && z === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN(0);
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = new BN(z, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits(JPoint, Base.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p) {
    if (this.isInfinity())
      return p.toJ();
    if (p.isInfinity())
      return this;
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      for (var i = 0; i < pow; i++)
        r = r.dbl();
      return r;
    }
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (var i = 0; i < pow; i++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i + 1 < pow)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx);
      var t = m.redSqr().redISub(s).redISub(s);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t;
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = b.redSqr();
      var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      var e = a.redAdd(a).redIAdd(a);
      var f = e.redSqr();
      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f.redISub(d).redISub(d);
      ny = e.redMul(d.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t = m.redSqr().redISub(s).redISub(s);
      nx = t;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m = xx.redAdd(xx).redIAdd(xx);
    var mm = m.redSqr();
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    var ee = e.redSqr();
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN(k, kbase);
    return this.curve._wnafMul(this, k);
  };
  JPoint.prototype.eq = function eq(p) {
    if (p.type === 'affine')
      return this.eq(p.toJ());
    if (this === p)
      return true;
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
      return false;
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
    return false;
  };
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC JPoint Infinity>';
    return '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
  };
  JPoint.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b2", ["1b1", "197", "ad", "1ad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var curve = $__require('1b1');
  var BN = $__require('197');
  var inherits = $__require('ad');
  var Base = curve.base;
  var elliptic = $__require('1ad');
  var utils = elliptic.utils;
  function MontCurve(conf) {
    Base.call(this, 'mont', conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.i4 = new BN(4).toRed(this.red).redInvm();
    this.two = new BN(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits(MontCurve, Base);
  module.exports = MontCurve;
  MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
  };
  function Point(curve, x, z) {
    Base.BasePoint.call(this, curve, 'projective');
    if (x === null && z === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN(x, 16);
      this.z = new BN(z, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits(Point, Base.BasePoint);
  MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils.toArray(bytes, enc), 1);
  };
  MontCurve.prototype.point = function point(x, z) {
    return new Point(this, x, z);
  };
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  Point.prototype.precompute = function precompute() {};
  Point.prototype._encode = function _encode() {
    return this.getX().toArray('be', this.curve.p.byteLength());
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1] || curve.one);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  Point.prototype.dbl = function dbl() {
    var a = this.x.redAdd(this.z);
    var aa = a.redSqr();
    var b = this.x.redSub(this.z);
    var bb = b.redSqr();
    var c = aa.redSub(bb);
    var nx = aa.redMul(bb);
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };
  Point.prototype.add = function add() {
    throw new Error('Not supported on Montgomery curve');
  };
  Point.prototype.diffAdd = function diffAdd(p, diff) {
    var a = this.x.redAdd(this.z);
    var b = this.x.redSub(this.z);
    var c = p.x.redAdd(p.z);
    var d = p.x.redSub(p.z);
    var da = d.redMul(a);
    var cb = c.redMul(b);
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this;
    var b = this.curve.point(null, null);
    var c = this;
    for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
      bits.push(t.andln(1));
    for (var i = bits.length - 1; i >= 0; i--) {
      if (bits[i] === 0) {
        a = a.diffAdd(b, c);
        b = b.dbl();
      } else {
        b = a.diffAdd(b, c);
        a = a.dbl();
      }
    }
    return b;
  };
  Point.prototype.mulAdd = function mulAdd() {
    throw new Error('Not supported on Montgomery curve');
  };
  Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error('Not supported on Montgomery curve');
  };
  Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b3", ["1b1", "1ad", "197", "ad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var curve = $__require('1b1');
  var elliptic = $__require('1ad');
  var BN = $__require('197');
  var inherits = $__require('ad');
  var Base = curve.base;
  var assert = elliptic.utils.assert;
  function EdwardsCurve(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, 'edwards', conf);
    this.a = new BN(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits(EdwardsCurve, Base);
  module.exports = EdwardsCurve;
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
  };
  EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error('invalid point');
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN(y, 16);
    if (!y.red)
      y = y.toRed(this.red);
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.one);
    var rhs = y2.redMul(this.d).redAdd(this.one);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
      if (odd)
        throw new Error('invalid point');
      else
        return this.point(this.zero, y);
    }
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
      throw new Error('invalid point');
    if (x.isOdd() !== odd)
      x = x.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity())
      return true;
    point.normalize();
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
  };
  function Point(curve, x, y, z, t) {
    Base.BasePoint.call(this, curve, 'projective');
    if (x === null && y === null && z === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = z ? new BN(z, 16) : this.curve.one;
      this.t = t && new BN(t, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits(Point, Base.BasePoint);
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new Point(this, x, y, z, t);
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.x.cmpn(0) === 0 && this.y.cmp(this.z) === 0;
  };
  Point.prototype._extDbl = function _extDbl() {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    var d = this.curve._mulA(a);
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    var g = d.redAdd(b);
    var f = g.redSub(c);
    var h = d.redSub(b);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projDbl = function _projDbl() {
    var b = this.x.redAdd(this.y).redSqr();
    var c = this.x.redSqr();
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    if (this.curve.twisted) {
      var e = this.curve._mulA(c);
      var f = e.redAdd(d);
      if (this.zOne) {
        nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
        ny = f.redMul(e.redSub(d));
        nz = f.redSqr().redSub(f).redSub(f);
      } else {
        var h = this.z.redSqr();
        var j = f.redSub(h).redISub(h);
        nx = b.redSub(c).redISub(d).redMul(j);
        ny = f.redMul(e.redSub(d));
        nz = f.redMul(j);
      }
    } else {
      var e = c.redAdd(d);
      var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
      var j = e.redSub(h).redSub(h);
      nx = this.curve._mulC(b.redISub(e)).redMul(j);
      ny = this.curve._mulC(e).redMul(c.redISub(d));
      nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  Point.prototype._extAdd = function _extAdd(p) {
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    var d = this.z.redMul(p.z.redAdd(p.z));
    var e = b.redSub(a);
    var f = d.redSub(c);
    var g = d.redAdd(c);
    var h = b.redAdd(a);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projAdd = function _projAdd(p) {
    var a = this.z.redMul(p.z);
    var b = a.redSqr();
    var c = this.x.redMul(p.x);
    var d = this.y.redMul(p.y);
    var e = this.curve.d.redMul(c).redMul(d);
    var f = b.redSub(e);
    var g = b.redAdd(e);
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
      nz = f.redMul(g);
    } else {
      ny = a.redMul(g).redMul(d.redSub(c));
      nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extAdd(p);
    else
      return this._projAdd(p);
  };
  Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else
      return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
  };
  Point.prototype.normalize = function normalize() {
    if (this.zOne)
      return this;
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t)
      this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
  };
  Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
    return false;
  };
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b1", ["1af", "1b0", "1b2", "1b3"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var curve = exports;
  curve.base = $__require('1af');
  curve.short = $__require('1b0');
  curve.mont = $__require('1b2');
  curve.edwards = $__require('1b3');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b4", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    doubles: {
      step: 4,
      points: [['e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a', 'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'], ['8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508', '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'], ['175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739', 'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'], ['363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640', '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'], ['8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c', '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'], ['723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda', '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'], ['eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa', '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'], ['100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0', 'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'], ['e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d', '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'], ['feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d', 'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'], ['da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1', '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'], ['53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0', '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'], ['8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047', '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'], ['385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862', '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'], ['6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7', '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'], ['3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd', '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'], ['85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83', '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'], ['948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a', '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'], ['6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8', 'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'], ['e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d', '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'], ['e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725', '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'], ['213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754', '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'], ['4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c', '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'], ['fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6', '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'], ['76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39', 'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'], ['c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891', '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'], ['d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b', 'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'], ['b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03', '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'], ['e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d', 'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'], ['a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070', '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'], ['90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4', 'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'], ['8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da', '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'], ['e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11', '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'], ['8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e', 'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'], ['e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41', '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'], ['b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef', '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'], ['d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8', 'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'], ['324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d', '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'], ['4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96', '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'], ['9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd', 'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'], ['6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5', '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'], ['a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266', '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'], ['7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71', '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'], ['928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac', 'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'], ['85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751', '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'], ['ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e', '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'], ['827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241', 'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'], ['eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3', 'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'], ['e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f', '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'], ['1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19', 'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'], ['146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be', 'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'], ['fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9', '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'], ['da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2', '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'], ['a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13', '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'], ['174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c', 'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'], ['959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba', '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'], ['d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151', 'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'], ['64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073', 'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'], ['8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458', '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'], ['13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b', '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'], ['bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366', 'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'], ['8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa', '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'], ['8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0', '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'], ['dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787', '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'], ['f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e', 'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82']]
    },
    naf: {
      wnd: 7,
      points: [['f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9', '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'], ['2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4', 'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'], ['5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc', '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'], ['acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe', 'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'], ['774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb', 'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'], ['f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8', 'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'], ['d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e', '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'], ['defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34', '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'], ['2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c', '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'], ['352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5', '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'], ['2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f', '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'], ['9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714', '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'], ['daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729', 'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'], ['c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db', '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'], ['6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4', 'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'], ['1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5', 'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'], ['605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479', '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'], ['62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d', '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'], ['80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f', '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'], ['7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb', 'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'], ['d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9', 'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'], ['49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963', '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'], ['77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74', '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'], ['f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530', 'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'], ['463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b', '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'], ['f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247', 'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'], ['caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1', 'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'], ['2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120', '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'], ['7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435', '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'], ['754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18', '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'], ['e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8', '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'], ['186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb', '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'], ['df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f', '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'], ['5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143', 'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'], ['290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba', 'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'], ['af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45', 'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'], ['766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a', '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'], ['59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e', 'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'], ['f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8', 'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'], ['7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c', '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'], ['948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519', 'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'], ['7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab', '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'], ['3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca', 'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'], ['d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf', '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'], ['1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610', '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'], ['733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4', 'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'], ['15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c', 'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'], ['a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940', 'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'], ['e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980', 'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'], ['311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3', '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'], ['34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf', '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'], ['f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63', '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'], ['d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448', 'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'], ['32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf', '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'], ['7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5', '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'], ['ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6', '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'], ['16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5', '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'], ['eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99', 'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'], ['78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51', 'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'], ['494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5', '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'], ['a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5', '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'], ['c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997', '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'], ['841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881', '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'], ['5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5', '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'], ['36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66', 'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'], ['336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726', 'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'], ['8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede', '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'], ['1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94', '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'], ['85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31', '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'], ['29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51', 'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'], ['a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252', 'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'], ['4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5', 'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'], ['d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b', '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'], ['ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4', '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'], ['af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f', '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'], ['e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889', '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'], ['591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246', 'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'], ['11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984', '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'], ['3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a', 'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'], ['cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030', 'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'], ['c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197', '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'], ['c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593', 'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'], ['a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef', '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'], ['347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38', '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'], ['da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a', '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'], ['c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111', '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'], ['4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502', '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'], ['3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea', 'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'], ['cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26', '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'], ['b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986', '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'], ['d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e', '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'], ['48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4', '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'], ['dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda', 'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'], ['6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859', 'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'], ['e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f', 'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'], ['eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c', '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'], ['13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942', 'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'], ['ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a', '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'], ['b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80', '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'], ['ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d', '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'], ['8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1', 'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'], ['52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63', 'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'], ['e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352', '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'], ['7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193', 'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'], ['5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00', '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'], ['32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58', 'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'], ['e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7', 'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'], ['8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8', 'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'], ['4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e', '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'], ['3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d', 'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'], ['674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b', '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'], ['d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f', 'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'], ['30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6', '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'], ['be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297', '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'], ['93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a', '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'], ['b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c', 'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'], ['d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52', '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'], ['d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb', 'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'], ['463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065', 'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'], ['7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917', '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'], ['74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9', 'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'], ['30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3', '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'], ['9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57', '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'], ['176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66', 'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'], ['75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8', '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'], ['809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721', '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'], ['1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180', '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9']]
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b5", ["1ae", "1ad", "1b4"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var curves = exports;
  var hash = $__require('1ae');
  var elliptic = $__require('1ad');
  var assert = elliptic.utils.assert;
  function PresetCurve(options) {
    if (options.type === 'short')
      this.curve = new elliptic.curve.short(options);
    else if (options.type === 'edwards')
      this.curve = new elliptic.curve.edwards(options);
    else
      this.curve = new elliptic.curve.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), 'Invalid curve');
    assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve('p192', {
    type: 'short',
    prime: 'p192',
    p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
    b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
    n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
    hash: hash.sha256,
    gRed: false,
    g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811']
  });
  defineCurve('p224', {
    type: 'short',
    prime: 'p224',
    p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
    b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
    n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
    hash: hash.sha256,
    gRed: false,
    g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34']
  });
  defineCurve('p256', {
    type: 'short',
    prime: null,
    p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
    a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
    b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
    n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
    hash: hash.sha256,
    gRed: false,
    g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5']
  });
  defineCurve('p384', {
    type: 'short',
    prime: null,
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 ffffffff',
    a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 fffffffc',
    b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' + '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
    n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' + 'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
    hash: hash.sha384,
    gRed: false,
    g: ['aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' + '5502f25d bf55296c 3a545e38 72760ab7', '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' + '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f']
  });
  defineCurve('p521', {
    type: 'short',
    prime: null,
    p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff',
    a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff fffffffc',
    b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' + '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' + '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
    n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' + 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
    hash: hash.sha512,
    gRed: false,
    g: ['000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' + '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' + 'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66', '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' + '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' + '3fad0761 353c7086 a272c240 88be9476 9fd16650']
  });
  defineCurve('curve25519', {
    type: 'mont',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '76d06',
    b: '0',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: ['9']
  });
  defineCurve('ed25519', {
    type: 'edwards',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '-1',
    c: '1',
    d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: ['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a', '6666666666666666666666666666666666666666666666666666666666666658']
  });
  var pre;
  try {
    pre = $__require('1b4');
  } catch (e) {
    pre = undefined;
  }
  defineCurve('secp256k1', {
    type: 'short',
    prime: 'k256',
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
    a: '0',
    b: '7',
    n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
    h: '1',
    hash: hash.sha256,
    beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
    lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
    basis: [{
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    }, {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }],
    gRed: false,
    g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', pre]
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b6", ["197"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var BN = $__require('197');
  function KeyPair(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  }
  module.exports = KeyPair;
  KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(ec, {
      pub: pub,
      pubEnc: enc
    });
  };
  KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair)
      return priv;
    return new KeyPair(ec, {
      priv: priv,
      privEnc: enc
    });
  };
  KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return {
        result: false,
        reason: 'Invalid public key'
      };
    if (!pub.validate())
      return {
        result: false,
        reason: 'Public key is not a point'
      };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return {
        result: false,
        reason: 'Public key * N != O'
      };
    return {
      result: true,
      reason: null
    };
  };
  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    if (typeof compact === 'string') {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === 'hex')
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN(key, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
      this.pub = this.ec.curve.point(key.x, key.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
  };
  KeyPair.prototype.derive = function derive(pub) {
    return pub.mul(this.priv).getX();
  };
  KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  KeyPair.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
  };
  KeyPair.prototype.inspect = function inspect() {
    return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b7", ["197", "1ad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var BN = $__require('197');
  var elliptic = $__require('1ad');
  var utils = elliptic.utils;
  var assert = utils.assert;
  function Signature(options, enc) {
    if (options instanceof Signature)
      return options;
    if (this._importDER(options, enc))
      return;
    assert(options.r && options.s, 'Signature without r or s');
    this.r = new BN(options.r, 16);
    this.s = new BN(options.s, 16);
    if (options.recoveryParam === undefined)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  }
  module.exports = Signature;
  function Position() {
    this.place = 0;
  }
  function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 0x80)) {
      return initial;
    }
    var octetLen = initial & 0xf;
    var val = 0;
    for (var i = 0,
        off = p.place; i < octetLen; i++, off++) {
      val <<= 8;
      val |= buf[off];
    }
    p.place = off;
    return val;
  }
  function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
      i++;
    }
    if (i === 0) {
      return buf;
    }
    return buf.slice(i);
  }
  Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 0x30) {
      return false;
    }
    var len = getLength(data, p);
    if ((len + p.place) !== data.length) {
      return false;
    }
    if (data[p.place++] !== 0x02) {
      return false;
    }
    var rlen = getLength(data, p);
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 0x02) {
      return false;
    }
    var slen = getLength(data, p);
    if (data.length !== slen + p.place) {
      return false;
    }
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0 && (r[1] & 0x80)) {
      r = r.slice(1);
    }
    if (s[0] === 0 && (s[1] & 0x80)) {
      s = s.slice(1);
    }
    this.r = new BN(r);
    this.s = new BN(s);
    this.recoveryParam = null;
    return true;
  };
  function constructLength(arr, len) {
    if (len < 0x80) {
      arr.push(len);
      return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);
    while (--octets) {
      arr.push((len >>> (octets << 3)) & 0xff);
    }
    arr.push(len);
  }
  Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    if (r[0] & 0x80)
      r = [0].concat(r);
    if (s[0] & 0x80)
      s = [0].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while (!s[0] && !(s[1] & 0x80)) {
      s = s.slice(1);
    }
    var arr = [0x02];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [0x30];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils.encode(res, enc);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b8", ["197", "1ad", "1b6", "1b7"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var BN = $__require('197');
  var elliptic = $__require('1ad');
  var utils = elliptic.utils;
  var assert = utils.assert;
  var KeyPair = $__require('1b6');
  var Signature = $__require('1b7');
  function EC(options) {
    if (!(this instanceof EC))
      return new EC(options);
    if (typeof options === 'string') {
      assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);
      options = elliptic.curves[options];
    }
    if (options instanceof elliptic.curves.PresetCurve)
      options = {curve: options};
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  module.exports = EC;
  EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new elliptic.hmacDRBG({
      hash: this.hash,
      pers: options.pers,
      entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
      nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN(2));
    do {
      var priv = new BN(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    } while (true);
  };
  EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === 'object') {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN(msg, 16));
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray('be', bytes);
    var nonce = msg.toArray('be', bytes);
    var drbg = new elliptic.hmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce: nonce,
      pers: options.pers,
      persEnc: options.persEnc
    });
    var ns1 = this.n.sub(new BN(1));
    for (var iter = 0; true; iter++) {
      var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
      k = this._truncateToN(k, true);
      if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r = kpX.umod(this.n);
      if (r.cmpn(0) === 0)
        continue;
      var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
      s = s.umod(this.n);
      if (s.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
      if (options.canonical && s.cmp(this.nh) > 0) {
        s = this.n.sub(s);
        recoveryParam ^= 1;
      }
      return new Signature({
        r: r,
        s: s,
        recoveryParam: recoveryParam
      });
    }
  };
  EC.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new BN(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature(signature, 'hex');
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
      return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
      return false;
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    if (!this.curve._maxwellTrick) {
      var p = this.g.mulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.getX().umod(this.n).cmp(r) === 0;
    }
    var p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.eqXToP(r);
  };
  EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
    assert((3 & j) === j, 'The recovery param is more than two bits');
    signature = new Signature(signature, enc);
    var n = this.n;
    var e = new BN(msg);
    var r = signature.r;
    var s = signature.s;
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error('Unable to find sencond key candinate');
    if (isSecondKey)
      r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else
      r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
    return this.g.mulAdd(s1, r, s2);
  };
  EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
    signature = new Signature(signature, enc);
    if (signature.recoveryParam !== null)
      return signature.recoveryParam;
    for (var i = 0; i < 4; i++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature, i);
      } catch (e) {
        continue;
      }
      if (Qprime.eq(Q))
        return i;
    }
    throw new Error('Unable to find valid recovery factor');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b9", ["ad"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var utils = exports;
  var inherits = $__require('ad');
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === 'string') {
      if (!enc) {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 0xff;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      } else if (enc === 'hex') {
        msg = msg.replace(/[^a-z0-9]+/ig, '');
        if (msg.length % 2 !== 0)
          msg = '0' + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    } else {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
    }
    return res;
  }
  utils.toArray = toArray;
  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;
  function htonl(w) {
    var res = (w >>> 24) | ((w >>> 8) & 0xff00) | ((w << 8) & 0xff0000) | ((w & 0xff) << 24);
    return res >>> 0;
  }
  utils.htonl = htonl;
  function toHex32(msg, endian) {
    var res = '';
    for (var i = 0; i < msg.length; i++) {
      var w = msg[i];
      if (endian === 'little')
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  }
  utils.toHex32 = toHex32;
  function zero2(word) {
    if (word.length === 1)
      return '0' + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function zero8(word) {
    if (word.length === 7)
      return '0' + word;
    else if (word.length === 6)
      return '00' + word;
    else if (word.length === 5)
      return '000' + word;
    else if (word.length === 4)
      return '0000' + word;
    else if (word.length === 3)
      return '00000' + word;
    else if (word.length === 2)
      return '000000' + word;
    else if (word.length === 1)
      return '0000000' + word;
    else
      return word;
  }
  utils.zero8 = zero8;
  function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i = 0,
        k = start; i < res.length; i++, k += 4) {
      var w;
      if (endian === 'big')
        w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
      else
        w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
      res[i] = w >>> 0;
    }
    return res;
  }
  utils.join32 = join32;
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i = 0,
        k = 0; i < msg.length; i++, k += 4) {
      var m = msg[i];
      if (endian === 'big') {
        res[k] = m >>> 24;
        res[k + 1] = (m >>> 16) & 0xff;
        res[k + 2] = (m >>> 8) & 0xff;
        res[k + 3] = m & 0xff;
      } else {
        res[k + 3] = m >>> 24;
        res[k + 2] = (m >>> 16) & 0xff;
        res[k + 1] = (m >>> 8) & 0xff;
        res[k] = m & 0xff;
      }
    }
    return res;
  }
  utils.split32 = split32;
  function rotr32(w, b) {
    return (w >>> b) | (w << (32 - b));
  }
  utils.rotr32 = rotr32;
  function rotl32(w, b) {
    return (w << b) | (w >>> (32 - b));
  }
  utils.rotl32 = rotl32;
  function sum32(a, b) {
    return (a + b) >>> 0;
  }
  utils.sum32 = sum32;
  function sum32_3(a, b, c) {
    return (a + b + c) >>> 0;
  }
  utils.sum32_3 = sum32_3;
  function sum32_4(a, b, c, d) {
    return (a + b + c + d) >>> 0;
  }
  utils.sum32_4 = sum32_4;
  function sum32_5(a, b, c, d, e) {
    return (a + b + c + d + e) >>> 0;
  }
  utils.sum32_5 = sum32_5;
  function assert(cond, msg) {
    if (!cond)
      throw new Error(msg || 'Assertion failed');
  }
  utils.assert = assert;
  utils.inherits = inherits;
  function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  exports.sum64 = sum64;
  function sum64_hi(ah, al, bh, bl) {
    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  ;
  exports.sum64_hi = sum64_hi;
  function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  ;
  exports.sum64_lo = sum64_lo;
  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }
  ;
  exports.sum64_4_hi = sum64_4_hi;
  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  ;
  exports.sum64_4_lo = sum64_4_lo;
  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = (lo + el) >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }
  ;
  exports.sum64_5_hi = sum64_5_hi;
  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  }
  ;
  exports.sum64_5_lo = sum64_5_lo;
  function rotr64_hi(ah, al, num) {
    var r = (al << (32 - num)) | (ah >>> num);
    return r >>> 0;
  }
  ;
  exports.rotr64_hi = rotr64_hi;
  function rotr64_lo(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
  }
  ;
  exports.rotr64_lo = rotr64_lo;
  function shr64_hi(ah, al, num) {
    return ah >>> num;
  }
  ;
  exports.shr64_hi = shr64_hi;
  function shr64_lo(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
  }
  ;
  exports.shr64_lo = shr64_lo;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ba", ["1bb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hash = $__require('1bb');
  var utils = hash.utils;
  var assert = utils.assert;
  function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = 'big';
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  exports.BlockHash = BlockHash;
  BlockHash.prototype.update = function update(msg, enc) {
    msg = utils.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils.join32(msg, 0, msg.length - r, this.endian);
      for (var i = 0; i < msg.length; i += this._delta32)
        this._update(msg, i, i + this._delta32);
    }
    return this;
  };
  BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
  };
  BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - ((len + this.padLength) % bytes);
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for (var i = 1; i < k; i++)
      res[i] = 0;
    len <<= 3;
    if (this.endian === 'big') {
      for (var t = 8; t < this.padLength; t++)
        res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = (len >>> 24) & 0xff;
      res[i++] = (len >>> 16) & 0xff;
      res[i++] = (len >>> 8) & 0xff;
      res[i++] = len & 0xff;
    } else {
      res[i++] = len & 0xff;
      res[i++] = (len >>> 8) & 0xff;
      res[i++] = (len >>> 16) & 0xff;
      res[i++] = (len >>> 24) & 0xff;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      for (var t = 8; t < this.padLength; t++)
        res[i++] = 0;
    }
    return res;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1bc", ["1bb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hash = $__require('1bb');
  var utils = hash.utils;
  var assert = utils.assert;
  var rotr32 = utils.rotr32;
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_4 = utils.sum32_4;
  var sum32_5 = utils.sum32_5;
  var rotr64_hi = utils.rotr64_hi;
  var rotr64_lo = utils.rotr64_lo;
  var shr64_hi = utils.shr64_hi;
  var shr64_lo = utils.shr64_lo;
  var sum64 = utils.sum64;
  var sum64_hi = utils.sum64_hi;
  var sum64_lo = utils.sum64_lo;
  var sum64_4_hi = utils.sum64_4_hi;
  var sum64_4_lo = utils.sum64_4_lo;
  var sum64_5_hi = utils.sum64_5_hi;
  var sum64_5_lo = utils.sum64_5_lo;
  var BlockHash = hash.common.BlockHash;
  var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
  var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
  var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];
  function SHA256() {
    if (!(this instanceof SHA256))
      return new SHA256();
    BlockHash.call(this);
    this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils.inherits(SHA256, BlockHash);
  exports.sha256 = SHA256;
  SHA256.blockSize = 512;
  SHA256.outSize = 256;
  SHA256.hmacStrength = 192;
  SHA256.padLength = 64;
  SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i++)
      W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for (var i = 0; i < W.length; i++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
      var T2 = sum32(s0_256(a), maj32(a, b, c));
      h = g;
      g = f;
      f = e;
      e = sum32(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
  };
  SHA256.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'big');
    else
      return utils.split32(this.h, 'big');
  };
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
    SHA256.call(this);
    this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
  }
  utils.inherits(SHA224, SHA256);
  exports.sha224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h.slice(0, 7), 'big');
    else
      return utils.split32(this.h.slice(0, 7), 'big');
  };
  function SHA512() {
    if (!(this instanceof SHA512))
      return new SHA512();
    BlockHash.call(this);
    this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils.inherits(SHA512, BlockHash);
  exports.sha512 = SHA512;
  SHA512.blockSize = 1024;
  SHA512.outSize = 512;
  SHA512.hmacStrength = 192;
  SHA512.padLength = 128;
  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    for (var i = 0; i < 32; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i += 2) {
      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      var c1_hi = W[i - 14];
      var c1_lo = W[i - 13];
      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      var c3_hi = W[i - 32];
      var c3_lo = W[i - 31];
      W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
  };
  SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for (var i = 0; i < W.length; i += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i];
      var c3_lo = this.k[i + 1];
      var c4_hi = W[i];
      var c4_lo = W[i + 1];
      var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      var c0_hi = s0_512_hi(ah, al);
      var c0_lo = s0_512_lo(ah, al);
      var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
      var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  SHA512.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'big');
    else
      return utils.split32(this.h, 'big');
  };
  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();
    SHA512.call(this);
    this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];
  }
  utils.inherits(SHA384, SHA512);
  exports.sha384 = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h.slice(0, 12), 'big');
    else
      return utils.split32(this.h.slice(0, 12), 'big');
  };
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
    BlockHash.call(this);
    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    this.W = new Array(80);
  }
  utils.inherits(SHA1, BlockHash);
  exports.sha1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i++)
      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for (var i = 0; i < W.length; i++) {
      var s = ~~(i / 20);
      var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32(b, 30);
      b = a;
      a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'big');
    else
      return utils.split32(this.h, 'big');
  };
  function ch32(x, y, z) {
    return (x & y) ^ ((~x) & z);
  }
  function maj32(x, y, z) {
    return (x & y) ^ (x & z) ^ (y & z);
  }
  function p32(x, y, z) {
    return x ^ y ^ z;
  }
  function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  }
  function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  }
  function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
  }
  function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
  }
  function ft_1(s, x, y, z) {
    if (s === 0)
      return ch32(x, y, z);
    if (s === 1 || s === 3)
      return p32(x, y, z);
    if (s === 2)
      return maj32(x, y, z);
  }
  function ch64_hi(xh, xl, yh, yl, zh, zl) {
    var r = (xh & yh) ^ ((~xh) & zh);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = (xl & yl) ^ ((~xl) & zl);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function maj64_hi(xh, xl, yh, yl, zh, zl) {
    var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1bd", ["1bb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hash = $__require('1bb');
  var utils = hash.utils;
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_3 = utils.sum32_3;
  var sum32_4 = utils.sum32_4;
  var BlockHash = hash.common.BlockHash;
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();
    BlockHash.call(this);
    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    this.endian = 'little';
  }
  utils.inherits(RIPEMD160, BlockHash);
  exports.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'little');
    else
      return utils.split32(this.h, 'little');
  };
  function f(j, x, y, z) {
    if (j <= 15)
      return x ^ y ^ z;
    else if (j <= 31)
      return (x & y) | ((~x) & z);
    else if (j <= 47)
      return (x | (~y)) ^ z;
    else if (j <= 63)
      return (x & z) | (y & (~z));
    else
      return x ^ (y | (~z));
  }
  function K(j) {
    if (j <= 15)
      return 0x00000000;
    else if (j <= 31)
      return 0x5a827999;
    else if (j <= 47)
      return 0x6ed9eba1;
    else if (j <= 63)
      return 0x8f1bbcdc;
    else
      return 0xa953fd4e;
  }
  function Kh(j) {
    if (j <= 15)
      return 0x50a28be6;
    else if (j <= 31)
      return 0x5c4dd124;
    else if (j <= 47)
      return 0x6d703ef3;
    else if (j <= 63)
      return 0x7a6d76e9;
    else
      return 0x00000000;
  }
  var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
  var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
  var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
  var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1be", ["1bb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hmac = exports;
  var hash = $__require('1bb');
  var utils = hash.utils;
  var assert = utils.assert;
  function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
  }
  module.exports = Hmac;
  Hmac.prototype._init = function init(key) {
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    for (var i = key.length; i < this.blockSize; i++)
      key.push(0);
    for (var i = 0; i < key.length; i++)
      key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
    for (var i = 0; i < key.length; i++)
      key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1bb", ["1b9", "1ba", "1bc", "1bd", "1be"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hash = exports;
  hash.utils = $__require('1b9');
  hash.common = $__require('1ba');
  hash.sha = $__require('1bc');
  hash.ripemd = $__require('1bd');
  hash.hmac = $__require('1be');
  hash.sha1 = hash.sha.sha1;
  hash.sha256 = hash.sha.sha256;
  hash.sha224 = hash.sha.sha224;
  hash.sha384 = hash.sha.sha384;
  hash.sha512 = hash.sha.sha512;
  hash.ripemd160 = hash.ripemd.ripemd160;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ae", ["1bb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1bb');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1bf", ["1ad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var elliptic = $__require('1ad');
  var utils = elliptic.utils;
  var assert = utils.assert;
  var parseBytes = utils.parseBytes;
  var cachedProperty = utils.cachedProperty;
  function KeyPair(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes(params.secret);
    if (eddsa.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes(params.pub);
  }
  KeyPair.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(eddsa, {pub: pub});
  };
  KeyPair.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair)
      return secret;
    return new KeyPair(eddsa, {secret: secret});
  };
  KeyPair.prototype.secret = function secret() {
    return this._secret;
  };
  cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty(KeyPair, 'pub', function pub() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty(KeyPair, 'privBytes', function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;
    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
  });
  cachedProperty(KeyPair, 'priv', function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty(KeyPair, 'hash', function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  KeyPair.prototype.sign = function sign(message) {
    assert(this._secret, 'KeyPair can only verify');
    return this.eddsa.sign(message, this);
  };
  KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  KeyPair.prototype.getSecret = function getSecret(enc) {
    assert(this._secret, 'KeyPair is public only');
    return utils.encode(this.secret(), enc);
  };
  KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils.encode(this.pubBytes(), enc);
  };
  module.exports = KeyPair;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c0", ["197", "1ad"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var BN = $__require('197');
  var elliptic = $__require('1ad');
  var utils = elliptic.utils;
  var assert = utils.assert;
  var cachedProperty = utils.cachedProperty;
  var parseBytes = utils.parseBytes;
  function Signature(eddsa, sig) {
    this.eddsa = eddsa;
    if (typeof sig !== 'object')
      sig = parseBytes(sig);
    if (Array.isArray(sig)) {
      sig = {
        R: sig.slice(0, eddsa.encodingLength),
        S: sig.slice(eddsa.encodingLength)
      };
    }
    assert(sig.R && sig.S, 'Signature without R or S');
    if (eddsa.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN)
      this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }
  cachedProperty(Signature, 'S', function S() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty(Signature, 'R', function R() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty(Signature, 'Rencoded', function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty(Signature, 'Sencoded', function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });
  Signature.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Signature.prototype.toHex = function toHex() {
    return utils.encode(this.toBytes(), 'hex').toUpperCase();
  };
  module.exports = Signature;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c1", ["1ae", "1ad", "1bf", "1c0"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hash = $__require('1ae');
  var elliptic = $__require('1ad');
  var utils = elliptic.utils;
  var assert = utils.assert;
  var parseBytes = utils.parseBytes;
  var KeyPair = $__require('1bf');
  var Signature = $__require('1c0');
  function EDDSA(curve) {
    assert(curve === 'ed25519', 'only tested with ed25519 so far');
    if (!(this instanceof EDDSA))
      return new EDDSA(curve);
    var curve = elliptic.curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash.sha512;
  }
  module.exports = EDDSA;
  EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({
      R: R,
      S: S,
      Rencoded: Rencoded
    });
  };
  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
  };
  EDDSA.prototype.hashInt = function hashInt() {
    var hash = this.hash();
    for (var i = 0; i < arguments.length; i++)
      hash.update(arguments[i]);
    return utils.intFromLE(hash.digest()).umod(this.curve.n);
  };
  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };
  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };
  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature)
      return sig;
    return new Signature(this, sig);
  };
  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray('le', this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
    return enc;
  };
  EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
    var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
    var y = utils.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };
  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray('le', this.encodingLength);
  };
  EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils.intFromLE(bytes);
  };
  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ad", ["1a9", "1aa", "196", "1ac", "1b1", "1b5", "1b8", "1c1"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var elliptic = exports;
  elliptic.version = $__require('1a9').version;
  elliptic.utils = $__require('1aa');
  elliptic.rand = $__require('196');
  elliptic.hmacDRBG = $__require('1ac');
  elliptic.curve = $__require('1b1');
  elliptic.curves = $__require('1b5');
  elliptic.ec = $__require('1b8');
  elliptic.eddsa = $__require('1c1');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a3", ["1ad"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1ad');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c2", ["1a3", "197", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var elliptic = $__require('1a3');
    var BN = $__require('197');
    module.exports = function createECDH(curve) {
      return new ECDH(curve);
    };
    var aliases = {
      secp256k1: {
        name: 'secp256k1',
        byteLength: 32
      },
      secp224r1: {
        name: 'p224',
        byteLength: 28
      },
      prime256v1: {
        name: 'p256',
        byteLength: 32
      },
      prime192v1: {
        name: 'p192',
        byteLength: 24
      },
      ed25519: {
        name: 'ed25519',
        byteLength: 32
      },
      secp384r1: {
        name: 'p384',
        byteLength: 48
      },
      secp521r1: {
        name: 'p521',
        byteLength: 66
      }
    };
    aliases.p224 = aliases.secp224r1;
    aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
    aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
    aliases.p384 = aliases.secp384r1;
    aliases.p521 = aliases.secp521r1;
    function ECDH(curve) {
      this.curveType = aliases[curve];
      if (!this.curveType) {
        this.curveType = {name: curve};
      }
      this.curve = new elliptic.ec(this.curveType.name);
      this.keys = void 0;
    }
    ECDH.prototype.generateKeys = function(enc, format) {
      this.keys = this.curve.genKeyPair();
      return this.getPublicKey(enc, format);
    };
    ECDH.prototype.computeSecret = function(other, inenc, enc) {
      inenc = inenc || 'utf8';
      if (!Buffer.isBuffer(other)) {
        other = new Buffer(other, inenc);
      }
      var otherPub = this.curve.keyFromPublic(other).getPublic();
      var out = otherPub.mul(this.keys.getPrivate()).getX();
      return formatReturnValue(out, enc, this.curveType.byteLength);
    };
    ECDH.prototype.getPublicKey = function(enc, format) {
      var key = this.keys.getPublic(format === 'compressed', true);
      if (format === 'hybrid') {
        if (key[key.length - 1] % 2) {
          key[0] = 7;
        } else {
          key[0] = 6;
        }
      }
      return formatReturnValue(key, enc);
    };
    ECDH.prototype.getPrivateKey = function(enc) {
      return formatReturnValue(this.keys.getPrivate(), enc);
    };
    ECDH.prototype.setPublicKey = function(pub, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(pub)) {
        pub = new Buffer(pub, enc);
      }
      this.keys._importPublic(pub);
      return this;
    };
    ECDH.prototype.setPrivateKey = function(priv, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(priv)) {
        priv = new Buffer(priv, enc);
      }
      var _priv = new BN(priv);
      _priv = _priv.toString(16);
      this.keys._importPrivate(_priv);
      return this;
    };
    function formatReturnValue(bn, enc, len) {
      if (!Array.isArray(bn)) {
        bn = bn.toArray();
      }
      var buf = new Buffer(bn);
      if (len && buf.length < len) {
        var zeros = new Buffer(len - buf.length);
        zeros.fill(0);
        buf = Buffer.concat([zeros, buf]);
      }
      if (!enc) {
        return buf;
      } else {
        return buf.toString(enc);
      }
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c3", ["1c2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1c2');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c4", ["1a4", "19a", "1a7", "1c5", "1c6", "197", "1c7", "1a2", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var parseKeys = $__require('1a4');
    var randomBytes = $__require('19a');
    var createHash = $__require('1a7');
    var mgf = $__require('1c5');
    var xor = $__require('1c6');
    var bn = $__require('197');
    var withPublic = $__require('1c7');
    var crt = $__require('1a2');
    var constants = {
      RSA_PKCS1_OAEP_PADDING: 4,
      RSA_PKCS1_PADDIN: 1,
      RSA_NO_PADDING: 3
    };
    module.exports = function publicEncrypt(public_key, msg, reverse) {
      var padding;
      if (public_key.padding) {
        padding = public_key.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(public_key);
      var paddedMsg;
      if (padding === 4) {
        paddedMsg = oaep(key, msg);
      } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        paddedMsg = new bn(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
          throw new Error('data too long for modulus');
        }
      } else {
        throw new Error('unknown padding');
      }
      if (reverse) {
        return crt(paddedMsg, key);
      } else {
        return withPublic(paddedMsg, key);
      }
    };
    function oaep(key, msg) {
      var k = key.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash('sha1').update(new Buffer('')).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (mLen > k - hLen2 - 2) {
        throw new Error('message too long');
      }
      var ps = new Buffer(k - mLen - hLen2 - 2);
      ps.fill(0);
      var dblen = k - hLen - 1;
      var seed = randomBytes(hLen);
      var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
      var maskedSeed = xor(seed, mgf(maskedDb, hLen));
      return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
    }
    function pkcs1(key, msg, reverse) {
      var mLen = msg.length;
      var k = key.modulus.byteLength();
      if (mLen > k - 11) {
        throw new Error('message too long');
      }
      var ps;
      if (reverse) {
        ps = new Buffer(k - mLen - 3);
        ps.fill(0xff);
      } else {
        ps = nonZero(k - mLen - 3);
      }
      return new bn(Buffer.concat([new Buffer([0, reverse ? 1 : 2]), ps, new Buffer([0]), msg], k));
    }
    function nonZero(len, crypto) {
      var out = new Buffer(len);
      var i = 0;
      var cache = randomBytes(len * 2);
      var cur = 0;
      var num;
      while (i < len) {
        if (cur === cache.length) {
          cache = randomBytes(len * 2);
          cur = 0;
        }
        num = cache[cur++];
        if (num) {
          out[i++] = num;
        }
      }
      return out;
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c8", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var indexOf = [].indexOf;
  module.exports = function(arr, obj) {
    if (indexOf)
      return arr.indexOf(obj);
    for (var i = 0; i < arr.length; ++i) {
      if (arr[i] === obj)
        return i;
    }
    return -1;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c9", ["1c8"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1c8');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ca", ["1c9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var indexOf = $__require('1c9');
  var Object_keys = function(obj) {
    if (Object.keys)
      return Object.keys(obj);
    else {
      var res = [];
      for (var key in obj)
        res.push(key);
      return res;
    }
  };
  var forEach = function(xs, fn) {
    if (xs.forEach)
      return xs.forEach(fn);
    else
      for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
      }
  };
  var defineProp = (function() {
    try {
      Object.defineProperty({}, '_', {});
      return function(obj, name, value) {
        Object.defineProperty(obj, name, {
          writable: true,
          enumerable: false,
          configurable: true,
          value: value
        });
      };
    } catch (e) {
      return function(obj, name, value) {
        obj[name] = value;
      };
    }
  }());
  var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function', 'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError', 'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape', 'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];
  function Context() {}
  Context.prototype = {};
  var Script = exports.Script = function NodeScript(code) {
    if (!(this instanceof Script))
      return new Script(code);
    this.code = code;
  };
  Script.prototype.runInContext = function(context) {
    if (!(context instanceof Context)) {
      throw new TypeError("needs a 'context' argument.");
    }
    var iframe = document.createElement('iframe');
    if (!iframe.style)
      iframe.style = {};
    iframe.style.display = 'none';
    document.body.appendChild(iframe);
    var win = iframe.contentWindow;
    var wEval = win.eval,
        wExecScript = win.execScript;
    if (!wEval && wExecScript) {
      wExecScript.call(win, 'null');
      wEval = win.eval;
    }
    forEach(Object_keys(context), function(key) {
      win[key] = context[key];
    });
    forEach(globals, function(key) {
      if (context[key]) {
        win[key] = context[key];
      }
    });
    var winKeys = Object_keys(win);
    var res = wEval.call(win, this.code);
    forEach(Object_keys(win), function(key) {
      if (key in context || indexOf(winKeys, key) === -1) {
        context[key] = win[key];
      }
    });
    forEach(globals, function(key) {
      if (!(key in context)) {
        defineProp(context, key, win[key]);
      }
    });
    document.body.removeChild(iframe);
    return res;
  };
  Script.prototype.runInThisContext = function() {
    return eval(this.code);
  };
  Script.prototype.runInNewContext = function(context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);
    forEach(Object_keys(ctx), function(key) {
      context[key] = ctx[key];
    });
    return res;
  };
  forEach(Object_keys(Script.prototype), function(name) {
    exports[name] = Script[name] = function(code) {
      var s = Script(code);
      return s[name].apply(s, [].slice.call(arguments, 1));
    };
  });
  exports.createScript = function(code) {
    return exports.Script(code);
  };
  exports.createContext = Script.createContext = function(context) {
    var copy = new Context();
    if (typeof context === 'object') {
      forEach(Object_keys(context), function(key) {
        copy[key] = context[key];
      });
    }
    return copy;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1cb", ["1ca"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1ca');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1cc", ["1cb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('vm') : $__require('1cb');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1cd", ["1cc"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1cc');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ce", ["1cf", "ad", "1cd"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var asn1 = $__require('1cf');
  var inherits = $__require('ad');
  var api = exports;
  api.define = function define(name, body) {
    return new Entity(name, body);
  };
  function Entity(name, body) {
    this.name = name;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
  }
  ;
  Entity.prototype._createNamed = function createNamed(base) {
    var named;
    try {
      named = $__require('1cd').runInThisContext('(function ' + this.name + '(entity) {\n' + '  this._initNamed(entity);\n' + '})');
    } catch (e) {
      named = function(entity) {
        this._initNamed(entity);
      };
    }
    inherits(named, base);
    named.prototype._initNamed = function initnamed(entity) {
      base.call(this, entity);
    };
    return new named(this);
  };
  Entity.prototype._getDecoder = function _getDecoder(enc) {
    enc = enc || 'der';
    if (!this.decoders.hasOwnProperty(enc))
      this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
    return this.decoders[enc];
  };
  Entity.prototype.decode = function decode(data, enc, options) {
    return this._getDecoder(enc).decode(data, options);
  };
  Entity.prototype._getEncoder = function _getEncoder(enc) {
    enc = enc || 'der';
    if (!this.encoders.hasOwnProperty(enc))
      this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
    return this.encoders[enc];
  };
  Entity.prototype.encode = function encode(data, enc, reporter) {
    return this._getEncoder(enc).encode(data, reporter);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d0", ["ad"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var inherits = $__require('ad');
  function Reporter(options) {
    this._reporterState = {
      obj: null,
      path: [],
      options: options || {},
      errors: []
    };
  }
  exports.Reporter = Reporter;
  Reporter.prototype.isError = function isError(obj) {
    return obj instanceof ReporterError;
  };
  Reporter.prototype.save = function save() {
    var state = this._reporterState;
    return {
      obj: state.obj,
      pathLen: state.path.length
    };
  };
  Reporter.prototype.restore = function restore(data) {
    var state = this._reporterState;
    state.obj = data.obj;
    state.path = state.path.slice(0, data.pathLen);
  };
  Reporter.prototype.enterKey = function enterKey(key) {
    return this._reporterState.path.push(key);
  };
  Reporter.prototype.exitKey = function exitKey(index) {
    var state = this._reporterState;
    state.path = state.path.slice(0, index - 1);
  };
  Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
    var state = this._reporterState;
    this.exitKey(index);
    if (state.obj !== null)
      state.obj[key] = value;
  };
  Reporter.prototype.path = function path() {
    return this._reporterState.path.join('/');
  };
  Reporter.prototype.enterObject = function enterObject() {
    var state = this._reporterState;
    var prev = state.obj;
    state.obj = {};
    return prev;
  };
  Reporter.prototype.leaveObject = function leaveObject(prev) {
    var state = this._reporterState;
    var now = state.obj;
    state.obj = prev;
    return now;
  };
  Reporter.prototype.error = function error(msg) {
    var err;
    var state = this._reporterState;
    var inherited = msg instanceof ReporterError;
    if (inherited) {
      err = msg;
    } else {
      err = new ReporterError(state.path.map(function(elem) {
        return '[' + JSON.stringify(elem) + ']';
      }).join(''), msg.message || msg, msg.stack);
    }
    if (!state.options.partial)
      throw err;
    if (!inherited)
      state.errors.push(err);
    return err;
  };
  Reporter.prototype.wrapResult = function wrapResult(result) {
    var state = this._reporterState;
    if (!state.options.partial)
      return result;
    return {
      result: this.isError(result) ? null : result,
      errors: state.errors
    };
  };
  function ReporterError(path, msg) {
    this.path = path;
    this.rethrow(msg);
  }
  ;
  inherits(ReporterError, Error);
  ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + ' at: ' + (this.path || '(shallow)');
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, ReporterError);
    if (!this.stack) {
      try {
        throw new Error(this.message);
      } catch (e) {
        this.stack = e.stack;
      }
    }
    return this;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d1", ["ad", "1d2", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = $__require('ad');
    var Reporter = $__require('1d2').Reporter;
    var Buffer = $__require('72').Buffer;
    function DecoderBuffer(base, options) {
      Reporter.call(this, options);
      if (!Buffer.isBuffer(base)) {
        this.error('Input not Buffer');
        return;
      }
      this.base = base;
      this.offset = 0;
      this.length = base.length;
    }
    inherits(DecoderBuffer, Reporter);
    exports.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.prototype.save = function save() {
      return {
        offset: this.offset,
        reporter: Reporter.prototype.save.call(this)
      };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      var res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || 'DecoderBuffer overrun');
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || 'DecoderBuffer overrun');
      var res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
          if (!(item instanceof EncoderBuffer))
            item = new EncoderBuffer(item, reporter);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === 'number') {
        if (!(0 <= value && value <= 0xff))
          return reporter.error('non-byte EncoderBuffer value');
        this.value = value;
        this.length = 1;
      } else if (typeof value === 'string') {
        this.value = value;
        this.length = Buffer.byteLength(value);
      } else if (Buffer.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter.error('Unsupported type: ' + typeof value);
      }
    }
    exports.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out)
        out = new Buffer(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === 'number')
          out[offset] = this.value;
        else if (typeof this.value === 'string')
          out.write(this.value, offset);
        else if (Buffer.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d3", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = assert;
  function assert(val, msg) {
    if (!val)
      throw new Error(msg || 'Assertion failed');
  }
  assert.equal = function assertEqual(l, r, msg) {
    if (l != r)
      throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("af", ["1d3"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1d3');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d4", ["1d2", "af"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Reporter = $__require('1d2').Reporter;
  var EncoderBuffer = $__require('1d2').EncoderBuffer;
  var DecoderBuffer = $__require('1d2').DecoderBuffer;
  var assert = $__require('af');
  var tags = ['seq', 'seqof', 'set', 'setof', 'objid', 'bool', 'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc', 'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str', 'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'];
  var methods = ['key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice', 'any', 'contains'].concat(tags);
  var overrided = ['_peekTag', '_decodeTag', '_use', '_decodeStr', '_decodeObjid', '_decodeTime', '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList', '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime', '_encodeNull', '_encodeInt', '_encodeBool'];
  function Node(enc, parent) {
    var state = {};
    this._baseState = state;
    state.enc = enc;
    state.parent = parent || null;
    state.children = null;
    state.tag = null;
    state.args = null;
    state.reverseArgs = null;
    state.choice = null;
    state.optional = false;
    state.any = false;
    state.obj = false;
    state.use = null;
    state.useDecoder = null;
    state.key = null;
    state['default'] = null;
    state.explicit = null;
    state.implicit = null;
    state.contains = null;
    if (!state.parent) {
      state.children = [];
      this._wrap();
    }
  }
  module.exports = Node;
  var stateProps = ['enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice', 'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit', 'implicit', 'contains'];
  Node.prototype.clone = function clone() {
    var state = this._baseState;
    var cstate = {};
    stateProps.forEach(function(prop) {
      cstate[prop] = state[prop];
    });
    var res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
  };
  Node.prototype._wrap = function wrap() {
    var state = this._baseState;
    methods.forEach(function(method) {
      this[method] = function _wrappedMethod() {
        var clone = new this.constructor(this);
        state.children.push(clone);
        return clone[method].apply(clone, arguments);
      };
    }, this);
  };
  Node.prototype._init = function init(body) {
    var state = this._baseState;
    assert(state.parent === null);
    body.call(this);
    state.children = state.children.filter(function(child) {
      return child._baseState.parent === this;
    }, this);
    assert.equal(state.children.length, 1, 'Root node can have only one child');
  };
  Node.prototype._useArgs = function useArgs(args) {
    var state = this._baseState;
    var children = args.filter(function(arg) {
      return arg instanceof this.constructor;
    }, this);
    args = args.filter(function(arg) {
      return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
      assert(state.children === null);
      state.children = children;
      children.forEach(function(child) {
        child._baseState.parent = this;
      }, this);
    }
    if (args.length !== 0) {
      assert(state.args === null);
      state.args = args;
      state.reverseArgs = args.map(function(arg) {
        if (typeof arg !== 'object' || arg.constructor !== Object)
          return arg;
        var res = {};
        Object.keys(arg).forEach(function(key) {
          if (key == (key | 0))
            key |= 0;
          var value = arg[key];
          res[value] = key;
        });
        return res;
      });
    }
  };
  overrided.forEach(function(method) {
    Node.prototype[method] = function _overrided() {
      var state = this._baseState;
      throw new Error(method + ' not implemented for encoding: ' + state.enc);
    };
  });
  tags.forEach(function(tag) {
    Node.prototype[tag] = function _tagMethod() {
      var state = this._baseState;
      var args = Array.prototype.slice.call(arguments);
      assert(state.tag === null);
      state.tag = tag;
      this._useArgs(args);
      return this;
    };
  });
  Node.prototype.use = function use(item) {
    assert(item);
    var state = this._baseState;
    assert(state.use === null);
    state.use = item;
    return this;
  };
  Node.prototype.optional = function optional() {
    var state = this._baseState;
    state.optional = true;
    return this;
  };
  Node.prototype.def = function def(val) {
    var state = this._baseState;
    assert(state['default'] === null);
    state['default'] = val;
    state.optional = true;
    return this;
  };
  Node.prototype.explicit = function explicit(num) {
    var state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.explicit = num;
    return this;
  };
  Node.prototype.implicit = function implicit(num) {
    var state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.implicit = num;
    return this;
  };
  Node.prototype.obj = function obj() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);
    state.obj = true;
    if (args.length !== 0)
      this._useArgs(args);
    return this;
  };
  Node.prototype.key = function key(newKey) {
    var state = this._baseState;
    assert(state.key === null);
    state.key = newKey;
    return this;
  };
  Node.prototype.any = function any() {
    var state = this._baseState;
    state.any = true;
    return this;
  };
  Node.prototype.choice = function choice(obj) {
    var state = this._baseState;
    assert(state.choice === null);
    state.choice = obj;
    this._useArgs(Object.keys(obj).map(function(key) {
      return obj[key];
    }));
    return this;
  };
  Node.prototype.contains = function contains(item) {
    var state = this._baseState;
    assert(state.use === null);
    state.contains = item;
    return this;
  };
  Node.prototype._decode = function decode(input, options) {
    var state = this._baseState;
    if (state.parent === null)
      return input.wrapResult(state.children[0]._decode(input, options));
    var result = state['default'];
    var present = true;
    var prevKey = null;
    if (state.key !== null)
      prevKey = input.enterKey(state.key);
    if (state.optional) {
      var tag = null;
      if (state.explicit !== null)
        tag = state.explicit;
      else if (state.implicit !== null)
        tag = state.implicit;
      else if (state.tag !== null)
        tag = state.tag;
      if (tag === null && !state.any) {
        var save = input.save();
        try {
          if (state.choice === null)
            this._decodeGeneric(state.tag, input, options);
          else
            this._decodeChoice(input, options);
          present = true;
        } catch (e) {
          present = false;
        }
        input.restore(save);
      } else {
        present = this._peekTag(input, tag, state.any);
        if (input.isError(present))
          return present;
      }
    }
    var prevObj;
    if (state.obj && present)
      prevObj = input.enterObject();
    if (present) {
      if (state.explicit !== null) {
        var explicit = this._decodeTag(input, state.explicit);
        if (input.isError(explicit))
          return explicit;
        input = explicit;
      }
      var start = input.offset;
      if (state.use === null && state.choice === null) {
        if (state.any)
          var save = input.save();
        var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
        if (input.isError(body))
          return body;
        if (state.any)
          result = input.raw(save);
        else
          input = body;
      }
      if (options && options.track && state.tag !== null)
        options.track(input.path(), start, input.length, 'tagged');
      if (options && options.track && state.tag !== null)
        options.track(input.path(), input.offset, input.length, 'content');
      if (state.any)
        result = result;
      else if (state.choice === null)
        result = this._decodeGeneric(state.tag, input, options);
      else
        result = this._decodeChoice(input, options);
      if (input.isError(result))
        return result;
      if (!state.any && state.choice === null && state.children !== null) {
        state.children.forEach(function decodeChildren(child) {
          child._decode(input, options);
        });
      }
      if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
        var data = new DecoderBuffer(result);
        result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
      }
    }
    if (state.obj && present)
      result = input.leaveObject(prevObj);
    if (state.key !== null && (result !== null || present === true))
      input.leaveKey(prevKey, state.key, result);
    else if (prevKey !== null)
      input.exitKey(prevKey);
    return result;
  };
  Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
    var state = this._baseState;
    if (tag === 'seq' || tag === 'set')
      return null;
    if (tag === 'seqof' || tag === 'setof')
      return this._decodeList(input, tag, state.args[0], options);
    else if (/str$/.test(tag))
      return this._decodeStr(input, tag, options);
    else if (tag === 'objid' && state.args)
      return this._decodeObjid(input, state.args[0], state.args[1], options);
    else if (tag === 'objid')
      return this._decodeObjid(input, null, null, options);
    else if (tag === 'gentime' || tag === 'utctime')
      return this._decodeTime(input, tag, options);
    else if (tag === 'null_')
      return this._decodeNull(input, options);
    else if (tag === 'bool')
      return this._decodeBool(input, options);
    else if (tag === 'objDesc')
      return this._decodeStr(input, tag, options);
    else if (tag === 'int' || tag === 'enum')
      return this._decodeInt(input, state.args && state.args[0], options);
    if (state.use !== null) {
      return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
    } else {
      return input.error('unknown tag: ' + tag);
    }
  };
  Node.prototype._getUse = function _getUse(entity, obj) {
    var state = this._baseState;
    state.useDecoder = this._use(entity, obj);
    assert(state.useDecoder._baseState.parent === null);
    state.useDecoder = state.useDecoder._baseState.children[0];
    if (state.implicit !== state.useDecoder._baseState.implicit) {
      state.useDecoder = state.useDecoder.clone();
      state.useDecoder._baseState.implicit = state.implicit;
    }
    return state.useDecoder;
  };
  Node.prototype._decodeChoice = function decodeChoice(input, options) {
    var state = this._baseState;
    var result = null;
    var match = false;
    Object.keys(state.choice).some(function(key) {
      var save = input.save();
      var node = state.choice[key];
      try {
        var value = node._decode(input, options);
        if (input.isError(value))
          return false;
        result = {
          type: key,
          value: value
        };
        match = true;
      } catch (e) {
        input.restore(save);
        return false;
      }
      return true;
    }, this);
    if (!match)
      return input.error('Choice not matched');
    return result;
  };
  Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
    return new EncoderBuffer(data, this.reporter);
  };
  Node.prototype._encode = function encode(data, reporter, parent) {
    var state = this._baseState;
    if (state['default'] !== null && state['default'] === data)
      return;
    var result = this._encodeValue(data, reporter, parent);
    if (result === undefined)
      return;
    if (this._skipDefault(result, reporter, parent))
      return;
    return result;
  };
  Node.prototype._encodeValue = function encode(data, reporter, parent) {
    var state = this._baseState;
    if (state.parent === null)
      return state.children[0]._encode(data, reporter || new Reporter());
    var result = null;
    this.reporter = reporter;
    if (state.optional && data === undefined) {
      if (state['default'] !== null)
        data = state['default'];
      else
        return;
    }
    var content = null;
    var primitive = false;
    if (state.any) {
      result = this._createEncoderBuffer(data);
    } else if (state.choice) {
      result = this._encodeChoice(data, reporter);
    } else if (state.contains) {
      content = this._getUse(state.contains, parent)._encode(data, reporter);
      primitive = true;
    } else if (state.children) {
      content = state.children.map(function(child) {
        if (child._baseState.tag === 'null_')
          return child._encode(null, reporter, data);
        if (child._baseState.key === null)
          return reporter.error('Child should have a key');
        var prevKey = reporter.enterKey(child._baseState.key);
        if (typeof data !== 'object')
          return reporter.error('Child expected, but input is not object');
        var res = child._encode(data[child._baseState.key], reporter, data);
        reporter.leaveKey(prevKey);
        return res;
      }, this).filter(function(child) {
        return child;
      });
      content = this._createEncoderBuffer(content);
    } else {
      if (state.tag === 'seqof' || state.tag === 'setof') {
        if (!(state.args && state.args.length === 1))
          return reporter.error('Too many args for : ' + state.tag);
        if (!Array.isArray(data))
          return reporter.error('seqof/setof, but data is not Array');
        var child = this.clone();
        child._baseState.implicit = null;
        content = this._createEncoderBuffer(data.map(function(item) {
          var state = this._baseState;
          return this._getUse(state.args[0], data)._encode(item, reporter);
        }, child));
      } else if (state.use !== null) {
        result = this._getUse(state.use, parent)._encode(data, reporter);
      } else {
        content = this._encodePrimitive(state.tag, data);
        primitive = true;
      }
    }
    var result;
    if (!state.any && state.choice === null) {
      var tag = state.implicit !== null ? state.implicit : state.tag;
      var cls = state.implicit === null ? 'universal' : 'context';
      if (tag === null) {
        if (state.use === null)
          reporter.error('Tag could be ommited only for .use()');
      } else {
        if (state.use === null)
          result = this._encodeComposite(tag, primitive, cls, content);
      }
    }
    if (state.explicit !== null)
      result = this._encodeComposite(state.explicit, false, 'context', result);
    return result;
  };
  Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
    var state = this._baseState;
    var node = state.choice[data.type];
    if (!node) {
      assert(false, data.type + ' not found in ' + JSON.stringify(Object.keys(state.choice)));
    }
    return node._encode(data.value, reporter);
  };
  Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
    var state = this._baseState;
    if (/str$/.test(tag))
      return this._encodeStr(data, tag);
    else if (tag === 'objid' && state.args)
      return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
    else if (tag === 'objid')
      return this._encodeObjid(data, null, null);
    else if (tag === 'gentime' || tag === 'utctime')
      return this._encodeTime(data, tag);
    else if (tag === 'null_')
      return this._encodeNull();
    else if (tag === 'int' || tag === 'enum')
      return this._encodeInt(data, state.args && state.reverseArgs[0]);
    else if (tag === 'bool')
      return this._encodeBool(data);
    else if (tag === 'objDesc')
      return this._encodeStr(data, tag);
    else
      throw new Error('Unsupported tag: ' + tag);
  };
  Node.prototype._isNumstr = function isNumstr(str) {
    return /^[0-9 ]*$/.test(str);
  };
  Node.prototype._isPrintstr = function isPrintstr(str) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d2", ["1d0", "1d1", "1d4"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var base = exports;
  base.Reporter = $__require('1d0').Reporter;
  base.DecoderBuffer = $__require('1d1').DecoderBuffer;
  base.EncoderBuffer = $__require('1d1').EncoderBuffer;
  base.Node = $__require('1d4');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d5", ["1d6"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var constants = $__require('1d6');
  exports.tagClass = {
    0: 'universal',
    1: 'application',
    2: 'context',
    3: 'private'
  };
  exports.tagClassByName = constants._reverse(exports.tagClass);
  exports.tag = {
    0x00: 'end',
    0x01: 'bool',
    0x02: 'int',
    0x03: 'bitstr',
    0x04: 'octstr',
    0x05: 'null_',
    0x06: 'objid',
    0x07: 'objDesc',
    0x08: 'external',
    0x09: 'real',
    0x0a: 'enum',
    0x0b: 'embed',
    0x0c: 'utf8str',
    0x0d: 'relativeOid',
    0x10: 'seq',
    0x11: 'set',
    0x12: 'numstr',
    0x13: 'printstr',
    0x14: 't61str',
    0x15: 'videostr',
    0x16: 'ia5str',
    0x17: 'utctime',
    0x18: 'gentime',
    0x19: 'graphstr',
    0x1a: 'iso646str',
    0x1b: 'genstr',
    0x1c: 'unistr',
    0x1d: 'charstr',
    0x1e: 'bmpstr'
  };
  exports.tagByName = constants._reverse(exports.tag);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d6", ["1d5"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var constants = exports;
  constants._reverse = function reverse(map) {
    var res = {};
    Object.keys(map).forEach(function(key) {
      if ((key | 0) == key)
        key = key | 0;
      var value = map[key];
      res[value] = key;
    });
    return res;
  };
  constants.der = $__require('1d5');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d7", ["ad", "1cf"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var inherits = $__require('ad');
  var asn1 = $__require('1cf');
  var base = asn1.base;
  var bignum = asn1.bignum;
  var der = asn1.constants.der;
  function DERDecoder(entity) {
    this.enc = 'der';
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
  }
  ;
  module.exports = DERDecoder;
  DERDecoder.prototype.decode = function decode(data, options) {
    if (!(data instanceof base.DecoderBuffer))
      data = new base.DecoderBuffer(data, options);
    return this.tree._decode(data, options);
  };
  function DERNode(parent) {
    base.Node.call(this, 'der', parent);
  }
  inherits(DERNode, base.Node);
  DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
    if (buffer.isEmpty())
      return false;
    var state = buffer.save();
    var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
    if (buffer.isError(decodedTag))
      return decodedTag;
    buffer.restore(state);
    return decodedTag.tag === tag || decodedTag.tagStr === tag || (decodedTag.tagStr + 'of') === tag || any;
  };
  DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
    var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
    if (buffer.isError(decodedTag))
      return decodedTag;
    var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
    if (buffer.isError(len))
      return len;
    if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + 'of' !== tag) {
      return buffer.error('Failed to match tag: "' + tag + '"');
    }
    if (decodedTag.primitive || len !== null)
      return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    var state = buffer.save();
    var res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
    if (buffer.isError(res))
      return res;
    len = buffer.offset - state.offset;
    buffer.restore(state);
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
  };
  DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
    while (true) {
      var tag = derDecodeTag(buffer, fail);
      if (buffer.isError(tag))
        return tag;
      var len = derDecodeLen(buffer, tag.primitive, fail);
      if (buffer.isError(len))
        return len;
      var res;
      if (tag.primitive || len !== null)
        res = buffer.skip(len);
      else
        res = this._skipUntilEnd(buffer, fail);
      if (buffer.isError(res))
        return res;
      if (tag.tagStr === 'end')
        break;
    }
  };
  DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
    var result = [];
    while (!buffer.isEmpty()) {
      var possibleEnd = this._peekTag(buffer, 'end');
      if (buffer.isError(possibleEnd))
        return possibleEnd;
      var res = decoder.decode(buffer, 'der', options);
      if (buffer.isError(res) && possibleEnd)
        break;
      result.push(res);
    }
    return result;
  };
  DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
    if (tag === 'bitstr') {
      var unused = buffer.readUInt8();
      if (buffer.isError(unused))
        return unused;
      return {
        unused: unused,
        data: buffer.raw()
      };
    } else if (tag === 'bmpstr') {
      var raw = buffer.raw();
      if (raw.length % 2 === 1)
        return buffer.error('Decoding of string type: bmpstr length mismatch');
      var str = '';
      for (var i = 0; i < raw.length / 2; i++) {
        str += String.fromCharCode(raw.readUInt16BE(i * 2));
      }
      return str;
    } else if (tag === 'numstr') {
      var numstr = buffer.raw().toString('ascii');
      if (!this._isNumstr(numstr)) {
        return buffer.error('Decoding of string type: ' + 'numstr unsupported characters');
      }
      return numstr;
    } else if (tag === 'octstr') {
      return buffer.raw();
    } else if (tag === 'objDesc') {
      return buffer.raw();
    } else if (tag === 'printstr') {
      var printstr = buffer.raw().toString('ascii');
      if (!this._isPrintstr(printstr)) {
        return buffer.error('Decoding of string type: ' + 'printstr unsupported characters');
      }
      return printstr;
    } else if (/str$/.test(tag)) {
      return buffer.raw().toString();
    } else {
      return buffer.error('Decoding of string type: ' + tag + ' unsupported');
    }
  };
  DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
    var result;
    var identifiers = [];
    var ident = 0;
    while (!buffer.isEmpty()) {
      var subident = buffer.readUInt8();
      ident <<= 7;
      ident |= subident & 0x7f;
      if ((subident & 0x80) === 0) {
        identifiers.push(ident);
        ident = 0;
      }
    }
    if (subident & 0x80)
      identifiers.push(ident);
    var first = (identifiers[0] / 40) | 0;
    var second = identifiers[0] % 40;
    if (relative)
      result = identifiers;
    else
      result = [first, second].concat(identifiers.slice(1));
    if (values) {
      var tmp = values[result.join(' ')];
      if (tmp === undefined)
        tmp = values[result.join('.')];
      if (tmp !== undefined)
        result = tmp;
    }
    return result;
  };
  DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
    var str = buffer.raw().toString();
    if (tag === 'gentime') {
      var year = str.slice(0, 4) | 0;
      var mon = str.slice(4, 6) | 0;
      var day = str.slice(6, 8) | 0;
      var hour = str.slice(8, 10) | 0;
      var min = str.slice(10, 12) | 0;
      var sec = str.slice(12, 14) | 0;
    } else if (tag === 'utctime') {
      var year = str.slice(0, 2) | 0;
      var mon = str.slice(2, 4) | 0;
      var day = str.slice(4, 6) | 0;
      var hour = str.slice(6, 8) | 0;
      var min = str.slice(8, 10) | 0;
      var sec = str.slice(10, 12) | 0;
      if (year < 70)
        year = 2000 + year;
      else
        year = 1900 + year;
    } else {
      return buffer.error('Decoding ' + tag + ' time is not supported yet');
    }
    return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
  };
  DERNode.prototype._decodeNull = function decodeNull(buffer) {
    return null;
  };
  DERNode.prototype._decodeBool = function decodeBool(buffer) {
    var res = buffer.readUInt8();
    if (buffer.isError(res))
      return res;
    else
      return res !== 0;
  };
  DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
    var raw = buffer.raw();
    var res = new bignum(raw);
    if (values)
      res = values[res.toString(10)] || res;
    return res;
  };
  DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === 'function')
      entity = entity(obj);
    return entity._getDecoder('der').tree;
  };
  function derDecodeTag(buf, fail) {
    var tag = buf.readUInt8(fail);
    if (buf.isError(tag))
      return tag;
    var cls = der.tagClass[tag >> 6];
    var primitive = (tag & 0x20) === 0;
    if ((tag & 0x1f) === 0x1f) {
      var oct = tag;
      tag = 0;
      while ((oct & 0x80) === 0x80) {
        oct = buf.readUInt8(fail);
        if (buf.isError(oct))
          return oct;
        tag <<= 7;
        tag |= oct & 0x7f;
      }
    } else {
      tag &= 0x1f;
    }
    var tagStr = der.tag[tag];
    return {
      cls: cls,
      primitive: primitive,
      tag: tag,
      tagStr: tagStr
    };
  }
  function derDecodeLen(buf, primitive, fail) {
    var len = buf.readUInt8(fail);
    if (buf.isError(len))
      return len;
    if (!primitive && len === 0x80)
      return null;
    if ((len & 0x80) === 0) {
      return len;
    }
    var num = len & 0x7f;
    if (num >= 4)
      return buf.error('length octect is too long');
    len = 0;
    for (var i = 0; i < num; i++) {
      len <<= 8;
      var j = buf.readUInt8(fail);
      if (buf.isError(j))
        return j;
      len |= j;
    }
    return len;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d8", ["ad", "72", "1d7"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = $__require('ad');
    var Buffer = $__require('72').Buffer;
    var DERDecoder = $__require('1d7');
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = 'pem';
    }
    ;
    inherits(PEMDecoder, DERDecoder);
    module.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode(data, options) {
      var lines = data.toString().split(/[\r\n]+/g);
      var label = options.label.toUpperCase();
      var re = /^-----(BEGIN|END) ([^-]+)-----$/;
      var start = -1;
      var end = -1;
      for (var i = 0; i < lines.length; i++) {
        var match = lines[i].match(re);
        if (match === null)
          continue;
        if (match[2] !== label)
          continue;
        if (start === -1) {
          if (match[1] !== 'BEGIN')
            break;
          start = i;
        } else {
          if (match[1] !== 'END')
            break;
          end = i;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error('PEM section not found for: ' + label);
      var base64 = lines.slice(start + 1, end).join('');
      base64.replace(/[^a-z0-9\+\/=]+/gi, '');
      var input = new Buffer(base64, 'base64');
      return DERDecoder.prototype.decode.call(this, input, options);
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d9", ["1d7", "1d8"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var decoders = exports;
  decoders.der = $__require('1d7');
  decoders.pem = $__require('1d8');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1da", ["ad", "72", "1cf"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = $__require('ad');
    var Buffer = $__require('72').Buffer;
    var asn1 = $__require('1cf');
    var base = asn1.base;
    var der = asn1.constants.der;
    function DEREncoder(entity) {
      this.enc = 'der';
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    ;
    module.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      base.Node.call(this, 'der', parent);
    }
    inherits(DERNode, base.Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 0x80) {
        var header = new Buffer(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([header, content]);
      }
      var lenOctets = 1;
      for (var i = content.length; i >= 0x100; i >>= 8)
        lenOctets++;
      var header = new Buffer(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 0x80 | lenOctets;
      for (var i = 1 + lenOctets,
          j = content.length; j > 0; i--, j >>= 8)
        header[i] = j & 0xff;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === 'bitstr') {
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      } else if (tag === 'bmpstr') {
        var buf = new Buffer(str.length * 2);
        for (var i = 0; i < str.length; i++) {
          buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf);
      } else if (tag === 'numstr') {
        if (!this._isNumstr(str)) {
          return this.reporter.error('Encoding of string type: numstr supports ' + 'only digits and space');
        }
        return this._createEncoderBuffer(str);
      } else if (tag === 'printstr') {
        if (!this._isPrintstr(str)) {
          return this.reporter.error('Encoding of string type: printstr supports ' + 'only latin upper and lower case letters, ' + 'digits, space, apostrophe, left and rigth ' + 'parenthesis, plus sign, comma, hyphen, ' + 'dot, slash, colon, equal sign, ' + 'question mark');
        }
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
      } else if (tag === 'objDesc') {
        return this._createEncoderBuffer(str);
      } else {
        return this.reporter.error('Encoding of string type: ' + tag + ' unsupported');
      }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
      if (typeof id === 'string') {
        if (!values)
          return this.reporter.error('string objid given, but no values map found');
        if (!values.hasOwnProperty(id))
          return this.reporter.error('objid not found in values map');
        id = values[id].split(/[\s\.]+/g);
        for (var i = 0; i < id.length; i++)
          id[i] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
        for (var i = 0; i < id.length; i++)
          id[i] |= 0;
      }
      if (!Array.isArray(id)) {
        return this.reporter.error('objid() should be either array or string, ' + 'got: ' + JSON.stringify(id));
      }
      if (!relative) {
        if (id[1] >= 40)
          return this.reporter.error('Second objid identifier OOB');
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      var size = 0;
      for (var i = 0; i < id.length; i++) {
        var ident = id[i];
        for (size++; ident >= 0x80; ident >>= 7)
          size++;
      }
      var objid = new Buffer(size);
      var offset = objid.length - 1;
      for (var i = id.length - 1; i >= 0; i--) {
        var ident = id[i];
        objid[offset--] = ident & 0x7f;
        while ((ident >>= 7) > 0)
          objid[offset--] = 0x80 | (ident & 0x7f);
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10)
        return '0' + num;
      else
        return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      var str;
      var date = new Date(time);
      if (tag === 'gentime') {
        str = [two(date.getFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
      } else if (tag === 'utctime') {
        str = [two(date.getFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
      } else {
        this.reporter.error('Encoding ' + tag + ' time is not supported yet');
      }
      return this._encodeStr(str, 'octstr');
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer('');
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === 'string') {
        if (!values)
          return this.reporter.error('String int or enum given, but no values map');
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error('Values map doesn\'t contain: ' + JSON.stringify(num));
        }
        num = values[num];
      }
      if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
        var numArray = num.toArray();
        if (!num.sign && numArray[0] & 0x80) {
          numArray.unshift(0);
        }
        num = new Buffer(numArray);
      }
      if (Buffer.isBuffer(num)) {
        var size = num.length;
        if (num.length === 0)
          size++;
        var out = new Buffer(size);
        num.copy(out);
        if (num.length === 0)
          out[0] = 0;
        return this._createEncoderBuffer(out);
      }
      if (num < 0x80)
        return this._createEncoderBuffer(num);
      if (num < 0x100)
        return this._createEncoderBuffer([0, num]);
      var size = 1;
      for (var i = num; i >= 0x100; i >>= 8)
        size++;
      var out = new Array(size);
      for (var i = out.length - 1; i >= 0; i--) {
        out[i] = num & 0xff;
        num >>= 8;
      }
      if (out[0] & 0x80) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(new Buffer(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 0xff : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === 'function')
        entity = entity(obj);
      return entity._getEncoder('der').tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      var state = this._baseState;
      var i;
      if (state['default'] === null)
        return false;
      var data = dataBuffer.join();
      if (state.defaultBuffer === undefined)
        state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();
      if (data.length !== state.defaultBuffer.length)
        return false;
      for (i = 0; i < data.length; i++)
        if (data[i] !== state.defaultBuffer[i])
          return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
      var res;
      if (tag === 'seqof')
        tag = 'seq';
      else if (tag === 'setof')
        tag = 'set';
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === 'number' && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error('Unknown tag: ' + tag);
      if (res >= 0x1f)
        return reporter.error('Multi-octet tag encoding unsupported');
      if (!primitive)
        res |= 0x20;
      res |= (der.tagClassByName[cls || 'universal'] << 6);
      return res;
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1db", ["ad", "1da"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var inherits = $__require('ad');
  var DEREncoder = $__require('1da');
  function PEMEncoder(entity) {
    DEREncoder.call(this, entity);
    this.enc = 'pem';
  }
  ;
  inherits(PEMEncoder, DEREncoder);
  module.exports = PEMEncoder;
  PEMEncoder.prototype.encode = function encode(data, options) {
    var buf = DEREncoder.prototype.encode.call(this, data);
    var p = buf.toString('base64');
    var out = ['-----BEGIN ' + options.label + '-----'];
    for (var i = 0; i < p.length; i += 64)
      out.push(p.slice(i, i + 64));
    out.push('-----END ' + options.label + '-----');
    return out.join('\n');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1dc", ["1da", "1db"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var encoders = exports;
  encoders.der = $__require('1da');
  encoders.pem = $__require('1db');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1cf", ["197", "1ce", "1d2", "1d6", "1d9", "1dc"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var asn1 = exports;
  asn1.bignum = $__require('197');
  asn1.define = $__require('1ce').define;
  asn1.base = $__require('1d2');
  asn1.constants = $__require('1d6');
  asn1.decoders = $__require('1d9');
  asn1.encoders = $__require('1dc');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1dd", ["1cf"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1cf');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1de", ["1dd"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var asn1 = $__require('1dd');
  var RSAPrivateKey = asn1.define('RSAPrivateKey', function() {
    this.seq().obj(this.key('version').int(), this.key('modulus').int(), this.key('publicExponent').int(), this.key('privateExponent').int(), this.key('prime1').int(), this.key('prime2').int(), this.key('exponent1').int(), this.key('exponent2').int(), this.key('coefficient').int());
  });
  exports.RSAPrivateKey = RSAPrivateKey;
  var RSAPublicKey = asn1.define('RSAPublicKey', function() {
    this.seq().obj(this.key('modulus').int(), this.key('publicExponent').int());
  });
  exports.RSAPublicKey = RSAPublicKey;
  var PublicKey = asn1.define('SubjectPublicKeyInfo', function() {
    this.seq().obj(this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPublicKey').bitstr());
  });
  exports.PublicKey = PublicKey;
  var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function() {
    this.seq().obj(this.key('algorithm').objid(), this.key('none').null_().optional(), this.key('curve').objid().optional(), this.key('params').seq().obj(this.key('p').int(), this.key('q').int(), this.key('g').int()).optional());
  });
  var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function() {
    this.seq().obj(this.key('version').int(), this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPrivateKey').octstr());
  });
  exports.PrivateKey = PrivateKeyInfo;
  var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function() {
    this.seq().obj(this.key('algorithm').seq().obj(this.key('id').objid(), this.key('decrypt').seq().obj(this.key('kde').seq().obj(this.key('id').objid(), this.key('kdeparams').seq().obj(this.key('salt').octstr(), this.key('iters').int())), this.key('cipher').seq().obj(this.key('algo').objid(), this.key('iv').octstr()))), this.key('subjectPrivateKey').octstr());
  });
  exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
  var DSAPrivateKey = asn1.define('DSAPrivateKey', function() {
    this.seq().obj(this.key('version').int(), this.key('p').int(), this.key('q').int(), this.key('g').int(), this.key('pub_key').int(), this.key('priv_key').int());
  });
  exports.DSAPrivateKey = DSAPrivateKey;
  exports.DSAparam = asn1.define('DSAparam', function() {
    this.int();
  });
  var ECPrivateKey = asn1.define('ECPrivateKey', function() {
    this.seq().obj(this.key('version').int(), this.key('privateKey').octstr(), this.key('parameters').optional().explicit(0).use(ECParameters), this.key('publicKey').optional().explicit(1).bitstr());
  });
  exports.ECPrivateKey = ECPrivateKey;
  var ECParameters = asn1.define('ECParameters', function() {
    this.choice({namedCurve: this.objid()});
  });
  exports.signature = asn1.define('signature', function() {
    this.seq().obj(this.key('r').int(), this.key('s').int());
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1df", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e0", ["190", "1e1", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m;
    var startRegex = /^-----BEGIN (.*) KEY-----\r?\n/m;
    var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m;
    var evp = $__require('190');
    var ciphers = $__require('1e1');
    module.exports = function(okey, password) {
      var key = okey.toString();
      var match = key.match(findProc);
      var decrypted;
      if (!match) {
        var match2 = key.match(fullRegex);
        decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64');
      } else {
        var suite = 'aes' + match[1];
        var iv = new Buffer(match[2], 'hex');
        var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64');
        var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
        var out = [];
        var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer.concat(out);
      }
      var tag = key.match(startRegex)[1] + ' KEY';
      return {
        tag: tag,
        data: decrypted
      };
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e2", ["1e3", "18c", "ad", "192", "190", "1e4", "1e5", "1e6", "1e7", "1e8", "1e9", "1ea", "1eb", "1ec", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var aes = $__require('1e3');
    var Transform = $__require('18c');
    var inherits = $__require('ad');
    var modes = $__require('192');
    var ebtk = $__require('190');
    var StreamCipher = $__require('1e4');
    var AuthCipher = $__require('1e5');
    inherits(Cipher, Transform);
    function Cipher(mode, key, iv) {
      if (!(this instanceof Cipher)) {
        return new Cipher(mode, key, iv);
      }
      Transform.call(this);
      this._cache = new Splitter();
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      iv.copy(this._prev);
      this._mode = mode;
      this._autopadding = true;
    }
    Cipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while ((chunk = this._cache.get())) {
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
      }
      return Buffer.concat(out);
    };
    Cipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
      } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
        this._cipher.scrub();
        throw new Error('data not multiple of block length');
      }
    };
    Cipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      if (!(this instanceof Splitter)) {
        return new Splitter();
      }
      this.cache = new Buffer('');
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer.concat([this.cache, data]);
    };
    Splitter.prototype.get = function() {
      if (this.cache.length > 15) {
        var out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      var len = 16 - this.cache.length;
      var padBuff = new Buffer(len);
      var i = -1;
      while (++i < len) {
        padBuff.writeUInt8(len, i);
      }
      var out = Buffer.concat([this.cache, padBuff]);
      return out;
    };
    var modelist = {
      ECB: $__require('1e6'),
      CBC: $__require('1e7'),
      CFB: $__require('1e8'),
      CFB8: $__require('1e9'),
      CFB1: $__require('1ea'),
      OFB: $__require('1eb'),
      CTR: $__require('1ec'),
      GCM: $__require('1ec')
    };
    function createCipheriv(suite, password, iv) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      if (typeof iv === 'string') {
        iv = new Buffer(iv);
      }
      if (typeof password === 'string') {
        password = new Buffer(password);
      }
      if (password.length !== config.key / 8) {
        throw new TypeError('invalid key length ' + password.length);
      }
      if (iv.length !== config.iv) {
        throw new TypeError('invalid iv length ' + iv.length);
      }
      if (config.type === 'stream') {
        return new StreamCipher(modelist[config.mode], password, iv);
      } else if (config.type === 'auth') {
        return new AuthCipher(modelist[config.mode], password, iv);
      }
      return new Cipher(modelist[config.mode], password, iv);
    }
    function createCipher(suite, password) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      var keys = ebtk(password, false, config.key, config.iv);
      return createCipheriv(suite, keys.key, keys.iv);
    }
    exports.createCipheriv = createCipheriv;
    exports.createCipher = createCipher;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e4", ["1e3", "18c", "ad", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var aes = $__require('1e3');
    var Transform = $__require('18c');
    var inherits = $__require('ad');
    inherits(StreamCipher, Transform);
    module.exports = StreamCipher;
    function StreamCipher(mode, key, iv, decrypt) {
      if (!(this instanceof StreamCipher)) {
        return new StreamCipher(mode, key, iv);
      }
      Transform.call(this);
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      this._cache = new Buffer('');
      this._secCache = new Buffer('');
      this._decrypt = decrypt;
      iv.copy(this._prev);
      this._mode = mode;
    }
    StreamCipher.prototype._update = function(chunk) {
      return this._mode.encrypt(this, chunk, this._decrypt);
    };
    StreamCipher.prototype._final = function() {
      this._cipher.scrub();
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e3", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var uint_max = Math.pow(2, 32);
    function fixup_uint32(x) {
      var ret,
          x_pos;
      ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
      return ret;
    }
    function scrub_vec(v) {
      for (var i = 0; i < v.length; v++) {
        v[i] = 0;
      }
      return false;
    }
    function Global() {
      this.SBOX = [];
      this.INV_SBOX = [];
      this.SUB_MIX = [[], [], [], []];
      this.INV_SUB_MIX = [[], [], [], []];
      this.init();
      this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    }
    Global.prototype.init = function() {
      var d,
          i,
          sx,
          t,
          x,
          x2,
          x4,
          x8,
          xi,
          _i;
      d = (function() {
        var _i,
            _results;
        _results = [];
        for (i = _i = 0; _i < 256; i = ++_i) {
          if (i < 128) {
            _results.push(i << 1);
          } else {
            _results.push((i << 1) ^ 0x11b);
          }
        }
        return _results;
      })();
      x = 0;
      xi = 0;
      for (i = _i = 0; _i < 256; i = ++_i) {
        sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
        this.SBOX[x] = sx;
        this.INV_SBOX[sx] = x;
        x2 = d[x];
        x4 = d[x2];
        x8 = d[x4];
        t = (d[sx] * 0x101) ^ (sx * 0x1010100);
        this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);
        this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);
        this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);
        this.SUB_MIX[3][x] = t;
        t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
        this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
        this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
        this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
        this.INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
      return true;
    };
    var G = new Global();
    AES.blockSize = 4 * 4;
    AES.prototype.blockSize = AES.blockSize;
    AES.keySize = 256 / 8;
    AES.prototype.keySize = AES.keySize;
    function bufferToArray(buf) {
      var len = buf.length / 4;
      var out = new Array(len);
      var i = -1;
      while (++i < len) {
        out[i] = buf.readUInt32BE(i * 4);
      }
      return out;
    }
    function AES(key) {
      this._key = bufferToArray(key);
      this._doReset();
    }
    AES.prototype._doReset = function() {
      var invKsRow,
          keySize,
          keyWords,
          ksRow,
          ksRows,
          t;
      keyWords = this._key;
      keySize = keyWords.length;
      this._nRounds = keySize + 6;
      ksRows = (this._nRounds + 1) * 4;
      this._keySchedule = [];
      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);
      }
      this._invKeySchedule = [];
      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
        this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]];
      }
      return true;
    };
    AES.prototype.encryptBlock = function(M) {
      M = bufferToArray(new Buffer(M));
      var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX);
      var buf = new Buffer(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[1], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[3], 12);
      return buf;
    };
    AES.prototype.decryptBlock = function(M) {
      M = bufferToArray(new Buffer(M));
      var temp = [M[3], M[1]];
      M[1] = temp[0];
      M[3] = temp[1];
      var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);
      var buf = new Buffer(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[3], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[1], 12);
      return buf;
    };
    AES.prototype.scrub = function() {
      scrub_vec(this._keySchedule);
      scrub_vec(this._invKeySchedule);
      scrub_vec(this._key);
    };
    AES.prototype._doCryptBlock = function(M, keySchedule, SUB_MIX, SBOX) {
      var ksRow,
          s0,
          s1,
          s2,
          s3,
          t0,
          t1,
          t2,
          t3;
      s0 = M[0] ^ keySchedule[0];
      s1 = M[1] ^ keySchedule[1];
      s2 = M[2] ^ keySchedule[2];
      s3 = M[3] ^ keySchedule[3];
      ksRow = 4;
      for (var round = 1; round < this._nRounds; round++) {
        t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];
        t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];
        t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];
        t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
      }
      t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
      t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
      t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
      t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
      return [fixup_uint32(t0), fixup_uint32(t1), fixup_uint32(t2), fixup_uint32(t3)];
    };
    exports.AES = AES;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ed", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var zeros = new Buffer(16);
    zeros.fill(0);
    module.exports = GHASH;
    function GHASH(key) {
      this.h = key;
      this.state = new Buffer(16);
      this.state.fill(0);
      this.cache = new Buffer('');
    }
    GHASH.prototype.ghash = function(block) {
      var i = -1;
      while (++i < block.length) {
        this.state[i] ^= block[i];
      }
      this._multiply();
    };
    GHASH.prototype._multiply = function() {
      var Vi = toArray(this.h);
      var Zi = [0, 0, 0, 0];
      var j,
          xi,
          lsb_Vi;
      var i = -1;
      while (++i < 128) {
        xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0;
        if (xi) {
          Zi = xor(Zi, Vi);
        }
        lsb_Vi = (Vi[3] & 1) !== 0;
        for (j = 3; j > 0; j--) {
          Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31);
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsb_Vi) {
          Vi[0] = Vi[0] ^ (0xe1 << 24);
        }
      }
      this.state = fromArray(Zi);
    };
    GHASH.prototype.update = function(buf) {
      this.cache = Buffer.concat([this.cache, buf]);
      var chunk;
      while (this.cache.length >= 16) {
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
      }
    };
    GHASH.prototype.final = function(abl, bl) {
      if (this.cache.length) {
        this.ghash(Buffer.concat([this.cache, zeros], 16));
      }
      this.ghash(fromArray([0, abl, 0, bl]));
      return this.state;
    };
    function toArray(buf) {
      return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];
    }
    function fromArray(out) {
      out = out.map(fixup_uint32);
      var buf = new Buffer(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[1], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[3], 12);
      return buf;
    }
    var uint_max = Math.pow(2, 32);
    function fixup_uint32(x) {
      var ret,
          x_pos;
      ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
      return ret;
    }
    function xor(a, b) {
      return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]];
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e5", ["1e3", "18c", "ad", "1ed", "1ee", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var aes = $__require('1e3');
    var Transform = $__require('18c');
    var inherits = $__require('ad');
    var GHASH = $__require('1ed');
    var xor = $__require('1ee');
    inherits(StreamCipher, Transform);
    module.exports = StreamCipher;
    function StreamCipher(mode, key, iv, decrypt) {
      if (!(this instanceof StreamCipher)) {
        return new StreamCipher(mode, key, iv);
      }
      Transform.call(this);
      this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])]);
      iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])]);
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      this._cache = new Buffer('');
      this._secCache = new Buffer('');
      this._decrypt = decrypt;
      this._alen = 0;
      this._len = 0;
      iv.copy(this._prev);
      this._mode = mode;
      var h = new Buffer(4);
      h.fill(0);
      this._ghash = new GHASH(this._cipher.encryptBlock(h));
      this._authTag = null;
      this._called = false;
    }
    StreamCipher.prototype._update = function(chunk) {
      if (!this._called && this._alen) {
        var rump = 16 - (this._alen % 16);
        if (rump < 16) {
          rump = new Buffer(rump);
          rump.fill(0);
          this._ghash.update(rump);
        }
      }
      this._called = true;
      var out = this._mode.encrypt(this, chunk);
      if (this._decrypt) {
        this._ghash.update(chunk);
      } else {
        this._ghash.update(out);
      }
      this._len += chunk.length;
      return out;
    };
    StreamCipher.prototype._final = function() {
      if (this._decrypt && !this._authTag) {
        throw new Error('Unsupported state or unable to authenticate data');
      }
      var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt) {
        if (xorTest(tag, this._authTag)) {
          throw new Error('Unsupported state or unable to authenticate data');
        }
      } else {
        this._authTag = tag;
      }
      this._cipher.scrub();
    };
    StreamCipher.prototype.getAuthTag = function getAuthTag() {
      if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
        return this._authTag;
      } else {
        throw new Error('Attempting to get auth tag in unsupported state');
      }
    };
    StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
      if (this._decrypt) {
        this._authTag = tag;
      } else {
        throw new Error('Attempting to set auth tag in unsupported state');
      }
    };
    StreamCipher.prototype.setAAD = function setAAD(buf) {
      if (!this._called) {
        this._ghash.update(buf);
        this._alen += buf.length;
      } else {
        throw new Error('Attempting to set AAD in unsupported state');
      }
    };
    function xorTest(a, b) {
      var out = 0;
      if (a.length !== b.length) {
        out++;
      }
      var len = Math.min(a.length, b.length);
      var i = -1;
      while (++i < len) {
        out += (a[i] ^ b[i]);
      }
      return out;
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ef", ["1f0", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var md5 = $__require('1f0');
    module.exports = EVP_BytesToKey;
    function EVP_BytesToKey(password, salt, keyLen, ivLen) {
      if (!Buffer.isBuffer(password)) {
        password = new Buffer(password, 'binary');
      }
      if (salt && !Buffer.isBuffer(salt)) {
        salt = new Buffer(salt, 'binary');
      }
      keyLen = keyLen / 8;
      ivLen = ivLen || 0;
      var ki = 0;
      var ii = 0;
      var key = new Buffer(keyLen);
      var iv = new Buffer(ivLen);
      var addmd = 0;
      var md_buf;
      var i;
      var bufs = [];
      while (true) {
        if (addmd++ > 0) {
          bufs.push(md_buf);
        }
        bufs.push(password);
        if (salt) {
          bufs.push(salt);
        }
        md_buf = md5(Buffer.concat(bufs));
        bufs = [];
        i = 0;
        if (keyLen > 0) {
          while (true) {
            if (keyLen === 0) {
              break;
            }
            if (i === md_buf.length) {
              break;
            }
            key[ki++] = md_buf[i];
            keyLen--;
            i++;
          }
        }
        if (ivLen > 0 && i !== md_buf.length) {
          while (true) {
            if (ivLen === 0) {
              break;
            }
            if (i === md_buf.length) {
              break;
            }
            iv[ii++] = md_buf[i];
            ivLen--;
            i++;
          }
        }
        if (keyLen === 0 && ivLen === 0) {
          break;
        }
      }
      for (i = 0; i < md_buf.length; i++) {
        md_buf[i] = 0;
      }
      return {
        key: key,
        iv: iv
      };
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("190", ["1ef"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1ef');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e6", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.encrypt = function(self, block) {
    return self._cipher.encryptBlock(block);
  };
  exports.decrypt = function(self, block) {
    return self._cipher.decryptBlock(block);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e7", ["1ee"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var xor = $__require('1ee');
  exports.encrypt = function(self, block) {
    var data = xor(block, self._prev);
    self._prev = self._cipher.encryptBlock(data);
    return self._prev;
  };
  exports.decrypt = function(self, block) {
    var pad = self._prev;
    self._prev = block;
    var out = self._cipher.decryptBlock(block);
    return xor(out, pad);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e8", ["1ee", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var xor = $__require('1ee');
    exports.encrypt = function(self, data, decrypt) {
      var out = new Buffer('');
      var len;
      while (data.length) {
        if (self._cache.length === 0) {
          self._cache = self._cipher.encryptBlock(self._prev);
          self._prev = new Buffer('');
        }
        if (self._cache.length <= data.length) {
          len = self._cache.length;
          out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
          data = data.slice(len);
        } else {
          out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
          break;
        }
      }
      return out;
    };
    function encryptStart(self, data, decrypt) {
      var len = data.length;
      var out = xor(data, self._cache);
      self._cache = self._cache.slice(len);
      self._prev = Buffer.concat([self._prev, decrypt ? data : out]);
      return out;
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e9", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    function encryptByte(self, byteParam, decrypt) {
      var pad = self._cipher.encryptBlock(self._prev);
      var out = pad[0] ^ byteParam;
      self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])]);
      return out;
    }
    exports.encrypt = function(self, chunk, decrypt) {
      var len = chunk.length;
      var out = new Buffer(len);
      var i = -1;
      while (++i < len) {
        out[i] = encryptByte(self, chunk[i], decrypt);
      }
      return out;
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ea", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    function encryptByte(self, byteParam, decrypt) {
      var pad;
      var i = -1;
      var len = 8;
      var out = 0;
      var bit,
          value;
      while (++i < len) {
        pad = self._cipher.encryptBlock(self._prev);
        bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0;
        value = pad[0] ^ bit;
        out += ((value & 0x80) >> (i % 8));
        self._prev = shiftIn(self._prev, decrypt ? bit : value);
      }
      return out;
    }
    exports.encrypt = function(self, chunk, decrypt) {
      var len = chunk.length;
      var out = new Buffer(len);
      var i = -1;
      while (++i < len) {
        out[i] = encryptByte(self, chunk[i], decrypt);
      }
      return out;
    };
    function shiftIn(buffer, value) {
      var len = buffer.length;
      var i = -1;
      var out = new Buffer(buffer.length);
      buffer = Buffer.concat([buffer, new Buffer([value])]);
      while (++i < len) {
        out[i] = buffer[i] << 1 | buffer[i + 1] >> (7);
      }
      return out;
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1eb", ["1ee", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var xor = $__require('1ee');
    function getBlock(self) {
      self._prev = self._cipher.encryptBlock(self._prev);
      return self._prev;
    }
    exports.encrypt = function(self, chunk) {
      while (self._cache.length < chunk.length) {
        self._cache = Buffer.concat([self._cache, getBlock(self)]);
      }
      var pad = self._cache.slice(0, chunk.length);
      self._cache = self._cache.slice(chunk.length);
      return xor(chunk, pad);
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f1", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    module.exports = function xor(a, b) {
      var length = Math.min(a.length, b.length);
      var buffer = new Buffer(length);
      for (var i = 0; i < length; ++i) {
        buffer[i] = a[i] ^ b[i];
      }
      return buffer;
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ee", ["1f1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1f1');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ec", ["1ee", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var xor = $__require('1ee');
    function incr32(iv) {
      var len = iv.length;
      var item;
      while (len--) {
        item = iv.readUInt8(len);
        if (item === 255) {
          iv.writeUInt8(0, len);
        } else {
          item++;
          iv.writeUInt8(item, len);
          break;
        }
      }
    }
    function getBlock(self) {
      var out = self._cipher.encryptBlock(self._prev);
      incr32(self._prev);
      return out;
    }
    exports.encrypt = function(self, chunk) {
      while (self._cache.length < chunk.length) {
        self._cache = Buffer.concat([self._cache, getBlock(self)]);
      }
      var pad = self._cache.slice(0, chunk.length);
      self._cache = self._cache.slice(chunk.length);
      return xor(chunk, pad);
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f2", ["1e3", "18c", "ad", "192", "1e4", "1e5", "190", "1e6", "1e7", "1e8", "1e9", "1ea", "1eb", "1ec", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var aes = $__require('1e3');
    var Transform = $__require('18c');
    var inherits = $__require('ad');
    var modes = $__require('192');
    var StreamCipher = $__require('1e4');
    var AuthCipher = $__require('1e5');
    var ebtk = $__require('190');
    inherits(Decipher, Transform);
    function Decipher(mode, key, iv) {
      if (!(this instanceof Decipher)) {
        return new Decipher(mode, key, iv);
      }
      Transform.call(this);
      this._cache = new Splitter();
      this._last = void 0;
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      iv.copy(this._prev);
      this._mode = mode;
      this._autopadding = true;
    }
    Decipher.prototype._update = function(data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while ((chunk = this._cache.get(this._autopadding))) {
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
      }
      return Buffer.concat(out);
    };
    Decipher.prototype._final = function() {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
      } else if (chunk) {
        throw new Error('data not multiple of block length');
      }
    };
    Decipher.prototype.setAutoPadding = function(setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      if (!(this instanceof Splitter)) {
        return new Splitter();
      }
      this.cache = new Buffer('');
    }
    Splitter.prototype.add = function(data) {
      this.cache = Buffer.concat([this.cache, data]);
    };
    Splitter.prototype.get = function(autoPadding) {
      var out;
      if (autoPadding) {
        if (this.cache.length > 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      } else {
        if (this.cache.length >= 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      }
      return null;
    };
    Splitter.prototype.flush = function() {
      if (this.cache.length) {
        return this.cache;
      }
    };
    function unpad(last) {
      var padded = last[15];
      var i = -1;
      while (++i < padded) {
        if (last[(i + (16 - padded))] !== padded) {
          throw new Error('unable to decrypt data');
        }
      }
      if (padded === 16) {
        return;
      }
      return last.slice(0, 16 - padded);
    }
    var modelist = {
      ECB: $__require('1e6'),
      CBC: $__require('1e7'),
      CFB: $__require('1e8'),
      CFB8: $__require('1e9'),
      CFB1: $__require('1ea'),
      OFB: $__require('1eb'),
      CTR: $__require('1ec'),
      GCM: $__require('1ec')
    };
    function createDecipheriv(suite, password, iv) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      if (typeof iv === 'string') {
        iv = new Buffer(iv);
      }
      if (typeof password === 'string') {
        password = new Buffer(password);
      }
      if (password.length !== config.key / 8) {
        throw new TypeError('invalid key length ' + password.length);
      }
      if (iv.length !== config.iv) {
        throw new TypeError('invalid iv length ' + iv.length);
      }
      if (config.type === 'stream') {
        return new StreamCipher(modelist[config.mode], password, iv, true);
      } else if (config.type === 'auth') {
        return new AuthCipher(modelist[config.mode], password, iv, true);
      }
      return new Decipher(modelist[config.mode], password, iv);
    }
    function createDecipher(suite, password) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      var keys = ebtk(password, false, config.key, config.iv);
      return createDecipheriv(suite, keys.key, keys.iv);
    }
    exports.createDecipher = createDecipher;
    exports.createDecipheriv = createDecipheriv;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("192", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports['aes-128-ecb'] = {
    cipher: 'AES',
    key: 128,
    iv: 0,
    mode: 'ECB',
    type: 'block'
  };
  exports['aes-192-ecb'] = {
    cipher: 'AES',
    key: 192,
    iv: 0,
    mode: 'ECB',
    type: 'block'
  };
  exports['aes-256-ecb'] = {
    cipher: 'AES',
    key: 256,
    iv: 0,
    mode: 'ECB',
    type: 'block'
  };
  exports['aes-128-cbc'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CBC',
    type: 'block'
  };
  exports['aes-192-cbc'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CBC',
    type: 'block'
  };
  exports['aes-256-cbc'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CBC',
    type: 'block'
  };
  exports['aes128'] = exports['aes-128-cbc'];
  exports['aes192'] = exports['aes-192-cbc'];
  exports['aes256'] = exports['aes-256-cbc'];
  exports['aes-128-cfb'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CFB',
    type: 'stream'
  };
  exports['aes-192-cfb'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CFB',
    type: 'stream'
  };
  exports['aes-256-cfb'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CFB',
    type: 'stream'
  };
  exports['aes-128-cfb8'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CFB8',
    type: 'stream'
  };
  exports['aes-192-cfb8'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CFB8',
    type: 'stream'
  };
  exports['aes-256-cfb8'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CFB8',
    type: 'stream'
  };
  exports['aes-128-cfb1'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CFB1',
    type: 'stream'
  };
  exports['aes-192-cfb1'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CFB1',
    type: 'stream'
  };
  exports['aes-256-cfb1'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CFB1',
    type: 'stream'
  };
  exports['aes-128-ofb'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'OFB',
    type: 'stream'
  };
  exports['aes-192-ofb'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'OFB',
    type: 'stream'
  };
  exports['aes-256-ofb'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'OFB',
    type: 'stream'
  };
  exports['aes-128-ctr'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CTR',
    type: 'stream'
  };
  exports['aes-192-ctr'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CTR',
    type: 'stream'
  };
  exports['aes-256-ctr'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CTR',
    type: 'stream'
  };
  exports['aes-128-gcm'] = {
    cipher: 'AES',
    key: 128,
    iv: 12,
    mode: 'GCM',
    type: 'auth'
  };
  exports['aes-192-gcm'] = {
    cipher: 'AES',
    key: 192,
    iv: 12,
    mode: 'GCM',
    type: 'auth'
  };
  exports['aes-256-gcm'] = {
    cipher: 'AES',
    key: 256,
    iv: 12,
    mode: 'GCM',
    type: 'auth'
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("191", ["1e2", "1f2", "192"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ciphers = $__require('1e2');
  exports.createCipher = exports.Cipher = ciphers.createCipher;
  exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
  var deciphers = $__require('1f2');
  exports.createDecipher = exports.Decipher = deciphers.createDecipher;
  exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
  var modes = $__require('192');
  function getCiphers() {
    return Object.keys(modes);
  }
  exports.listCiphers = exports.getCiphers = getCiphers;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e1", ["191"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('191');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f3", ["1f4", "ad", "58", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var createHash = $__require('1f4');
    var inherits = $__require('ad');
    var Transform = $__require('58').Transform;
    var ZEROS = new Buffer(128);
    ZEROS.fill(0);
    function Hmac(alg, key) {
      Transform.call(this);
      alg = alg.toLowerCase();
      if (typeof key === 'string') {
        key = new Buffer(key);
      }
      var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64;
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        key = createHash(alg).update(key).digest();
      } else if (key.length < blocksize) {
        key = Buffer.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = new Buffer(blocksize);
      var opad = this._opad = new Buffer(blocksize);
      for (var i = 0; i < blocksize; i++) {
        ipad[i] = key[i] ^ 0x36;
        opad[i] = key[i] ^ 0x5C;
      }
      this._hash = createHash(alg).update(ipad);
    }
    inherits(Hmac, Transform);
    Hmac.prototype.update = function(data, enc) {
      this._hash.update(data, enc);
      return this;
    };
    Hmac.prototype._transform = function(data, _, next) {
      this._hash.update(data);
      next();
    };
    Hmac.prototype._flush = function(next) {
      this.push(this.digest());
      next();
    };
    Hmac.prototype.digest = function(enc) {
      var h = this._hash.digest();
      return createHash(this._alg).update(this._opad).update(h).digest(enc);
    };
    module.exports = function createHmac(alg, key) {
      return new Hmac(alg, key);
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a1", ["1f3"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1f3');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f5", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var MAX_ALLOC = Math.pow(2, 30) - 1;
  module.exports = function(iterations, keylen) {
    if (typeof iterations !== 'number') {
      throw new TypeError('Iterations not a number');
    }
    if (iterations < 0) {
      throw new TypeError('Bad iterations');
    }
    if (typeof keylen !== 'number') {
      throw new TypeError('Key length not a number');
    }
    if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
      throw new TypeError('Bad key length');
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f6", ["1a1", "1f5", "72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var createHmac = $__require('1a1');
    var checkParameters = $__require('1f5');
    exports.pbkdf2 = function(password, salt, iterations, keylen, digest, callback) {
      if (typeof digest === 'function') {
        callback = digest;
        digest = undefined;
      }
      checkParameters(iterations, keylen);
      if (typeof callback !== 'function')
        throw new Error('No callback provided to pbkdf2');
      setTimeout(function() {
        callback(null, exports.pbkdf2Sync(password, salt, iterations, keylen, digest));
      });
    };
    var defaultEncoding;
    if (process.browser) {
      defaultEncoding = 'utf-8';
    } else {
      var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);
      defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
    }
    exports.pbkdf2Sync = function(password, salt, iterations, keylen, digest) {
      if (!Buffer.isBuffer(password))
        password = new Buffer(password, defaultEncoding);
      if (!Buffer.isBuffer(salt))
        salt = new Buffer(salt, defaultEncoding);
      checkParameters(iterations, keylen);
      digest = digest || 'sha1';
      var hLen;
      var l = 1;
      var DK = new Buffer(keylen);
      var block1 = new Buffer(salt.length + 4);
      salt.copy(block1, 0, 0, salt.length);
      var r;
      var T;
      for (var i = 1; i <= l; i++) {
        block1.writeUInt32BE(i, salt.length);
        var U = createHmac(digest, password).update(block1).digest();
        if (!hLen) {
          hLen = U.length;
          T = new Buffer(hLen);
          l = Math.ceil(keylen / hLen);
          r = keylen - (l - 1) * hLen;
        }
        U.copy(T, 0, 0, hLen);
        for (var j = 1; j < iterations; j++) {
          U = createHmac(digest, password).update(U).digest();
          for (var k = 0; k < hLen; k++)
            T[k] ^= U[k];
        }
        var destPos = (i - 1) * hLen;
        var len = (i === l ? r : hLen);
        T.copy(DK, destPos, 0, len);
      }
      return DK;
    };
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f7", ["1f6"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1f6');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f8", ["1de", "1df", "1e0", "1e1", "1f7", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var asn1 = $__require('1de');
    var aesid = $__require('1df');
    var fixProc = $__require('1e0');
    var ciphers = $__require('1e1');
    var compat = $__require('1f7');
    module.exports = parseKeys;
    function parseKeys(buffer) {
      var password;
      if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
        password = buffer.passphrase;
        buffer = buffer.key;
      }
      if (typeof buffer === 'string') {
        buffer = new Buffer(buffer);
      }
      var stripped = fixProc(buffer, password);
      var type = stripped.tag;
      var data = stripped.data;
      var subtype,
          ndata;
      switch (type) {
        case 'PUBLIC KEY':
          ndata = asn1.PublicKey.decode(data, 'der');
          subtype = ndata.algorithm.algorithm.join('.');
          switch (subtype) {
            case '1.2.840.113549.1.1.1':
              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
            case '1.2.840.10045.2.1':
              ndata.subjectPrivateKey = ndata.subjectPublicKey;
              return {
                type: 'ec',
                data: ndata
              };
            case '1.2.840.10040.4.1':
              ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
              return {
                type: 'dsa',
                data: ndata.algorithm.params
              };
            default:
              throw new Error('unknown key id ' + subtype);
          }
          throw new Error('unknown key type ' + type);
        case 'ENCRYPTED PRIVATE KEY':
          data = asn1.EncryptedPrivateKey.decode(data, 'der');
          data = decrypt(data, password);
        case 'PRIVATE KEY':
          ndata = asn1.PrivateKey.decode(data, 'der');
          subtype = ndata.algorithm.algorithm.join('.');
          switch (subtype) {
            case '1.2.840.113549.1.1.1':
              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
            case '1.2.840.10045.2.1':
              return {
                curve: ndata.algorithm.curve,
                privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
              };
            case '1.2.840.10040.4.1':
              ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
              return {
                type: 'dsa',
                params: ndata.algorithm.params
              };
            default:
              throw new Error('unknown key id ' + subtype);
          }
          throw new Error('unknown key type ' + type);
        case 'RSA PUBLIC KEY':
          return asn1.RSAPublicKey.decode(data, 'der');
        case 'RSA PRIVATE KEY':
          return asn1.RSAPrivateKey.decode(data, 'der');
        case 'DSA PRIVATE KEY':
          return {
            type: 'dsa',
            params: asn1.DSAPrivateKey.decode(data, 'der')
          };
        case 'EC PRIVATE KEY':
          data = asn1.ECPrivateKey.decode(data, 'der');
          return {
            curve: data.parameters.value,
            privateKey: data.privateKey
          };
        default:
          throw new Error('unknown key type ' + type);
      }
    }
    parseKeys.signature = asn1.signature;
    function decrypt(data, password) {
      var salt = data.algorithm.decrypt.kde.kdeparams.salt;
      var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
      var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
      var iv = data.algorithm.decrypt.cipher.iv;
      var cipherText = data.subjectPrivateKey;
      var keylen = parseInt(algo.split('-')[1], 10) / 8;
      var key = compat.pbkdf2Sync(password, salt, iters, keylen);
      var cipher = ciphers.createDecipheriv(algo, key, iv);
      var out = [];
      out.push(cipher.update(cipherText));
      out.push(cipher.final());
      return Buffer.concat(out);
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a4", ["1f8"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1f8');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c5", ["1a7", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var createHash = $__require('1a7');
    module.exports = function(seed, len) {
      var t = new Buffer('');
      var i = 0,
          c;
      while (t.length < len) {
        c = i2ops(i++);
        t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
      }
      return t.slice(0, len);
    };
    function i2ops(c) {
      var out = new Buffer(4);
      out.writeUInt32BE(c, 0);
      return out;
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c6", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function xor(a, b) {
    var len = a.length;
    var i = -1;
    while (++i < len) {
      a[i] ^= b[i];
    }
    return a;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f9", ["72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    'use strict';
    function oldBrowser() {
      throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11');
    }
    var crypto = global.crypto || global.msCrypto;
    if (crypto && crypto.getRandomValues) {
      module.exports = randomBytes;
    } else {
      module.exports = oldBrowser;
    }
    function randomBytes(size, cb) {
      if (size > 65536)
        throw new Error('requested too many random bytes');
      var rawBytes = new global.Uint8Array(size);
      if (size > 0) {
        crypto.getRandomValues(rawBytes);
      }
      var bytes = new Buffer(rawBytes.buffer);
      if (typeof cb === 'function') {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("19a", ["1f9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1f9');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1fa", ["197", "19a", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var bn = $__require('197');
    var randomBytes = $__require('19a');
    module.exports = crt;
    function blind(priv) {
      var r = getr(priv);
      var blinder = r.toRed(bn.mont(priv.modulus)).redPow(new bn(priv.publicExponent)).fromRed();
      return {
        blinder: blinder,
        unblinder: r.invm(priv.modulus)
      };
    }
    function crt(msg, priv) {
      var blinds = blind(priv);
      var len = priv.modulus.byteLength();
      var mod = bn.mont(priv.modulus);
      var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
      var c1 = blinded.toRed(bn.mont(priv.prime1));
      var c2 = blinded.toRed(bn.mont(priv.prime2));
      var qinv = priv.coefficient;
      var p = priv.prime1;
      var q = priv.prime2;
      var m1 = c1.redPow(priv.exponent1);
      var m2 = c2.redPow(priv.exponent2);
      m1 = m1.fromRed();
      m2 = m2.fromRed();
      var h = m1.isub(m2).imul(qinv).umod(p);
      h.imul(q);
      m2.iadd(h);
      return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
    }
    crt.getr = getr;
    function getr(priv) {
      var len = priv.modulus.byteLength();
      var r = new bn(randomBytes(len));
      while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
        r = new bn(randomBytes(len));
      }
      return r;
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a2", ["1fa"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1fa');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1fb", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var intSize = 4;
    var zeroBuffer = new Buffer(intSize);
    zeroBuffer.fill(0);
    var chrsz = 8;
    function toArray(buf, bigEndian) {
      if ((buf.length % intSize) !== 0) {
        var len = buf.length + (intSize - (buf.length % intSize));
        buf = Buffer.concat([buf, zeroBuffer], len);
      }
      var arr = [];
      var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
      for (var i = 0; i < buf.length; i += intSize) {
        arr.push(fn.call(buf, i));
      }
      return arr;
    }
    function toBuffer(arr, size, bigEndian) {
      var buf = new Buffer(size);
      var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
      for (var i = 0; i < arr.length; i++) {
        fn.call(buf, arr[i], i * 4, true);
      }
      return buf;
    }
    function hash(buf, fn, hashSize, bigEndian) {
      if (!Buffer.isBuffer(buf))
        buf = new Buffer(buf);
      var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
      return toBuffer(arr, hashSize, bigEndian);
    }
    exports.hash = hash;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f0", ["1fb"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var helpers = $__require('1fb');
  function core_md5(x, len) {
    x[len >> 5] |= 0x80 << ((len) % 32);
    x[(((len + 64) >>> 9) << 4) + 14] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    for (var i = 0; i < x.length; i += 16) {
      var olda = a;
      var oldb = b;
      var oldc = c;
      var oldd = d;
      a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
      d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
      b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
      a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
      d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
      c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
      d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = safe_add(a, olda);
      b = safe_add(b, oldb);
      c = safe_add(c, oldc);
      d = safe_add(d, oldd);
    }
    return Array(a, b, c, d);
  }
  function md5_cmn(q, a, b, x, s, t) {
    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
  }
  function md5_ff(a, b, c, d, x, s, t) {
    return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
  }
  function md5_gg(a, b, c, d, x, s, t) {
    return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
  }
  function md5_hh(a, b, c, d, x, s, t) {
    return md5_cmn(b ^ c ^ d, a, b, x, s, t);
  }
  function md5_ii(a, b, c, d, x, s, t) {
    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
  }
  function safe_add(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return (msw << 16) | (lsw & 0xFFFF);
  }
  function bit_rol(num, cnt) {
    return (num << cnt) | (num >>> (32 - cnt));
  }
  module.exports = function md5(buf) {
    return helpers.hash(buf, core_md5, 16);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1fc", ["72", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
    var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
    var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
    var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
    var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
    function bytesToWords(bytes) {
      var words = [];
      for (var i = 0,
          b = 0; i < bytes.length; i++, b += 8) {
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      }
      return words;
    }
    function wordsToBytes(words) {
      var bytes = [];
      for (var b = 0; b < words.length * 32; b += 8) {
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      }
      return bytes;
    }
    function processBlock(H, M, offset) {
      for (var i = 0; i < 16; i++) {
        var offset_i = offset + i;
        var M_offset_i = M[offset_i];
        M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));
      }
      var al,
          bl,
          cl,
          dl,
          el;
      var ar,
          br,
          cr,
          dr,
          er;
      ar = al = H[0];
      br = bl = H[1];
      cr = cl = H[2];
      dr = dl = H[3];
      er = el = H[4];
      var t;
      for (i = 0; i < 80; i += 1) {
        t = (al + M[offset + zl[i]]) | 0;
        if (i < 16) {
          t += f1(bl, cl, dl) + hl[0];
        } else if (i < 32) {
          t += f2(bl, cl, dl) + hl[1];
        } else if (i < 48) {
          t += f3(bl, cl, dl) + hl[2];
        } else if (i < 64) {
          t += f4(bl, cl, dl) + hl[3];
        } else {
          t += f5(bl, cl, dl) + hl[4];
        }
        t = t | 0;
        t = rotl(t, sl[i]);
        t = (t + el) | 0;
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = t;
        t = (ar + M[offset + zr[i]]) | 0;
        if (i < 16) {
          t += f5(br, cr, dr) + hr[0];
        } else if (i < 32) {
          t += f4(br, cr, dr) + hr[1];
        } else if (i < 48) {
          t += f3(br, cr, dr) + hr[2];
        } else if (i < 64) {
          t += f2(br, cr, dr) + hr[3];
        } else {
          t += f1(br, cr, dr) + hr[4];
        }
        t = t | 0;
        t = rotl(t, sr[i]);
        t = (t + er) | 0;
        ar = er;
        er = dr;
        dr = rotl(cr, 10);
        cr = br;
        br = t;
      }
      t = (H[1] + cl + dr) | 0;
      H[1] = (H[2] + dl + er) | 0;
      H[2] = (H[3] + el + ar) | 0;
      H[3] = (H[4] + al + br) | 0;
      H[4] = (H[0] + bl + cr) | 0;
      H[0] = t;
    }
    function f1(x, y, z) {
      return ((x) ^ (y) ^ (z));
    }
    function f2(x, y, z) {
      return (((x) & (y)) | ((~x) & (z)));
    }
    function f3(x, y, z) {
      return (((x) | (~(y))) ^ (z));
    }
    function f4(x, y, z) {
      return (((x) & (z)) | ((y) & (~(z))));
    }
    function f5(x, y, z) {
      return ((x) ^ ((y) | (~(z))));
    }
    function rotl(x, n) {
      return (x << n) | (x >>> (32 - n));
    }
    function ripemd160(message) {
      var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
      if (typeof message === 'string') {
        message = new Buffer(message, 'utf8');
      }
      var m = bytesToWords(message);
      var nBitsLeft = message.length * 8;
      var nBitsTotal = message.length * 8;
      m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
      m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) | (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00));
      for (var i = 0; i < m.length; i += 16) {
        processBlock(H, m, i);
      }
      for (i = 0; i < 5; i++) {
        var H_i = H[i];
        H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
      }
      var digestbytes = wordsToBytes(H);
      return new Buffer(digestbytes);
    }
    module.exports = ripemd160;
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1fd", ["1fc"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1fc');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1fe", ["ad", "1ff", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = $__require('ad');
    var Hash = $__require('1ff');
    var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 0x67452301;
      this._b = 0xefcdab89;
      this._c = 0x98badcfe;
      this._d = 0x10325476;
      this._e = 0xc3d2e1f0;
      return this;
    };
    function rotl5(num) {
      return (num << 5) | (num >>> 27);
    }
    function rotl30(num) {
      return (num << 30) | (num >>> 2);
    }
    function ft(s, b, c, d) {
      if (s === 0)
        return (b & c) | ((~b) & d);
      if (s === 2)
        return (b & c) | (b & d) | (c & d);
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var W = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i)
        W[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i)
        W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
    };
    Sha.prototype._hash = function() {
      var H = new Buffer(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("200", ["ad", "1ff", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = $__require('ad');
    var Hash = $__require('1ff');
    var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 0x67452301;
      this._b = 0xefcdab89;
      this._c = 0x98badcfe;
      this._d = 0x10325476;
      this._e = 0xc3d2e1f0;
      return this;
    };
    function rotl1(num) {
      return (num << 1) | (num >>> 31);
    }
    function rotl5(num) {
      return (num << 5) | (num >>> 27);
    }
    function rotl30(num) {
      return (num << 30) | (num >>> 2);
    }
    function ft(s, b, c, d) {
      if (s === 0)
        return (b & c) | ((~b) & d);
      if (s === 2)
        return (b & c) | (b & d) | (c & d);
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var W = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i)
        W[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i)
        W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
    };
    Sha1.prototype._hash = function() {
      var H = new Buffer(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha1;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("201", ["ad", "202", "1ff", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = $__require('ad');
    var Sha256 = $__require('202');
    var Hash = $__require('1ff');
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 0xc1059ed8;
      this._b = 0x367cd507;
      this._c = 0x3070dd17;
      this._d = 0xf70e5939;
      this._e = 0xffc00b31;
      this._f = 0x68581511;
      this._g = 0x64f98fa7;
      this._h = 0xbefa4fa4;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = new Buffer(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module.exports = Sha224;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("202", ["ad", "1ff", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = $__require('ad');
    var Hash = $__require('1ff');
    var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 0x6a09e667;
      this._b = 0xbb67ae85;
      this._c = 0x3c6ef372;
      this._d = 0xa54ff53a;
      this._e = 0x510e527f;
      this._f = 0x9b05688c;
      this._g = 0x1f83d9ab;
      this._h = 0x5be0cd19;
      return this;
    };
    function ch(x, y, z) {
      return z ^ (x & (y ^ z));
    }
    function maj(x, y, z) {
      return (x & y) | (z & (x | y));
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3);
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10);
    }
    Sha256.prototype._update = function(M) {
      var W = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i)
        W[i] = M.readInt32BE(i * 4);
      for (; i < 64; ++i)
        W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;
      for (var j = 0; j < 64; ++j) {
        var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0;
        var T2 = (sigma0(a) + maj(a, b, c)) | 0;
        h = g;
        g = f;
        f = e;
        e = (d + T1) | 0;
        d = c;
        c = b;
        b = a;
        a = (T1 + T2) | 0;
      }
      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
      this._f = (f + this._f) | 0;
      this._g = (g + this._g) | 0;
      this._h = (h + this._h) | 0;
    };
    Sha256.prototype._hash = function() {
      var H = new Buffer(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module.exports = Sha256;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("203", ["ad", "204", "1ff", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = $__require('ad');
    var SHA512 = $__require('204');
    var Hash = $__require('1ff');
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 0xcbbb9d5d;
      this._bh = 0x629a292a;
      this._ch = 0x9159015a;
      this._dh = 0x152fecd8;
      this._eh = 0x67332667;
      this._fh = 0x8eb44a87;
      this._gh = 0xdb0c2e0d;
      this._hh = 0x47b5481d;
      this._al = 0xc1059ed8;
      this._bl = 0x367cd507;
      this._cl = 0x3070dd17;
      this._dl = 0xf70e5939;
      this._el = 0xffc00b31;
      this._fl = 0x68581511;
      this._gl = 0x64f98fa7;
      this._hl = 0xbefa4fa4;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = new Buffer(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module.exports = Sha384;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1ff", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    function Hash(blockSize, finalSize) {
      this._block = new Buffer(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
      this._s = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === 'string') {
        enc = enc || 'utf8';
        data = new Buffer(data, enc);
      }
      var l = this._len += data.length;
      var s = this._s || 0;
      var f = 0;
      var buffer = this._block;
      while (s < l) {
        var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize));
        var ch = (t - f);
        for (var i = 0; i < ch; i++) {
          buffer[(s % this._blockSize) + i] = data[i + f];
        }
        s += ch;
        f += ch;
        if ((s % this._blockSize) === 0) {
          this._update(buffer);
        }
      }
      this._s = s;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var l = this._len * 8;
      this._block[this._len % this._blockSize] = 0x80;
      this._block.fill(0, this._len % this._blockSize + 1);
      if (l % (this._blockSize * 8) >= this._finalSize * 8) {
        this._update(this._block);
        this._block.fill(0);
      }
      this._block.writeInt32BE(l, this._blockSize - 4);
      var hash = this._update(this._block) || this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error('_update must be implemented by subclass');
    };
    module.exports = Hash;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("204", ["ad", "1ff", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var inherits = $__require('ad');
    var Hash = $__require('1ff');
    var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 0x6a09e667;
      this._bh = 0xbb67ae85;
      this._ch = 0x3c6ef372;
      this._dh = 0xa54ff53a;
      this._eh = 0x510e527f;
      this._fh = 0x9b05688c;
      this._gh = 0x1f83d9ab;
      this._hh = 0x5be0cd19;
      this._al = 0xf3bcc908;
      this._bl = 0x84caa73b;
      this._cl = 0xfe94f82b;
      this._dl = 0x5f1d36f1;
      this._el = 0xade682d1;
      this._fl = 0x2b3e6c1f;
      this._gl = 0xfb41bd6b;
      this._hl = 0x137e2179;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ (x & (y ^ z));
    }
    function maj(x, y, z) {
      return (x & y) | (z & (x | y));
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7);
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6);
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return (a >>> 0) < (b >>> 0) ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var W = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        W[i] = M.readInt32BE(i * 4);
        W[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = W[i - 15 * 2];
        var xl = W[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W[i - 2 * 2];
        xl = W[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W[i - 7 * 2];
        var Wi7l = W[i - 7 * 2 + 1];
        var Wi16h = W[i - 16 * 2];
        var Wi16l = W[i - 16 * 2 + 1];
        var Wil = (gamma0l + Wi7l) | 0;
        var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
        Wil = (Wil + gamma1l) | 0;
        Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
        Wil = (Wil + Wi16l) | 0;
        Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;
        W[i] = Wih;
        W[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = W[j];
        Wil = W[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = (hl + sigma1l) | 0;
        var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
        t1l = (t1l + chl) | 0;
        t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
        t1l = (t1l + Kil) | 0;
        t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
        t1l = (t1l + Wil) | 0;
        t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;
        var t2l = (sigma0l + majl) | 0;
        var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = (dl + t1l) | 0;
        eh = (dh + t1h + getCarry(el, dl)) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = (t1l + t2l) | 0;
        ah = (t1h + t2h + getCarry(al, t1l)) | 0;
      }
      this._al = (this._al + al) | 0;
      this._bl = (this._bl + bl) | 0;
      this._cl = (this._cl + cl) | 0;
      this._dl = (this._dl + dl) | 0;
      this._el = (this._el + el) | 0;
      this._fl = (this._fl + fl) | 0;
      this._gl = (this._gl + gl) | 0;
      this._hl = (this._hl + hl) | 0;
      this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
      this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
      this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
      this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
      this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
      this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
      this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
      this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = new Buffer(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module.exports = Sha512;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("205", ["1fe", "200", "201", "202", "203", "204"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var exports = module.exports = function SHA(algorithm) {
    algorithm = algorithm.toLowerCase();
    var Algorithm = exports[algorithm];
    if (!Algorithm)
      throw new Error(algorithm + ' is not supported (we accept pull requests)');
    return new Algorithm();
  };
  exports.sha = $__require('1fe');
  exports.sha1 = $__require('200');
  exports.sha224 = $__require('201');
  exports.sha256 = $__require('202');
  exports.sha384 = $__require('203');
  exports.sha512 = $__require('204');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("206", ["205"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('205');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("207", ["208", "20d", "209", "20a", "20b", "20c", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    exports = module.exports = $__require('208');
    exports.Stream = $__require('20d');
    exports.Readable = exports;
    exports.Writable = $__require('209');
    exports.Duplex = $__require('20a');
    exports.Transform = $__require('20b');
    exports.PassThrough = $__require('20c');
    if (!process.browser && process.env.READABLE_STREAM === 'disable') {
      module.exports = $__require('20d');
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("20e", ["209"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('209');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("20f", ["20a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('20a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("210", ["20b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('20b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("211", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Array.isArray || function(arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("212", ["211"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('211');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("213", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function EventEmitter() {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
  }
  module.exports = EventEmitter;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;
  EventEmitter.defaultMaxListeners = 10;
  EventEmitter.prototype.setMaxListeners = function(n) {
    if (!isNumber(n) || n < 0 || isNaN(n))
      throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
  };
  EventEmitter.prototype.emit = function(type) {
    var er,
        handler,
        len,
        args,
        i,
        listeners;
    if (!this._events)
      this._events = {};
    if (type === 'error') {
      if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) {
        er = arguments[1];
        if (er instanceof Error) {
          throw er;
        }
        throw TypeError('Uncaught, unspecified "error" event.');
      }
    }
    handler = this._events[type];
    if (isUndefined(handler))
      return false;
    if (isFunction(handler)) {
      switch (arguments.length) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    } else if (isObject(handler)) {
      len = arguments.length;
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      listeners = handler.slice();
      len = listeners.length;
      for (i = 0; i < len; i++)
        listeners[i].apply(this, args);
    }
    return true;
  };
  EventEmitter.prototype.addListener = function(type, listener) {
    var m;
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    if (!this._events)
      this._events = {};
    if (this._events.newListener)
      this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
    if (!this._events[type])
      this._events[type] = listener;
    else if (isObject(this._events[type]))
      this._events[type].push(listener);
    else
      this._events[type] = [this._events[type], listener];
    if (isObject(this._events[type]) && !this._events[type].warned) {
      var m;
      if (!isUndefined(this._maxListeners)) {
        m = this._maxListeners;
      } else {
        m = EventEmitter.defaultMaxListeners;
      }
      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
        if (typeof console.trace === 'function') {
          console.trace();
        }
      }
    }
    return this;
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.once = function(type, listener) {
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    var fired = false;
    function g() {
      this.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(this, arguments);
      }
    }
    g.listener = listener;
    this.on(type, g);
    return this;
  };
  EventEmitter.prototype.removeListener = function(type, listener) {
    var list,
        position,
        length,
        i;
    if (!isFunction(listener))
      throw TypeError('listener must be a function');
    if (!this._events || !this._events[type])
      return this;
    list = this._events[type];
    length = list.length;
    position = -1;
    if (list === listener || (isFunction(list.listener) && list.listener === listener)) {
      delete this._events[type];
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    } else if (isObject(list)) {
      for (i = length; i-- > 0; ) {
        if (list[i] === listener || (list[i].listener && list[i].listener === listener)) {
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (list.length === 1) {
        list.length = 0;
        delete this._events[type];
      } else {
        list.splice(position, 1);
      }
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function(type) {
    var key,
        listeners;
    if (!this._events)
      return this;
    if (!this._events.removeListener) {
      if (arguments.length === 0)
        this._events = {};
      else if (this._events[type])
        delete this._events[type];
      return this;
    }
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener')
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = {};
      return this;
    }
    listeners = this._events[type];
    if (isFunction(listeners)) {
      this.removeListener(type, listeners);
    } else {
      while (listeners.length)
        this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];
    return this;
  };
  EventEmitter.prototype.listeners = function(type) {
    var ret;
    if (!this._events || !this._events[type])
      ret = [];
    else if (isFunction(this._events[type]))
      ret = [this._events[type]];
    else
      ret = this._events[type].slice();
    return ret;
  };
  EventEmitter.listenerCount = function(emitter, type) {
    var ret;
    if (!emitter._events || !emitter._events[type])
      ret = 0;
    else if (isFunction(emitter._events[type]))
      ret = 1;
    else
      ret = emitter._events[type].length;
    return ret;
  };
  function isFunction(arg) {
    return typeof arg === 'function';
  }
  function isNumber(arg) {
    return typeof arg === 'number';
  }
  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("214", ["213"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('213');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("215", ["214"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('events') : $__require('214');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a", ["215"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('215');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("208", ["212", "72", "1a", "20d", "b8", "ad", "@empty", "20a", "119", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    module.exports = Readable;
    var isArray = $__require('212');
    var Buffer = $__require('72').Buffer;
    Readable.ReadableState = ReadableState;
    var EE = $__require('1a').EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = $__require('20d');
    var util = $__require('b8');
    util.inherits = $__require('ad');
    var StringDecoder;
    var debug = $__require('@empty');
    if (debug && debug.debuglog) {
      debug = debug.debuglog('stream');
    } else {
      debug = function() {};
    }
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      var Duplex = $__require('20a');
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = $__require('119').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      var Duplex = $__require('20a');
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (util.isString(chunk) && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (util.isNullOrUndefined(chunk)) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          if (!addToFront)
            state.reading = false;
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = $__require('119').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (isNaN(n) || util.isNull(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      debug('read', n);
      var state = this._readableState;
      var nOrig = n;
      if (!util.isNumber(n) || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug('need readable', doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      }
      if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (util.isNull(ret)) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
      if (!util.isNull(ret))
        this.emit('data', ret);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          process.nextTick(function() {
            emitReadable_(stream);
          });
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once('end', endFn);
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug('onend');
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      function cleanup() {
        debug('cleanup');
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        if (false === ret) {
          debug('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
      dest.emit('pipe', src);
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit('unpipe', this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === 'data' && false !== this._readableState.flowing) {
        this.resume();
      }
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            var self = this;
            process.nextTick(function() {
              debug('readable nexttick read 0');
              self.read(0);
            });
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        if (!state.reading) {
          debug('resume read 0');
          this.read(0);
        }
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(function() {
          resume_(stream, state);
        });
      }
    }
    function resume_(stream, state) {
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on('end', function() {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
        self.push(null);
      });
      stream.on('data', function(chunk) {
        debug('wrapped data');
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (!chunk || !state.objectMode && !chunk.length)
          return;
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
      self._read = function(n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
          var c = 0;
          for (var i = 0,
              l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("209", ["72", "b8", "ad", "20d", "20a", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    module.exports = Writable;
    var Buffer = $__require('72').Buffer;
    Writable.WritableState = WritableState;
    var util = $__require('b8');
    util.inherits = $__require('ad');
    var Stream = $__require('20d');
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      var Duplex = $__require('20a');
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = $__require('20a');
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      stream.emit('error', er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (util.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (!util.isFunction(cb))
        cb = function() {};
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(this, state);
      }
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (util.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, false, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          state.pendingcb--;
          cb(er);
        });
      else {
        state.pendingcb--;
        cb(er);
      }
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(stream, state);
        if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      if (stream._writev && state.buffer.length > 1) {
        var cbs = [];
        for (var c = 0; c < state.buffer.length; c++)
          cbs.push(state.buffer[c].callback);
        state.pendingcb++;
        doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
        state.buffer = [];
      } else {
        for (var c = 0; c < state.buffer.length; c++) {
          var entry = state.buffer[c];
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          if (state.writing) {
            c++;
            break;
          }
        }
        if (c < state.buffer.length)
          state.buffer = state.buffer.slice(c);
        else
          state.buffer.length = 0;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (util.isFunction(chunk)) {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (!util.isNullOrUndefined(chunk))
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return (state.ending && state.length === 0 && !state.finished && !state.writing);
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else
          prefinish(stream, state);
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
  })($__require('72').Buffer, $__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("20a", ["b8", "ad", "208", "209", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    module.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util = $__require('b8');
    util.inherits = $__require('ad');
    var Readable = $__require('208');
    var Writable = $__require('209');
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once('end', onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("20b", ["20a", "b8", "ad", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    module.exports = Transform;
    var Duplex = $__require('20a');
    var util = $__require('b8');
    util.inherits = $__require('ad');
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
      ts.writechunk = null;
      ts.writecb = null;
      if (!util.isNullOrUndefined(data))
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once('prefinish', function() {
        if (util.isFunction(this._flush))
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
      return stream.push(null);
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("216", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === '[object Array]';
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b8", ["216"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('216');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("20c", ["20b", "b8", "ad"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = PassThrough;
  var Transform = $__require('20b');
  var util = $__require('b8');
  util.inherits = $__require('ad');
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("217", ["20c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('20c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("20d", ["1a", "ad", "207", "20e", "20f", "210", "217"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Stream;
  var EE = $__require('1a').EventEmitter;
  var inherits = $__require('ad');
  inherits(Stream, EE);
  Stream.Readable = $__require('207');
  Stream.Writable = $__require('20e');
  Stream.Duplex = $__require('20f');
  Stream.Transform = $__require('210');
  Stream.PassThrough = $__require('217');
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on('data', ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on('drain', ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === 'function')
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, 'error') === 0) {
        throw er;
      }
    }
    source.on('error', onerror);
    dest.on('error', onerror);
    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);
      source.removeListener('end', onend);
      source.removeListener('close', onclose);
      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);
      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);
      dest.removeListener('close', cleanup);
    }
    source.on('end', cleanup);
    source.on('close', cleanup);
    dest.on('close', cleanup);
    dest.emit('pipe', source);
    return dest;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("218", ["20d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('20d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("219", ["218"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('stream') : $__require('218');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("58", ["219"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('219');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("21a", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if (typeof Object.create === 'function') {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }});
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ad", ["21a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('21a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("21b", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var Buffer = $__require('72').Buffer;
    var isBufferEncoding = Buffer.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      while (this.charLength) {
        var available = (buffer.length >= this.charLength - this.charReceived) ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return '';
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = (buffer.length >= 3) ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("119", ["21b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('21b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("21c", ["119"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('string_decoder') : $__require('119');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("fc", ["21c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('21c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("21d", ["58", "ad", "fc", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var Transform = $__require('58').Transform;
    var inherits = $__require('ad');
    var StringDecoder = $__require('fc').StringDecoder;
    module.exports = CipherBase;
    inherits(CipherBase, Transform);
    function CipherBase(hashMode) {
      Transform.call(this);
      this.hashMode = typeof hashMode === 'string';
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this.final = this._finalOrDigest;
      }
      this._decoder = null;
      this._encoding = null;
    }
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      if (typeof data === 'string') {
        data = new Buffer(data, inputEnc);
      }
      var outData = this._update(data);
      if (this.hashMode) {
        return this;
      }
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {};
    CipherBase.prototype.getAuthTag = function() {
      throw new Error('trying to get auth tag in unsupported state');
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error('trying to set auth tag in unsupported state');
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error('trying to set aad in unsupported state');
    };
    CipherBase.prototype._transform = function(data, _, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e) {
        err = e;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done) {
      var err;
      try {
        this.push(this._final());
      } catch (e) {
        err = e;
      } finally {
        done(err);
      }
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this._final() || new Buffer('');
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc) {
        throw new Error('can\'t switch encodings');
      }
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("18c", ["21d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('21d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f4", ["ad", "1f0", "1fd", "206", "18c", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    'use strict';
    var inherits = $__require('ad');
    var md5 = $__require('1f0');
    var rmd160 = $__require('1fd');
    var sha = $__require('206');
    var Base = $__require('18c');
    function HashNoConstructor(hash) {
      Base.call(this, 'digest');
      this._hash = hash;
      this.buffers = [];
    }
    inherits(HashNoConstructor, Base);
    HashNoConstructor.prototype._update = function(data) {
      this.buffers.push(data);
    };
    HashNoConstructor.prototype._final = function() {
      var buf = Buffer.concat(this.buffers);
      var r = this._hash(buf);
      this.buffers = null;
      return r;
    };
    function Hash(hash) {
      Base.call(this, 'digest');
      this._hash = hash;
    }
    inherits(Hash, Base);
    Hash.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hash.prototype._final = function() {
      return this._hash.digest();
    };
    module.exports = function createHash(alg) {
      alg = alg.toLowerCase();
      if ('md5' === alg)
        return new HashNoConstructor(md5);
      if ('rmd160' === alg || 'ripemd160' === alg)
        return new HashNoConstructor(rmd160);
      return new Hash(sha(alg));
    };
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a7", ["1f4"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('1f4');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("21e", ["72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    (function(module, exports) {
      'use strict';
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || 'Assertion failed');
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === 'le' || base === 'be') {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || 'be');
        }
      }
      if (typeof module === 'object') {
        module.exports = BN;
      } else {
        exports.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer;
      try {
        Buffer = $__require('buf' + 'fer').Buffer;
      } catch (e) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === 'number') {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === 'object') {
          return this._initArray(number, base, endian);
        }
        if (base === 'hex') {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, '');
        var start = 0;
        if (number[0] === '-') {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === '-') {
          this.negative = 1;
        }
        this.strip();
        if (endian !== 'le')
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 0x4000000) {
          this.words = [number & 0x3ffffff];
          this.length = 1;
        } else if (number < 0x10000000000000) {
          this.words = [number & 0x3ffffff, (number / 0x4000000) & 0x3ffffff];
          this.length = 2;
        } else {
          assert(number < 0x20000000000000);
          this.words = [number & 0x3ffffff, (number / 0x4000000) & 0x3ffffff, 1];
          this.length = 3;
        }
        if (endian !== 'le')
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === 'number');
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j,
            w;
        var off = 0;
        if (endian === 'be') {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
            this.words[j] |= (w << off) & 0x3ffffff;
            this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === 'le') {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
            this.words[j] |= (w << off) & 0x3ffffff;
            this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 0xa;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 0xa;
          } else {
            r |= c & 0xf;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j,
            w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= (w << off) & 0x3ffffff;
          this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= (w << off) & 0x3ffffff;
          this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 0xa;
          } else if (c >= 17) {
            r += c - 17 + 0xa;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0,
            limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = (limbPow / base) | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
      };
      var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
      var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
      var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === 'hex') {
          out = '';
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = (((w << off) | carry) & 0xffffff).toString(16);
            carry = (w >>> (24 - off)) & 0xffffff;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = '0' + out;
          }
          if (this.negative !== 0) {
            out = '-' + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = '';
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = '0' + out;
          }
          while (out.length % padding !== 0) {
            out = '0' + out;
          }
          if (this.negative !== 0) {
            out = '-' + out;
          }
          return out;
        }
        assert(false, 'Base should be between 2 and 36');
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 0x4000000;
        } else if (this.length === 3 && this.words[2] === 0x01) {
          ret += 0x10000000000000 + (this.words[1] * 0x4000000);
        } else if (this.length > 2) {
          assert(false, 'Number can only safely store up to 53 bits');
        }
        return (this.negative !== 0) ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer !== 'undefined');
        return this.toArrayLike(Buffer, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, 'byte array longer than desired length');
        assert(reqLength > 0, 'Requested array length <= 0');
        this.strip();
        var littleEndian = endian === 'le';
        var res = new ArrayType(reqLength);
        var b,
            i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(0xff);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(0xff);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 0x40) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 0x8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 0x02) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 0xf) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 0x3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 0x1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = (bit / 26) | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === 'number' && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 0x3ffffff;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === 'number' && bit >= 0);
        var off = (bit / 26) | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | (1 << wbit);
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a,
            b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a,
            b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = (self.length + num.length) | 0;
        out.length = len;
        len = (len - 1) | 0;
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = (r / 0x4000000) | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = (k - j) | 0;
            a = self.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += (r / 0x4000000) | 0;
            rword = r & 0x3ffffff;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = (mid + Math.imul(ah0, bl0)) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
        w0 &= 0x3ffffff;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = (mid + Math.imul(ah1, bl0)) | 0;
        hi = Math.imul(ah1, bh0);
        lo = (lo + Math.imul(al0, bl1)) | 0;
        mid = (mid + Math.imul(al0, bh1)) | 0;
        mid = (mid + Math.imul(ah0, bl1)) | 0;
        hi = (hi + Math.imul(ah0, bh1)) | 0;
        var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
        w1 &= 0x3ffffff;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = (mid + Math.imul(ah2, bl0)) | 0;
        hi = Math.imul(ah2, bh0);
        lo = (lo + Math.imul(al1, bl1)) | 0;
        mid = (mid + Math.imul(al1, bh1)) | 0;
        mid = (mid + Math.imul(ah1, bl1)) | 0;
        hi = (hi + Math.imul(ah1, bh1)) | 0;
        lo = (lo + Math.imul(al0, bl2)) | 0;
        mid = (mid + Math.imul(al0, bh2)) | 0;
        mid = (mid + Math.imul(ah0, bl2)) | 0;
        hi = (hi + Math.imul(ah0, bh2)) | 0;
        var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
        w2 &= 0x3ffffff;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = (mid + Math.imul(ah3, bl0)) | 0;
        hi = Math.imul(ah3, bh0);
        lo = (lo + Math.imul(al2, bl1)) | 0;
        mid = (mid + Math.imul(al2, bh1)) | 0;
        mid = (mid + Math.imul(ah2, bl1)) | 0;
        hi = (hi + Math.imul(ah2, bh1)) | 0;
        lo = (lo + Math.imul(al1, bl2)) | 0;
        mid = (mid + Math.imul(al1, bh2)) | 0;
        mid = (mid + Math.imul(ah1, bl2)) | 0;
        hi = (hi + Math.imul(ah1, bh2)) | 0;
        lo = (lo + Math.imul(al0, bl3)) | 0;
        mid = (mid + Math.imul(al0, bh3)) | 0;
        mid = (mid + Math.imul(ah0, bl3)) | 0;
        hi = (hi + Math.imul(ah0, bh3)) | 0;
        var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
        w3 &= 0x3ffffff;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = (mid + Math.imul(ah4, bl0)) | 0;
        hi = Math.imul(ah4, bh0);
        lo = (lo + Math.imul(al3, bl1)) | 0;
        mid = (mid + Math.imul(al3, bh1)) | 0;
        mid = (mid + Math.imul(ah3, bl1)) | 0;
        hi = (hi + Math.imul(ah3, bh1)) | 0;
        lo = (lo + Math.imul(al2, bl2)) | 0;
        mid = (mid + Math.imul(al2, bh2)) | 0;
        mid = (mid + Math.imul(ah2, bl2)) | 0;
        hi = (hi + Math.imul(ah2, bh2)) | 0;
        lo = (lo + Math.imul(al1, bl3)) | 0;
        mid = (mid + Math.imul(al1, bh3)) | 0;
        mid = (mid + Math.imul(ah1, bl3)) | 0;
        hi = (hi + Math.imul(ah1, bh3)) | 0;
        lo = (lo + Math.imul(al0, bl4)) | 0;
        mid = (mid + Math.imul(al0, bh4)) | 0;
        mid = (mid + Math.imul(ah0, bl4)) | 0;
        hi = (hi + Math.imul(ah0, bh4)) | 0;
        var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
        w4 &= 0x3ffffff;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = (mid + Math.imul(ah5, bl0)) | 0;
        hi = Math.imul(ah5, bh0);
        lo = (lo + Math.imul(al4, bl1)) | 0;
        mid = (mid + Math.imul(al4, bh1)) | 0;
        mid = (mid + Math.imul(ah4, bl1)) | 0;
        hi = (hi + Math.imul(ah4, bh1)) | 0;
        lo = (lo + Math.imul(al3, bl2)) | 0;
        mid = (mid + Math.imul(al3, bh2)) | 0;
        mid = (mid + Math.imul(ah3, bl2)) | 0;
        hi = (hi + Math.imul(ah3, bh2)) | 0;
        lo = (lo + Math.imul(al2, bl3)) | 0;
        mid = (mid + Math.imul(al2, bh3)) | 0;
        mid = (mid + Math.imul(ah2, bl3)) | 0;
        hi = (hi + Math.imul(ah2, bh3)) | 0;
        lo = (lo + Math.imul(al1, bl4)) | 0;
        mid = (mid + Math.imul(al1, bh4)) | 0;
        mid = (mid + Math.imul(ah1, bl4)) | 0;
        hi = (hi + Math.imul(ah1, bh4)) | 0;
        lo = (lo + Math.imul(al0, bl5)) | 0;
        mid = (mid + Math.imul(al0, bh5)) | 0;
        mid = (mid + Math.imul(ah0, bl5)) | 0;
        hi = (hi + Math.imul(ah0, bh5)) | 0;
        var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
        w5 &= 0x3ffffff;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = (mid + Math.imul(ah6, bl0)) | 0;
        hi = Math.imul(ah6, bh0);
        lo = (lo + Math.imul(al5, bl1)) | 0;
        mid = (mid + Math.imul(al5, bh1)) | 0;
        mid = (mid + Math.imul(ah5, bl1)) | 0;
        hi = (hi + Math.imul(ah5, bh1)) | 0;
        lo = (lo + Math.imul(al4, bl2)) | 0;
        mid = (mid + Math.imul(al4, bh2)) | 0;
        mid = (mid + Math.imul(ah4, bl2)) | 0;
        hi = (hi + Math.imul(ah4, bh2)) | 0;
        lo = (lo + Math.imul(al3, bl3)) | 0;
        mid = (mid + Math.imul(al3, bh3)) | 0;
        mid = (mid + Math.imul(ah3, bl3)) | 0;
        hi = (hi + Math.imul(ah3, bh3)) | 0;
        lo = (lo + Math.imul(al2, bl4)) | 0;
        mid = (mid + Math.imul(al2, bh4)) | 0;
        mid = (mid + Math.imul(ah2, bl4)) | 0;
        hi = (hi + Math.imul(ah2, bh4)) | 0;
        lo = (lo + Math.imul(al1, bl5)) | 0;
        mid = (mid + Math.imul(al1, bh5)) | 0;
        mid = (mid + Math.imul(ah1, bl5)) | 0;
        hi = (hi + Math.imul(ah1, bh5)) | 0;
        lo = (lo + Math.imul(al0, bl6)) | 0;
        mid = (mid + Math.imul(al0, bh6)) | 0;
        mid = (mid + Math.imul(ah0, bl6)) | 0;
        hi = (hi + Math.imul(ah0, bh6)) | 0;
        var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
        w6 &= 0x3ffffff;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = (mid + Math.imul(ah7, bl0)) | 0;
        hi = Math.imul(ah7, bh0);
        lo = (lo + Math.imul(al6, bl1)) | 0;
        mid = (mid + Math.imul(al6, bh1)) | 0;
        mid = (mid + Math.imul(ah6, bl1)) | 0;
        hi = (hi + Math.imul(ah6, bh1)) | 0;
        lo = (lo + Math.imul(al5, bl2)) | 0;
        mid = (mid + Math.imul(al5, bh2)) | 0;
        mid = (mid + Math.imul(ah5, bl2)) | 0;
        hi = (hi + Math.imul(ah5, bh2)) | 0;
        lo = (lo + Math.imul(al4, bl3)) | 0;
        mid = (mid + Math.imul(al4, bh3)) | 0;
        mid = (mid + Math.imul(ah4, bl3)) | 0;
        hi = (hi + Math.imul(ah4, bh3)) | 0;
        lo = (lo + Math.imul(al3, bl4)) | 0;
        mid = (mid + Math.imul(al3, bh4)) | 0;
        mid = (mid + Math.imul(ah3, bl4)) | 0;
        hi = (hi + Math.imul(ah3, bh4)) | 0;
        lo = (lo + Math.imul(al2, bl5)) | 0;
        mid = (mid + Math.imul(al2, bh5)) | 0;
        mid = (mid + Math.imul(ah2, bl5)) | 0;
        hi = (hi + Math.imul(ah2, bh5)) | 0;
        lo = (lo + Math.imul(al1, bl6)) | 0;
        mid = (mid + Math.imul(al1, bh6)) | 0;
        mid = (mid + Math.imul(ah1, bl6)) | 0;
        hi = (hi + Math.imul(ah1, bh6)) | 0;
        lo = (lo + Math.imul(al0, bl7)) | 0;
        mid = (mid + Math.imul(al0, bh7)) | 0;
        mid = (mid + Math.imul(ah0, bl7)) | 0;
        hi = (hi + Math.imul(ah0, bh7)) | 0;
        var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
        w7 &= 0x3ffffff;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = (mid + Math.imul(ah8, bl0)) | 0;
        hi = Math.imul(ah8, bh0);
        lo = (lo + Math.imul(al7, bl1)) | 0;
        mid = (mid + Math.imul(al7, bh1)) | 0;
        mid = (mid + Math.imul(ah7, bl1)) | 0;
        hi = (hi + Math.imul(ah7, bh1)) | 0;
        lo = (lo + Math.imul(al6, bl2)) | 0;
        mid = (mid + Math.imul(al6, bh2)) | 0;
        mid = (mid + Math.imul(ah6, bl2)) | 0;
        hi = (hi + Math.imul(ah6, bh2)) | 0;
        lo = (lo + Math.imul(al5, bl3)) | 0;
        mid = (mid + Math.imul(al5, bh3)) | 0;
        mid = (mid + Math.imul(ah5, bl3)) | 0;
        hi = (hi + Math.imul(ah5, bh3)) | 0;
        lo = (lo + Math.imul(al4, bl4)) | 0;
        mid = (mid + Math.imul(al4, bh4)) | 0;
        mid = (mid + Math.imul(ah4, bl4)) | 0;
        hi = (hi + Math.imul(ah4, bh4)) | 0;
        lo = (lo + Math.imul(al3, bl5)) | 0;
        mid = (mid + Math.imul(al3, bh5)) | 0;
        mid = (mid + Math.imul(ah3, bl5)) | 0;
        hi = (hi + Math.imul(ah3, bh5)) | 0;
        lo = (lo + Math.imul(al2, bl6)) | 0;
        mid = (mid + Math.imul(al2, bh6)) | 0;
        mid = (mid + Math.imul(ah2, bl6)) | 0;
        hi = (hi + Math.imul(ah2, bh6)) | 0;
        lo = (lo + Math.imul(al1, bl7)) | 0;
        mid = (mid + Math.imul(al1, bh7)) | 0;
        mid = (mid + Math.imul(ah1, bl7)) | 0;
        hi = (hi + Math.imul(ah1, bh7)) | 0;
        lo = (lo + Math.imul(al0, bl8)) | 0;
        mid = (mid + Math.imul(al0, bh8)) | 0;
        mid = (mid + Math.imul(ah0, bl8)) | 0;
        hi = (hi + Math.imul(ah0, bh8)) | 0;
        var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
        w8 &= 0x3ffffff;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = (mid + Math.imul(ah9, bl0)) | 0;
        hi = Math.imul(ah9, bh0);
        lo = (lo + Math.imul(al8, bl1)) | 0;
        mid = (mid + Math.imul(al8, bh1)) | 0;
        mid = (mid + Math.imul(ah8, bl1)) | 0;
        hi = (hi + Math.imul(ah8, bh1)) | 0;
        lo = (lo + Math.imul(al7, bl2)) | 0;
        mid = (mid + Math.imul(al7, bh2)) | 0;
        mid = (mid + Math.imul(ah7, bl2)) | 0;
        hi = (hi + Math.imul(ah7, bh2)) | 0;
        lo = (lo + Math.imul(al6, bl3)) | 0;
        mid = (mid + Math.imul(al6, bh3)) | 0;
        mid = (mid + Math.imul(ah6, bl3)) | 0;
        hi = (hi + Math.imul(ah6, bh3)) | 0;
        lo = (lo + Math.imul(al5, bl4)) | 0;
        mid = (mid + Math.imul(al5, bh4)) | 0;
        mid = (mid + Math.imul(ah5, bl4)) | 0;
        hi = (hi + Math.imul(ah5, bh4)) | 0;
        lo = (lo + Math.imul(al4, bl5)) | 0;
        mid = (mid + Math.imul(al4, bh5)) | 0;
        mid = (mid + Math.imul(ah4, bl5)) | 0;
        hi = (hi + Math.imul(ah4, bh5)) | 0;
        lo = (lo + Math.imul(al3, bl6)) | 0;
        mid = (mid + Math.imul(al3, bh6)) | 0;
        mid = (mid + Math.imul(ah3, bl6)) | 0;
        hi = (hi + Math.imul(ah3, bh6)) | 0;
        lo = (lo + Math.imul(al2, bl7)) | 0;
        mid = (mid + Math.imul(al2, bh7)) | 0;
        mid = (mid + Math.imul(ah2, bl7)) | 0;
        hi = (hi + Math.imul(ah2, bh7)) | 0;
        lo = (lo + Math.imul(al1, bl8)) | 0;
        mid = (mid + Math.imul(al1, bh8)) | 0;
        mid = (mid + Math.imul(ah1, bl8)) | 0;
        hi = (hi + Math.imul(ah1, bh8)) | 0;
        lo = (lo + Math.imul(al0, bl9)) | 0;
        mid = (mid + Math.imul(al0, bh9)) | 0;
        mid = (mid + Math.imul(ah0, bl9)) | 0;
        hi = (hi + Math.imul(ah0, bh9)) | 0;
        var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
        w9 &= 0x3ffffff;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = (mid + Math.imul(ah9, bl1)) | 0;
        hi = Math.imul(ah9, bh1);
        lo = (lo + Math.imul(al8, bl2)) | 0;
        mid = (mid + Math.imul(al8, bh2)) | 0;
        mid = (mid + Math.imul(ah8, bl2)) | 0;
        hi = (hi + Math.imul(ah8, bh2)) | 0;
        lo = (lo + Math.imul(al7, bl3)) | 0;
        mid = (mid + Math.imul(al7, bh3)) | 0;
        mid = (mid + Math.imul(ah7, bl3)) | 0;
        hi = (hi + Math.imul(ah7, bh3)) | 0;
        lo = (lo + Math.imul(al6, bl4)) | 0;
        mid = (mid + Math.imul(al6, bh4)) | 0;
        mid = (mid + Math.imul(ah6, bl4)) | 0;
        hi = (hi + Math.imul(ah6, bh4)) | 0;
        lo = (lo + Math.imul(al5, bl5)) | 0;
        mid = (mid + Math.imul(al5, bh5)) | 0;
        mid = (mid + Math.imul(ah5, bl5)) | 0;
        hi = (hi + Math.imul(ah5, bh5)) | 0;
        lo = (lo + Math.imul(al4, bl6)) | 0;
        mid = (mid + Math.imul(al4, bh6)) | 0;
        mid = (mid + Math.imul(ah4, bl6)) | 0;
        hi = (hi + Math.imul(ah4, bh6)) | 0;
        lo = (lo + Math.imul(al3, bl7)) | 0;
        mid = (mid + Math.imul(al3, bh7)) | 0;
        mid = (mid + Math.imul(ah3, bl7)) | 0;
        hi = (hi + Math.imul(ah3, bh7)) | 0;
        lo = (lo + Math.imul(al2, bl8)) | 0;
        mid = (mid + Math.imul(al2, bh8)) | 0;
        mid = (mid + Math.imul(ah2, bl8)) | 0;
        hi = (hi + Math.imul(ah2, bh8)) | 0;
        lo = (lo + Math.imul(al1, bl9)) | 0;
        mid = (mid + Math.imul(al1, bh9)) | 0;
        mid = (mid + Math.imul(ah1, bl9)) | 0;
        hi = (hi + Math.imul(ah1, bh9)) | 0;
        var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
        w10 &= 0x3ffffff;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = (mid + Math.imul(ah9, bl2)) | 0;
        hi = Math.imul(ah9, bh2);
        lo = (lo + Math.imul(al8, bl3)) | 0;
        mid = (mid + Math.imul(al8, bh3)) | 0;
        mid = (mid + Math.imul(ah8, bl3)) | 0;
        hi = (hi + Math.imul(ah8, bh3)) | 0;
        lo = (lo + Math.imul(al7, bl4)) | 0;
        mid = (mid + Math.imul(al7, bh4)) | 0;
        mid = (mid + Math.imul(ah7, bl4)) | 0;
        hi = (hi + Math.imul(ah7, bh4)) | 0;
        lo = (lo + Math.imul(al6, bl5)) | 0;
        mid = (mid + Math.imul(al6, bh5)) | 0;
        mid = (mid + Math.imul(ah6, bl5)) | 0;
        hi = (hi + Math.imul(ah6, bh5)) | 0;
        lo = (lo + Math.imul(al5, bl6)) | 0;
        mid = (mid + Math.imul(al5, bh6)) | 0;
        mid = (mid + Math.imul(ah5, bl6)) | 0;
        hi = (hi + Math.imul(ah5, bh6)) | 0;
        lo = (lo + Math.imul(al4, bl7)) | 0;
        mid = (mid + Math.imul(al4, bh7)) | 0;
        mid = (mid + Math.imul(ah4, bl7)) | 0;
        hi = (hi + Math.imul(ah4, bh7)) | 0;
        lo = (lo + Math.imul(al3, bl8)) | 0;
        mid = (mid + Math.imul(al3, bh8)) | 0;
        mid = (mid + Math.imul(ah3, bl8)) | 0;
        hi = (hi + Math.imul(ah3, bh8)) | 0;
        lo = (lo + Math.imul(al2, bl9)) | 0;
        mid = (mid + Math.imul(al2, bh9)) | 0;
        mid = (mid + Math.imul(ah2, bl9)) | 0;
        hi = (hi + Math.imul(ah2, bh9)) | 0;
        var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
        w11 &= 0x3ffffff;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = (mid + Math.imul(ah9, bl3)) | 0;
        hi = Math.imul(ah9, bh3);
        lo = (lo + Math.imul(al8, bl4)) | 0;
        mid = (mid + Math.imul(al8, bh4)) | 0;
        mid = (mid + Math.imul(ah8, bl4)) | 0;
        hi = (hi + Math.imul(ah8, bh4)) | 0;
        lo = (lo + Math.imul(al7, bl5)) | 0;
        mid = (mid + Math.imul(al7, bh5)) | 0;
        mid = (mid + Math.imul(ah7, bl5)) | 0;
        hi = (hi + Math.imul(ah7, bh5)) | 0;
        lo = (lo + Math.imul(al6, bl6)) | 0;
        mid = (mid + Math.imul(al6, bh6)) | 0;
        mid = (mid + Math.imul(ah6, bl6)) | 0;
        hi = (hi + Math.imul(ah6, bh6)) | 0;
        lo = (lo + Math.imul(al5, bl7)) | 0;
        mid = (mid + Math.imul(al5, bh7)) | 0;
        mid = (mid + Math.imul(ah5, bl7)) | 0;
        hi = (hi + Math.imul(ah5, bh7)) | 0;
        lo = (lo + Math.imul(al4, bl8)) | 0;
        mid = (mid + Math.imul(al4, bh8)) | 0;
        mid = (mid + Math.imul(ah4, bl8)) | 0;
        hi = (hi + Math.imul(ah4, bh8)) | 0;
        lo = (lo + Math.imul(al3, bl9)) | 0;
        mid = (mid + Math.imul(al3, bh9)) | 0;
        mid = (mid + Math.imul(ah3, bl9)) | 0;
        hi = (hi + Math.imul(ah3, bh9)) | 0;
        var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
        w12 &= 0x3ffffff;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = (mid + Math.imul(ah9, bl4)) | 0;
        hi = Math.imul(ah9, bh4);
        lo = (lo + Math.imul(al8, bl5)) | 0;
        mid = (mid + Math.imul(al8, bh5)) | 0;
        mid = (mid + Math.imul(ah8, bl5)) | 0;
        hi = (hi + Math.imul(ah8, bh5)) | 0;
        lo = (lo + Math.imul(al7, bl6)) | 0;
        mid = (mid + Math.imul(al7, bh6)) | 0;
        mid = (mid + Math.imul(ah7, bl6)) | 0;
        hi = (hi + Math.imul(ah7, bh6)) | 0;
        lo = (lo + Math.imul(al6, bl7)) | 0;
        mid = (mid + Math.imul(al6, bh7)) | 0;
        mid = (mid + Math.imul(ah6, bl7)) | 0;
        hi = (hi + Math.imul(ah6, bh7)) | 0;
        lo = (lo + Math.imul(al5, bl8)) | 0;
        mid = (mid + Math.imul(al5, bh8)) | 0;
        mid = (mid + Math.imul(ah5, bl8)) | 0;
        hi = (hi + Math.imul(ah5, bh8)) | 0;
        lo = (lo + Math.imul(al4, bl9)) | 0;
        mid = (mid + Math.imul(al4, bh9)) | 0;
        mid = (mid + Math.imul(ah4, bl9)) | 0;
        hi = (hi + Math.imul(ah4, bh9)) | 0;
        var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
        w13 &= 0x3ffffff;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = (mid + Math.imul(ah9, bl5)) | 0;
        hi = Math.imul(ah9, bh5);
        lo = (lo + Math.imul(al8, bl6)) | 0;
        mid = (mid + Math.imul(al8, bh6)) | 0;
        mid = (mid + Math.imul(ah8, bl6)) | 0;
        hi = (hi + Math.imul(ah8, bh6)) | 0;
        lo = (lo + Math.imul(al7, bl7)) | 0;
        mid = (mid + Math.imul(al7, bh7)) | 0;
        mid = (mid + Math.imul(ah7, bl7)) | 0;
        hi = (hi + Math.imul(ah7, bh7)) | 0;
        lo = (lo + Math.imul(al6, bl8)) | 0;
        mid = (mid + Math.imul(al6, bh8)) | 0;
        mid = (mid + Math.imul(ah6, bl8)) | 0;
        hi = (hi + Math.imul(ah6, bh8)) | 0;
        lo = (lo + Math.imul(al5, bl9)) | 0;
        mid = (mid + Math.imul(al5, bh9)) | 0;
        mid = (mid + Math.imul(ah5, bl9)) | 0;
        hi = (hi + Math.imul(ah5, bh9)) | 0;
        var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
        w14 &= 0x3ffffff;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = (mid + Math.imul(ah9, bl6)) | 0;
        hi = Math.imul(ah9, bh6);
        lo = (lo + Math.imul(al8, bl7)) | 0;
        mid = (mid + Math.imul(al8, bh7)) | 0;
        mid = (mid + Math.imul(ah8, bl7)) | 0;
        hi = (hi + Math.imul(ah8, bh7)) | 0;
        lo = (lo + Math.imul(al7, bl8)) | 0;
        mid = (mid + Math.imul(al7, bh8)) | 0;
        mid = (mid + Math.imul(ah7, bl8)) | 0;
        hi = (hi + Math.imul(ah7, bh8)) | 0;
        lo = (lo + Math.imul(al6, bl9)) | 0;
        mid = (mid + Math.imul(al6, bh9)) | 0;
        mid = (mid + Math.imul(ah6, bl9)) | 0;
        hi = (hi + Math.imul(ah6, bh9)) | 0;
        var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
        w15 &= 0x3ffffff;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = (mid + Math.imul(ah9, bl7)) | 0;
        hi = Math.imul(ah9, bh7);
        lo = (lo + Math.imul(al8, bl8)) | 0;
        mid = (mid + Math.imul(al8, bh8)) | 0;
        mid = (mid + Math.imul(ah8, bl8)) | 0;
        hi = (hi + Math.imul(ah8, bh8)) | 0;
        lo = (lo + Math.imul(al7, bl9)) | 0;
        mid = (mid + Math.imul(al7, bh9)) | 0;
        mid = (mid + Math.imul(ah7, bl9)) | 0;
        hi = (hi + Math.imul(ah7, bh9)) | 0;
        var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
        w16 &= 0x3ffffff;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = (mid + Math.imul(ah9, bl8)) | 0;
        hi = Math.imul(ah9, bh8);
        lo = (lo + Math.imul(al8, bl9)) | 0;
        mid = (mid + Math.imul(al8, bh9)) | 0;
        mid = (mid + Math.imul(ah8, bl9)) | 0;
        hi = (hi + Math.imul(ah8, bh9)) | 0;
        var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
        w17 &= 0x3ffffff;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = (mid + Math.imul(ah9, bl9)) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 0x3ffffff;
            ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
            lo = (lo + rword) | 0;
            rword = lo & 0x3ffffff;
            ncarry = (ncarry + (lo >>> 26)) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << (l - i - 1);
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 0x3ffffff;
          if (w < 0x4000000) {
            carry = 0;
          } else {
            carry = w / 0x4000000 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 0x1fff;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 0x1fff;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~0x1fff) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
          carry >>= 26;
          carry += (w / 0x4000000) | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = ((this.words[i] | 0) - newCarry) << r;
            this.words[i] = c | carry;
            carry = newCarry >>> (26 - r);
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === 'number' && bits >= 0);
        var h;
        if (hint) {
          h = (hint - (hint % 26)) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {} else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = (carry << (26 - r)) | (word >>> r);
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === 'number' && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, 'imaskn works only with positive numbers');
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
          this.words[i] -= 0x4000000;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 0x3ffffff;
          carry = (w >> 26) - ((right / 0x4000000) | 0);
          this.words[i + shift] = w & 0x3ffffff;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== 'mod') {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
          qj = Math.min((qj / bhi) | 0, 0x3ffffff);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== 'div' && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div,
            mod,
            res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== 'mod') {
            div = res.div.neg();
          }
          if (mode !== 'div') {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div: div,
            mod: mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== 'mod') {
            div = res.div.neg();
          }
          return {
            div: div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== 'div') {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === 'div') {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === 'mod') {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, 'div', false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, 'mod', false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, 'mod', true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 0x4000000;
          this.words[i] = (w / num) | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0,
              im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0,
              jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0,
              im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0,
              jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === 'number');
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 0x3ffffff;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 0x3ffffff, 'Number is too big');
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        assert(this.negative === 0, 'red works only with positives');
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, 'fromRed works only with numbers in reduction context');
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, 'redAdd works only with red numbers');
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, 'redIAdd works only with red numbers');
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, 'redSub works only with red numbers');
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, 'redISub works only with red numbers');
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, 'redShl works only with red numbers');
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, 'redSqr works only with red numbers');
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, 'redISqr works only with red numbers');
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, 'redSqrt works only with red numbers');
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, 'redInvm works only with red numbers');
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, 'redNeg works only with red numbers');
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, 'redPow(normalNum)');
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 0x3d1;
          num.words[i] = lo & 0x3ffffff;
          lo = w * 0x40 + ((lo / 0x4000000) | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 0x13 + carry;
          var lo = hi & 0x3ffffff;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime;
        if (name === 'k256') {
          prime = new K256();
        } else if (name === 'p224') {
          prime = new P224();
        } else if (name === 'p192') {
          prime = new P192();
        } else if (name === 'p25519') {
          prime = new P25519();
        } else {
          throw new Error('Unknown prime ' + name);
        }
        primes[name] = prime;
        return prime;
      };
      function Red(m) {
        if (typeof m === 'string') {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), 'modulus must be greater than 1');
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, 'red works only with positives');
        assert(a.red, 'red works only with red numbers');
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, 'red works only with positives');
        assert(a.red && a.red === b.red, 'red works only with red numbers');
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = (word >> j) & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - (this.shift % 26);
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === 'undefined' || module, this);
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("197", ["21e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('21e');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c7", ["197", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var bn = $__require('197');
    function withPublic(paddedMsg, key) {
      return new Buffer(paddedMsg.toRed(bn.mont(key.modulus)).redPow(new bn(key.publicExponent)).fromRed().toArray());
    }
    module.exports = withPublic;
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("21f", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  ;
  (function(exports) {
    'use strict';
    var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
    var PLUS = '+'.charCodeAt(0);
    var SLASH = '/'.charCodeAt(0);
    var NUMBER = '0'.charCodeAt(0);
    var LOWER = 'a'.charCodeAt(0);
    var UPPER = 'A'.charCodeAt(0);
    var PLUS_URL_SAFE = '-'.charCodeAt(0);
    var SLASH_URL_SAFE = '_'.charCodeAt(0);
    function decode(elt) {
      var code = elt.charCodeAt(0);
      if (code === PLUS || code === PLUS_URL_SAFE)
        return 62;
      if (code === SLASH || code === SLASH_URL_SAFE)
        return 63;
      if (code < NUMBER)
        return -1;
      if (code < NUMBER + 10)
        return code - NUMBER + 26 + 26;
      if (code < UPPER + 26)
        return code - UPPER;
      if (code < LOWER + 26)
        return code - LOWER + 26;
    }
    function b64ToByteArray(b64) {
      var i,
          j,
          l,
          tmp,
          placeHolders,
          arr;
      if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      var len = b64.length;
      placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
      arr = new Arr(b64.length * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? b64.length - 4 : b64.length;
      var L = 0;
      function push(v) {
        arr[L++] = v;
      }
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
        push((tmp & 0xFF0000) >> 16);
        push((tmp & 0xFF00) >> 8);
        push(tmp & 0xFF);
      }
      if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
        push(tmp & 0xFF);
      } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
        push((tmp >> 8) & 0xFF);
        push(tmp & 0xFF);
      }
      return arr;
    }
    function uint8ToBase64(uint8) {
      var i,
          extraBytes = uint8.length % 3,
          output = "",
          temp,
          length;
      function encode(num) {
        return lookup.charAt(num);
      }
      function tripletToBase64(num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
      }
      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output += tripletToBase64(temp);
      }
      switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode((temp << 4) & 0x3F);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
          output += encode(temp >> 10);
          output += encode((temp >> 4) & 0x3F);
          output += encode((temp << 2) & 0x3F);
          output += '=';
          break;
      }
      return output;
    }
    exports.toByteArray = b64ToByteArray;
    exports.fromByteArray = uint8ToBase64;
  }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("220", ["21f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('21f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("221", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e,
        m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e,
        m,
        c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("222", ["221"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('221');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("223", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == '[object Array]';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("117", ["223"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('223');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("224", ["220", "222", "117"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var base64 = $__require('220');
  var ieee754 = $__require('222');
  var isArray = $__require('117');
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192;
  var rootParent = {};
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
  function typedArraySupport() {
    function Bar() {}
    try {
      var arr = new Uint8Array(1);
      arr.foo = function() {
        return 42;
      };
      arr.constructor = Bar;
      return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
    } catch (e) {
      return false;
    }
  }
  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      if (arguments.length > 1)
        return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      this.length = 0;
      this.parent = undefined;
    }
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }
    return fromObject(this, arg);
  }
  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '')
      encoding = 'utf8';
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);
    that.write(string, encoding);
    return that;
  }
  function fromObject(that, object) {
    if (Buffer.isBuffer(object))
      return fromBuffer(that, object);
    if (isArray(object))
      return fromArray(that, object);
    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }
    if (typeof ArrayBuffer !== 'undefined') {
      if (object.buffer instanceof ArrayBuffer) {
        return fromTypedArray(that, object);
      }
      if (object instanceof ArrayBuffer) {
        return fromArrayBuffer(that, object);
      }
    }
    if (object.length)
      return fromArrayLike(that, object);
    return fromJsonObject(that, object);
  }
  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }
  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      array.byteLength;
      that = Buffer._augment(new Uint8Array(array));
    } else {
      that = fromTypedArray(that, new Uint8Array(array));
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromJsonObject(that, object) {
    var array;
    var length = 0;
    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  } else {
    Buffer.prototype.length = undefined;
    Buffer.prototype.parent = undefined;
  }
  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = Buffer._augment(new Uint8Array(length));
      that.__proto__ = Buffer.prototype;
    } else {
      that.length = length;
      that._isBuffer = true;
    }
    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool)
      that.parent = rootParent;
    return that;
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer))
      return new SlowBuffer(subject, encoding);
    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }
  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };
  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i])
        break;
      ++i;
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!isArray(list))
      throw new TypeError('list argument must be an Array of Buffers.');
    if (list.length === 0) {
      return new Buffer(0);
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }
    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };
  function byteLength(string, encoding) {
    if (typeof string !== 'string')
      string = '' + string;
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'ascii':
        case 'binary':
        case 'raw':
        case 'raws':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;
    if (!encoding)
      encoding = 'utf8';
    if (start < 0)
      start = 0;
    if (end > this.length)
      end = this.length;
    if (end <= start)
      return '';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'binary':
          return binarySlice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0)
      return '';
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max)
        str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };
  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return 0;
    return Buffer.compare(this, b);
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff)
      byteOffset = 0x7fffffff;
    else if (byteOffset < -0x80000000)
      byteOffset = -0x80000000;
    byteOffset >>= 0;
    if (this.length === 0)
      return -1;
    if (byteOffset >= this.length)
      return -1;
    if (byteOffset < 0)
      byteOffset = Math.max(this.length + byteOffset, 0);
    if (typeof val === 'string') {
      if (val.length === 0)
        return -1;
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }
    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === val.length)
            return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }
    throw new TypeError('val must be string, number or Buffer');
  };
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new Error('Invalid hex string');
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined)
          encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }
    if (!encoding)
      encoding = 'utf8';
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
          return asciiWrite(this, string, offset, length);
        case 'binary':
          return binaryWrite(this, string, offset, length);
        case 'base64':
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte,
            thirdByte,
            fourthByte,
            tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 0x1000;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }
    if (newBuf.length)
      newBuf.parent = this.parent || this;
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };
  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };
  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
  };
  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
      return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
  }
  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffffffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }
  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
      value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
    if (offset < 0)
      throw new RangeError('index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value)
      value = 0;
    if (!start)
      start = 0;
    if (!end)
      end = this.length;
    if (end < start)
      throw new RangeError('end < start');
    if (end === start)
      return;
    if (this.length === 0)
      return;
    if (start < 0 || start >= this.length)
      throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length)
      throw new RangeError('end out of bounds');
    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }
    return this;
  };
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0,
            len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };
  var BP = Buffer.prototype;
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;
    arr._set = arr.set;
    arr.get = BP.get;
    arr.set = BP.set;
    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;
    return arr;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }
  function toHex(n) {
    if (n < 16)
      return '0' + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; i++) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (!leadSurrogate) {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1)
            bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(0xEF, 0xBF, 0xBD);
      }
      leadSurrogate = null;
      if (codePoint < 0x80) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c,
        hi,
        lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if ((i + offset >= dst.length) || (i >= src.length))
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("225", ["224"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('224');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("226", ["225"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('buffer') : $__require('225');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("72", ["226"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('226');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("227", ["1a4", "1c5", "1c6", "197", "1a2", "1a7", "1c7", "72"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var parseKeys = $__require('1a4');
    var mgf = $__require('1c5');
    var xor = $__require('1c6');
    var bn = $__require('197');
    var crt = $__require('1a2');
    var createHash = $__require('1a7');
    var withPublic = $__require('1c7');
    module.exports = function privateDecrypt(private_key, enc, reverse) {
      var padding;
      if (private_key.padding) {
        padding = private_key.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(private_key);
      var k = key.modulus.byteLength();
      if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
        throw new Error('decryption error');
      }
      var msg;
      if (reverse) {
        msg = withPublic(new bn(enc), key);
      } else {
        msg = crt(enc, key);
      }
      var zBuffer = new Buffer(k - msg.length);
      zBuffer.fill(0);
      msg = Buffer.concat([zBuffer, msg], k);
      if (padding === 4) {
        return oaep(key, msg);
      } else if (padding === 1) {
        return pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        return msg;
      } else {
        throw new Error('unknown padding');
      }
    };
    function oaep(key, msg) {
      var n = key.modulus;
      var k = key.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash('sha1').update(new Buffer('')).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (msg[0] !== 0) {
        throw new Error('decryption error');
      }
      var maskedSeed = msg.slice(1, hLen + 1);
      var maskedDb = msg.slice(hLen + 1);
      var seed = xor(maskedSeed, mgf(maskedDb, hLen));
      var db = xor(maskedDb, mgf(seed, k - hLen - 1));
      if (compare(iHash, db.slice(0, hLen))) {
        throw new Error('decryption error');
      }
      var i = hLen;
      while (db[i] === 0) {
        i++;
      }
      if (db[i++] !== 1) {
        throw new Error('decryption error');
      }
      return db.slice(i);
    }
    function pkcs1(key, msg, reverse) {
      var p1 = msg.slice(0, 2);
      var i = 2;
      var status = 0;
      while (msg[i++] !== 0) {
        if (i >= msg.length) {
          status++;
          break;
        }
      }
      var ps = msg.slice(2, i - 1);
      var p2 = msg.slice(i - 1, i);
      if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
        status++;
      }
      if (ps.length < 8) {
        status++;
      }
      if (status) {
        throw new Error('decryption error');
      }
      return msg.slice(i);
    }
    function compare(a, b) {
      a = new Buffer(a);
      b = new Buffer(b);
      var dif = 0;
      var len = a.length;
      if (a.length !== b.length) {
        dif++;
        len = Math.min(a.length, b.length);
      }
      var i = -1;
      while (++i < len) {
        dif += (a[i] ^ b[i]);
      }
      return dif;
    }
  })($__require('72').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("228", ["1c4", "227"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.publicEncrypt = $__require('1c4');
  exports.privateDecrypt = $__require('227');
  exports.privateEncrypt = function privateEncrypt(key, buf) {
    return exports.publicEncrypt(key, buf, true);
  };
  exports.publicDecrypt = function publicDecrypt(key, buf) {
    return exports.privateDecrypt(key, buf, true);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("229", ["228"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('228');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("22a", ["19a", "1a7", "1a1", "19e", "1f7", "193", "19d", "1a8", "1c3", "229"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = $__require('19a');
  exports.createHash = exports.Hash = $__require('1a7');
  exports.createHmac = exports.Hmac = $__require('1a1');
  var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys($__require('19e')));
  exports.getHashes = function() {
    return hashes;
  };
  var p = $__require('1f7');
  exports.pbkdf2 = p.pbkdf2;
  exports.pbkdf2Sync = p.pbkdf2Sync;
  var aes = $__require('193');
  ;
  ['Cipher', 'createCipher', 'Cipheriv', 'createCipheriv', 'Decipher', 'createDecipher', 'Decipheriv', 'createDecipheriv', 'getCiphers', 'listCiphers'].forEach(function(key) {
    exports[key] = aes[key];
  });
  var dh = $__require('19d');
  ;
  ['DiffieHellmanGroup', 'createDiffieHellmanGroup', 'getDiffieHellman', 'createDiffieHellman', 'DiffieHellman'].forEach(function(key) {
    exports[key] = dh[key];
  });
  var sign = $__require('1a8');
  ;
  ['createSign', 'Sign', 'createVerify', 'Verify'].forEach(function(key) {
    exports[key] = sign[key];
  });
  exports.createECDH = $__require('1c3');
  var publicEncrypt = $__require('229');
  ;
  ['publicEncrypt', 'privateEncrypt', 'publicDecrypt', 'privateDecrypt'].forEach(function(key) {
    exports[key] = publicEncrypt[key];
  });
  ;
  ['createCredentials'].forEach(function(name) {
    exports[name] = function() {
      throw new Error(['sorry, ' + name + ' is not implemented yet', 'we accept pull requests', 'https://github.com/crypto-browserify/crypto-browserify'].join('\n'));
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("22b", ["22a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('22a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("22c", ["22b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('crypto') : $__require('22b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cd", ["22c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('22c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("49", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("22d", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("22e", ["22f", "230", "231", "45", "232", "233"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('22f'),
      call = $__require('230'),
      isArrayIter = $__require('231'),
      anObject = $__require('45'),
      toLength = $__require('232'),
      getIterFn = $__require('233');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4f", ["23", "234", "45", "22f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = $__require('23').getDesc,
      isObject = $__require('234'),
      anObject = $__require('45');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('22f')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("235", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("236", ["45", "237", "44"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('45'),
      aFunction = $__require('237'),
      SPECIES = $__require('44')('species');
  module.exports = function(O, D) {
    var C = anObject(O).constructor,
        S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("238", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("239", ["3b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('3b').document && document.documentElement;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("23a", ["234", "3b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('234'),
      document = $__require('3b').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("23b", ["22f", "238", "239", "23a", "3b", "39", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ctx = $__require('22f'),
        invoke = $__require('238'),
        html = $__require('239'),
        cel = $__require('23a'),
        global = $__require('3b'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('39')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("23c", ["3b", "23b", "39", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = $__require('3b'),
        macrotask = $__require('23b').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = $__require('39')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain,
          fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain)
          domain.enter();
        fn();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function() {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("23d", ["3f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var redefine = $__require('3f');
  module.exports = function(target, src) {
    for (var key in src)
      redefine(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("23e", ["4a", "23", "3d", "44"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = $__require('4a'),
      $ = $__require('23'),
      DESCRIPTORS = $__require('3d'),
      SPECIES = $__require('44')('species');
  module.exports = function(KEY) {
    var C = core[KEY];
    if (DESCRIPTORS && C && !C[SPECIES])
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("23f", ["23", "47", "3b", "22f", "240", "3e", "234", "45", "237", "22d", "22e", "4f", "235", "44", "236", "23c", "3d", "23d", "42", "23e", "4a", "241", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = $__require('23'),
        LIBRARY = $__require('47'),
        global = $__require('3b'),
        ctx = $__require('22f'),
        classof = $__require('240'),
        $export = $__require('3e'),
        isObject = $__require('234'),
        anObject = $__require('45'),
        aFunction = $__require('237'),
        strictNew = $__require('22d'),
        forOf = $__require('22e'),
        setProto = $__require('4f').set,
        same = $__require('235'),
        SPECIES = $__require('44')('species'),
        speciesConstructor = $__require('236'),
        asap = $__require('23c'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var USE_NATIVE = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('3d')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function(C) {
      var resolve,
          reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined)
          throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function(exec) {
      try {
        exec();
      } catch (e) {
        return {error: e};
      }
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok)
                record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else
                resolve(result);
            } else
              reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h)
        return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value)
          throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('23d')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a)
            record.a.push(reaction);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
    $__require('42')(P, PROMISE);
    $__require('23e')(PROMISE);
    Wrapper = $__require('4a')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, {reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      }});
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this))
          return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      }});
    $export($export.S + $export.F * !(USE_NATIVE && $__require('241')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function() {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              var alreadyCalled = false;
              C.resolve(promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                results[index] = value;
                --remaining || resolve(results);
              }, reject);
            });
          else
            resolve(results);
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function() {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      }
    });
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("242", ["49", "243", "244", "23f", "4a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('49');
  $__require('243');
  $__require('244');
  $__require('23f');
  module.exports = $__require('4a').Promise;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("34", ["242"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('242'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("245", ["246", "247", "248"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.NOT_ITERATOR_ERROR = undefined;
  exports.storeIO = storeIO;
  exports.runSaga = runSaga;
  var _utils = $__require('246');
  var _proc = $__require('247');
  var _proc2 = _interopRequireDefault(_proc);
  var _emitter = $__require('248');
  var _emitter2 = _interopRequireDefault(_emitter);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var NOT_ITERATOR_ERROR = exports.NOT_ITERATOR_ERROR = "runSaga must be called on an iterator";
  var IO = (0, _utils.sym)('IO');
  function storeIO(store) {
    (0, _utils.warnDeprecated)('storeIO is deprecated, to run Saga dynamically, use \'run\' method of the middleware');
    if (store[IO])
      return store[IO];
    var storeEmitter = (0, _emitter2.default)();
    var _dispatch = store.dispatch;
    store.dispatch = function(action) {
      var result = _dispatch(action);
      storeEmitter.emit(action);
      return result;
    };
    store[IO] = {
      subscribe: storeEmitter.subscribe,
      dispatch: store.dispatch,
      getState: store.getState
    };
    return store[IO];
  }
  function runSaga(iterator, _ref) {
    var subscribe = _ref.subscribe;
    var dispatch = _ref.dispatch;
    var getState = _ref.getState;
    var monitor = arguments.length <= 2 || arguments[2] === undefined ? _utils.noop : arguments[2];
    (0, _utils.check)(iterator, _utils.is.iterator, NOT_ITERATOR_ERROR);
    return (0, _proc2.default)(iterator, subscribe, dispatch, getState, monitor);
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("249", ["246", "24a", "24b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  exports.takeEvery = takeEvery;
  exports.takeLatest = takeLatest;
  var _utils = $__require('246');
  var _io = $__require('24a');
  var _SagaCancellationException = $__require('24b');
  var _SagaCancellationException2 = _interopRequireDefault(_SagaCancellationException);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var resume = function resume(fnOrValue, arg) {
    return _utils.is.func(fnOrValue) ? fnOrValue(arg) : fnOrValue;
  };
  var done = {done: true};
  function fsmIterator(fsm, nextState) {
    var name = arguments.length <= 2 || arguments[2] === undefined ? 'iterator' : arguments[2];
    var aborted = undefined,
        updateState = undefined;
    function next(arg, error) {
      if (aborted)
        return done;
      if (error) {
        aborted = true;
        if (!(error instanceof _SagaCancellationException2.default))
          throw error;
        return done;
      } else {
        if (updateState)
          updateState(arg);
        var _fsm$nextState = _slicedToArray(fsm[nextState], 3);
        var output = _fsm$nextState[0];
        var transition = _fsm$nextState[1];
        var _updateState = _fsm$nextState[2];
        updateState = _updateState;
        nextState = resume(transition, arg);
        return resume(output, arg);
      }
    }
    var iterator = {
      name: name,
      next: next,
      throw: function _throw(error) {
        return next(null, error);
      }
    };
    if (typeof Symbol !== 'undefined') {
      iterator[Symbol.iterator] = function() {
        return iterator;
      };
    }
    return iterator;
  }
  function takeEvery(pattern, worker) {
    for (var _len = arguments.length,
        args = Array(_len > 2 ? _len - 2 : 0),
        _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    var yieldTake = {
      done: false,
      value: (0, _io.take)(pattern)
    };
    var yieldFork = function yieldFork(action) {
      return {
        done: false,
        value: _io.fork.apply(undefined, [worker].concat(args, [action]))
      };
    };
    return fsmIterator({
      'take': [yieldTake, 'fork'],
      'fork': [yieldFork, 'take']
    }, 'take', 'takeEvery(' + pattern + ', ' + worker.name + ')');
  }
  function takeLatest(pattern, worker) {
    for (var _len2 = arguments.length,
        args = Array(_len2 > 2 ? _len2 - 2 : 0),
        _key2 = 2; _key2 < _len2; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }
    var yieldTake = {
      done: false,
      value: (0, _io.take)(pattern)
    };
    var yieldFork = function yieldFork() {
      return {
        done: false,
        value: _io.fork.apply(undefined, [worker].concat(args, [currentAction]))
      };
    };
    var yieldCancel = function yieldCancel() {
      return {
        done: false,
        value: (0, _io.cancel)(currentTask)
      };
    };
    var forkOrCancel = function forkOrCancel() {
      return currentTask ? 'cancel' : 'fork';
    };
    var currentTask = undefined,
        currentAction = undefined;
    return fsmIterator({
      'take': [yieldTake, forkOrCancel, function(action) {
        return currentAction = action;
      }],
      'cancel': [yieldCancel, 'fork'],
      'fork': [yieldFork, 'take', function(task) {
        return currentTask = task;
      }]
    }, 'take', 'takeLatest(' + pattern + ', ' + worker.name + ')');
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("248", ["246"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.default = emitter;
  var _utils = $__require('246');
  function emitter() {
    var cbs = [];
    function subscribe(cb) {
      cbs.push(cb);
      return function() {
        return (0, _utils.remove)(cbs, cb);
      };
    }
    function emit(item) {
      cbs.slice().forEach(function(cb) {
        return cb(item);
      });
    }
    return {
      subscribe: subscribe,
      emit: emit
    };
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("24c", ["246", "247", "248", "24d", "24b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.GET_STATE_DEPRECATED_WARNING = exports.RUN_SAGA_DYNAMIC_ERROR = exports.sagaArgError = undefined;
  exports.default = sagaMiddlewareFactory;
  var _utils = $__require('246');
  var _proc = $__require('247');
  var _proc2 = _interopRequireDefault(_proc);
  var _emitter = $__require('248');
  var _emitter2 = _interopRequireDefault(_emitter);
  var _monitorActions = $__require('24d');
  var _SagaCancellationException = $__require('24b');
  var _SagaCancellationException2 = _interopRequireDefault(_SagaCancellationException);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var sagaArgError = exports.sagaArgError = function sagaArgError(fn, pos, saga) {
    return '\n  ' + fn + ' can only be called on Generator functions\n  Argument ' + saga + ' at position ' + pos + ' is not function!\n';
  };
  var RUN_SAGA_DYNAMIC_ERROR = exports.RUN_SAGA_DYNAMIC_ERROR = 'Before running a Saga dynamically using middleware.run, you must mount the Saga middleware on the Store using applyMiddleware';
  var GET_STATE_DEPRECATED_WARNING = exports.GET_STATE_DEPRECATED_WARNING = '\n  Using the \'getState\' param of Sagas to access the state is deprecated since 0.9.1\n  To access the Store\'s state use \'yield select()\' instead\n  For more infos see http://yelouafi.github.io/redux-saga/docs/api/index.html#selectselector-args\n';
  function sagaMiddlewareFactory() {
    for (var _len = arguments.length,
        sagas = Array(_len),
        _key = 0; _key < _len; _key++) {
      sagas[_key] = arguments[_key];
    }
    var runSagaDynamically = undefined;
    sagas.forEach(function(saga, idx) {
      return (0, _utils.check)(saga, _utils.is.func, sagaArgError('createSagaMiddleware', idx, saga));
    });
    function sagaMiddleware(_ref) {
      var getState = _ref.getState;
      var dispatch = _ref.dispatch;
      var sagaEmitter = (0, _emitter2.default)();
      var monitor = _utils.isDev ? function(action) {
        return (0, _utils.asap)(function() {
          return dispatch(action);
        });
      } : undefined;
      var getStateDeprecated = function getStateDeprecated() {
        (0, _utils.warnDeprecated)(GET_STATE_DEPRECATED_WARNING);
        return getState();
      };
      function runSaga(saga) {
        for (var _len2 = arguments.length,
            args = Array(_len2 > 1 ? _len2 - 1 : 0),
            _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        return (0, _proc2.default)(saga.apply(undefined, [getStateDeprecated].concat(args)), sagaEmitter.subscribe, dispatch, getState, monitor, 0, saga.name);
      }
      runSagaDynamically = runSaga;
      sagas.forEach(runSaga);
      return function(next) {
        return function(action) {
          var result = next(action);
          if (!action[_monitorActions.MONITOR_ACTION])
            sagaEmitter.emit(action);
          return result;
        };
      };
    }
    sagaMiddleware.run = function(saga) {
      for (var _len3 = arguments.length,
          args = Array(_len3 > 1 ? _len3 - 1 : 0),
          _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      if (!runSagaDynamically) {
        throw new Error(RUN_SAGA_DYNAMIC_ERROR);
      }
      (0, _utils.check)(saga, _utils.is.func, sagaArgError('sagaMiddleware.run', 0, saga));
      var task = runSagaDynamically.apply(undefined, [saga].concat(args));
      task.done.catch(function(err) {
        if (!(err instanceof _SagaCancellationException2.default))
          throw err;
      });
      return task;
    };
    return sagaMiddleware;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("24e", ["24a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.select = exports.cancel = exports.join = exports.fork = exports.cps = exports.apply = exports.call = exports.race = exports.put = exports.take = undefined;
  var _io = $__require('24a');
  exports.take = _io.take;
  exports.put = _io.put;
  exports.race = _io.race;
  exports.call = _io.call;
  exports.apply = _io.apply;
  exports.cps = _io.cps;
  exports.fork = _io.fork;
  exports.join = _io.join;
  exports.cancel = _io.cancel;
  exports.select = _io.select;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("24a", ["246"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.asEffect = exports.SELECT_ARG_ERROR = exports.INVALID_PATTERN = exports.CANCEL_ARG_ERROR = exports.JOIN_ARG_ERROR = exports.FORK_ARG_ERROR = exports.CALL_FUNCTION_ARG_ERROR = undefined;
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  exports.matcher = matcher;
  exports.take = take;
  exports.put = put;
  exports.race = race;
  exports.call = call;
  exports.apply = apply;
  exports.cps = cps;
  exports.fork = fork;
  exports.join = join;
  exports.cancel = cancel;
  exports.select = select;
  var _utils = $__require('246');
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var CALL_FUNCTION_ARG_ERROR = exports.CALL_FUNCTION_ARG_ERROR = "call/cps/fork first argument must be a function, an array [context, function] or an object {context, fn}";
  var FORK_ARG_ERROR = exports.FORK_ARG_ERROR = "fork first argument must be a generator function or an iterator";
  var JOIN_ARG_ERROR = exports.JOIN_ARG_ERROR = "join argument must be a valid task (a result of a fork)";
  var CANCEL_ARG_ERROR = exports.CANCEL_ARG_ERROR = "cancel argument must be a valid task (a result of a fork)";
  var INVALID_PATTERN = exports.INVALID_PATTERN = "Invalid pattern passed to `take` (HINT: check if you didn't mispell a constant)";
  var SELECT_ARG_ERROR = exports.SELECT_ARG_ERROR = "select first argument must be a function";
  var IO = (0, _utils.sym)('IO');
  var TAKE = 'TAKE';
  var PUT = 'PUT';
  var RACE = 'RACE';
  var CALL = 'CALL';
  var CPS = 'CPS';
  var FORK = 'FORK';
  var JOIN = 'JOIN';
  var CANCEL = 'CANCEL';
  var SELECT = 'SELECT';
  var effect = function effect(type, payload) {
    var _ref;
    return _ref = {}, _defineProperty(_ref, IO, true), _defineProperty(_ref, type, payload), _ref;
  };
  var matchers = {
    wildcard: function wildcard() {
      return _utils.kTrue;
    },
    default: function _default(pattern) {
      return function(input) {
        return input.type === pattern;
      };
    },
    array: function array(patterns) {
      return function(input) {
        return patterns.some(function(p) {
          return p === input.type;
        });
      };
    },
    predicate: function predicate(_predicate) {
      return function(input) {
        return _predicate(input);
      };
    }
  };
  function matcher(pattern) {
    return (pattern === '*' ? matchers.wildcard : _utils.is.array(pattern) ? matchers.array : _utils.is.func(pattern) ? matchers.predicate : matchers.default)(pattern);
  }
  function take(pattern) {
    if (arguments.length > 0 && _utils.is.undef(pattern)) {
      throw new Error(INVALID_PATTERN);
    }
    return effect(TAKE, _utils.is.undef(pattern) ? '*' : pattern);
  }
  function put(action) {
    return effect(PUT, action);
  }
  function race(effects) {
    return effect(RACE, effects);
  }
  function getFnCallDesc(fn, args) {
    (0, _utils.check)(fn, _utils.is.notUndef, CALL_FUNCTION_ARG_ERROR);
    var context = null;
    if (_utils.is.array(fn)) {
      var _fn = fn;
      var _fn2 = _slicedToArray(_fn, 2);
      context = _fn2[0];
      fn = _fn2[1];
    } else if (fn.fn) {
      var _fn3 = fn;
      context = _fn3.context;
      fn = _fn3.fn;
    }
    (0, _utils.check)(fn, _utils.is.func, CALL_FUNCTION_ARG_ERROR);
    return {
      context: context,
      fn: fn,
      args: args
    };
  }
  function call(fn) {
    for (var _len = arguments.length,
        args = Array(_len > 1 ? _len - 1 : 0),
        _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return effect(CALL, getFnCallDesc(fn, args));
  }
  function apply(context, fn) {
    var args = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
    return effect(CALL, getFnCallDesc({
      context: context,
      fn: fn
    }, args));
  }
  function cps(fn) {
    for (var _len2 = arguments.length,
        args = Array(_len2 > 1 ? _len2 - 1 : 0),
        _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return effect(CPS, getFnCallDesc(fn, args));
  }
  function fork(fn) {
    for (var _len3 = arguments.length,
        args = Array(_len3 > 1 ? _len3 - 1 : 0),
        _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return effect(FORK, getFnCallDesc(fn, args));
  }
  var isForkedTask = function isForkedTask(task) {
    return task[_utils.TASK];
  };
  function join(taskDesc) {
    if (!isForkedTask(taskDesc))
      throw new Error(JOIN_ARG_ERROR);
    return effect(JOIN, taskDesc);
  }
  function cancel(taskDesc) {
    if (!isForkedTask(taskDesc))
      throw new Error(CANCEL_ARG_ERROR);
    return effect(CANCEL, taskDesc);
  }
  function select(selector) {
    for (var _len4 = arguments.length,
        args = Array(_len4 > 1 ? _len4 - 1 : 0),
        _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }
    if (arguments.length === 0) {
      selector = _utils.ident;
    } else {
      (0, _utils.check)(selector, _utils.is.func, SELECT_ARG_ERROR);
    }
    return effect(SELECT, {
      selector: selector,
      args: args
    });
  }
  var asEffect = exports.asEffect = {
    take: function take(effect) {
      return effect && effect[IO] && effect[TAKE];
    },
    put: function put(effect) {
      return effect && effect[IO] && effect[PUT];
    },
    race: function race(effect) {
      return effect && effect[IO] && effect[RACE];
    },
    call: function call(effect) {
      return effect && effect[IO] && effect[CALL];
    },
    cps: function cps(effect) {
      return effect && effect[IO] && effect[CPS];
    },
    fork: function fork(effect) {
      return effect && effect[IO] && effect[FORK];
    },
    join: function join(effect) {
      return effect && effect[IO] && effect[JOIN];
    },
    cancel: function cancel(effect) {
      return effect && effect[IO] && effect[CANCEL];
    },
    select: function select(effect) {
      return effect && effect[IO] && effect[SELECT];
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("24b", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.default = SagaCancellationException;
  function SagaCancellationException(type, saga, origin) {
    var message = 'SagaCancellationException; type: ' + type + ', saga: ' + saga + ', origin: ' + origin;
    this.name = 'SagaCancellationException';
    this.message = message;
    this.type = type;
    this.saga = saga;
    this.origin = origin;
    this.stack = new Error().stack;
  }
  SagaCancellationException.prototype = Object.create(Error.prototype);
  SagaCancellationException.prototype.constructor = SagaCancellationException;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("247", ["246", "24a", "24d", "24b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.MANUAL_CANCEL = exports.RACE_AUTO_CANCEL = exports.PARALLEL_AUTO_CANCEL = exports.CANCEL = exports.undefindInputError = exports.NOT_ITERATOR_ERROR = undefined;
  exports.default = proc;
  var _utils = $__require('246');
  var _io = $__require('24a');
  var _monitorActions = $__require('24d');
  var monitorActions = _interopRequireWildcard(_monitorActions);
  var _SagaCancellationException = $__require('24b');
  var _SagaCancellationException2 = _interopRequireDefault(_SagaCancellationException);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var NOT_ITERATOR_ERROR = exports.NOT_ITERATOR_ERROR = 'proc first argument (Saga function result) must be an iterator';
  var undefindInputError = exports.undefindInputError = function undefindInputError(name) {
    return '\n  ' + name + ' saga was provided with an undefined input action\n  Hints :\n  - check that your Action Creator returns a non undefined value\n  - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners\n';
  };
  var CANCEL = exports.CANCEL = (0, _utils.sym)('@@redux-saga/cancelPromise');
  var PARALLEL_AUTO_CANCEL = exports.PARALLEL_AUTO_CANCEL = 'PARALLEL_AUTO_CANCEL';
  var RACE_AUTO_CANCEL = exports.RACE_AUTO_CANCEL = 'RACE_AUTO_CANCEL';
  var MANUAL_CANCEL = exports.MANUAL_CANCEL = 'MANUAL_CANCEL';
  var nextEffectId = (0, _utils.autoInc)();
  function proc(iterator) {
    var subscribe = arguments.length <= 1 || arguments[1] === undefined ? function() {
      return _utils.noop;
    } : arguments[1];
    var dispatch = arguments.length <= 2 || arguments[2] === undefined ? _utils.noop : arguments[2];
    var getState = arguments.length <= 3 || arguments[3] === undefined ? _utils.noop : arguments[3];
    var monitor = arguments.length <= 4 || arguments[4] === undefined ? _utils.noop : arguments[4];
    var parentEffectId = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];
    var name = arguments.length <= 6 || arguments[6] === undefined ? 'anonymous' : arguments[6];
    var forked = arguments[7];
    (0, _utils.check)(iterator, _utils.is.iterator, NOT_ITERATOR_ERROR);
    var UNDEFINED_INPUT_ERROR = undefindInputError(name);
    var deferredInputs = [];
    var deferredEnd = (0, _utils.deferred)();
    var unsubscribe = subscribe(function(input) {
      if (input === undefined)
        throw UNDEFINED_INPUT_ERROR;
      for (var i = 0; i < deferredInputs.length; i++) {
        var def = deferredInputs[i];
        if (def.match(input)) {
          deferredInputs = [];
          def.resolve(input);
        }
      }
    });
    next.cancel = _utils.noop;
    var task = newTask(parentEffectId, name, iterator, deferredEnd.promise, forked);
    task.done[CANCEL] = function(_ref) {
      var type = _ref.type;
      var origin = _ref.origin;
      next.cancel(new _SagaCancellationException2.default(type, name, origin));
    };
    iterator._isRunning = true;
    next();
    return task;
    function logError(level, message, error) {
      if (typeof window === 'undefined') {
        console.log('redux-saga ' + level + ': ' + message + '\n' + error.stack);
      } else {
        console[level].call(console, message, error);
      }
    }
    function next(error, arg) {
      if (!iterator._isRunning)
        throw new Error('Trying to resume an already finished generator');
      try {
        var result = error ? iterator.throw(error) : iterator.next(arg);
        if (!result.done) {
          runEffect(result.value, parentEffectId, '', next);
        } else {
          end(result.value);
        }
      } catch (error) {
        end(error, true);
        if (error instanceof _SagaCancellationException2.default) {
          if (_utils.isDev) {
            logError('warn', name + ': uncaught', error);
          }
        } else {
          logError('error', name + ': uncaught', error);
        }
      }
    }
    function end(result, isError) {
      iterator._isRunning = false;
      if (!isError) {
        iterator._result = result;
        deferredEnd.resolve(result);
      } else {
        iterator._error = result;
        deferredEnd.reject(result);
      }
      unsubscribe();
    }
    function runEffect(effect, parentEffectId) {
      var label = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];
      var cb = arguments[3];
      var effectId = nextEffectId();
      monitor(monitorActions.effectTriggered(effectId, parentEffectId, label, effect));
      var effectSettled = undefined;
      function currCb(err, res) {
        if (effectSettled)
          return;
        effectSettled = true;
        cb.cancel = _utils.noop;
        err ? monitor(monitorActions.effectRejected(effectId, err)) : monitor(monitorActions.effectResolved(effectId, res));
        cb(err, res);
      }
      currCb.cancel = _utils.noop;
      cb.cancel = function(cancelError) {
        if (effectSettled)
          return;
        effectSettled = true;
        try {
          currCb.cancel(cancelError);
        } catch (err) {
          void 0;
        }
        currCb.cancel = _utils.noop;
        cb(cancelError);
        monitor(monitorActions.effectRejected(effectId, cancelError));
      };
      var data = undefined;
      return (_utils.is.promise(effect) ? resolvePromise(effect, currCb) : _utils.is.iterator(effect) ? resolveIterator(effect, effectId, name, currCb) : _utils.is.array(effect) ? runParallelEffect(effect, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.take(effect)) ? runTakeEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.put(effect)) ? runPutEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.race(effect)) ? runRaceEffect(data, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.call(effect)) ? runCallEffect(data, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.cps(effect)) ? runCPSEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.fork(effect)) ? runForkEffect(data, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.join(effect)) ? runJoinEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.cancel(effect)) ? runCancelEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.select(effect)) ? runSelectEffect(data, currCb) : currCb(null, effect));
    }
    function resolvePromise(promise, cb) {
      var cancelPromise = promise[CANCEL];
      if (typeof cancelPromise === 'function') {
        cb.cancel = cancelPromise;
      }
      promise.then(function(result) {
        return cb(null, result);
      }, function(error) {
        return cb(error);
      });
    }
    function resolveIterator(iterator, effectId, name, cb) {
      resolvePromise(proc(iterator, subscribe, dispatch, getState, monitor, effectId, name).done, cb);
    }
    function runTakeEffect(pattern, cb) {
      var def = {
        match: (0, _io.matcher)(pattern),
        pattern: pattern,
        resolve: function resolve(input) {
          return cb(null, input);
        }
      };
      deferredInputs.push(def);
      cb.cancel = function() {
        return (0, _utils.remove)(deferredInputs, def);
      };
    }
    function runPutEffect(action, cb) {
      (0, _utils.asap)(function() {
        return cb(null, dispatch(action));
      });
    }
    function runCallEffect(_ref2, effectId, cb) {
      var context = _ref2.context;
      var fn = _ref2.fn;
      var args = _ref2.args;
      var result = undefined;
      try {
        result = fn.apply(context, args);
      } catch (error) {
        return cb(error);
      }
      return _utils.is.promise(result) ? resolvePromise(result, cb) : _utils.is.iterator(result) ? resolveIterator(result, effectId, fn.name, cb) : cb(null, result);
    }
    function runCPSEffect(_ref3, cb) {
      var context = _ref3.context;
      var fn = _ref3.fn;
      var args = _ref3.args;
      try {
        fn.apply(context, args.concat(cb));
      } catch (error) {
        return cb(error);
      }
    }
    function runForkEffect(_ref4, effectId, cb) {
      var context = _ref4.context;
      var fn = _ref4.fn;
      var args = _ref4.args;
      var result = undefined,
          error = undefined,
          _iterator = undefined;
      try {
        result = fn.apply(context, args);
      } catch (err) {
        error = err;
      }
      if (_utils.is.iterator(result)) {
        _iterator = result;
      } else {
        _iterator = (error ? regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  throw error;
                case 1:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }) : regeneratorRuntime.mark(function _callee2() {
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return result;
                case 2:
                  return _context2.abrupt('return', _context2.sent);
                case 3:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }))();
      }
      cb(null, proc(_iterator, subscribe, dispatch, getState, monitor, effectId, fn.name, true));
    }
    function runJoinEffect(task, cb) {
      resolvePromise(task.done, cb);
    }
    function runCancelEffect(task, cb) {
      task.done[CANCEL](new _SagaCancellationException2.default(MANUAL_CANCEL, name, name));
      cb();
    }
    function runParallelEffect(effects, effectId, cb) {
      if (!effects.length) {
        cb(null, []);
        return;
      }
      var completedCount = 0;
      var completed = undefined;
      var results = Array(effects.length);
      function checkEffectEnd() {
        if (completedCount === results.length) {
          completed = true;
          cb(null, results);
        }
      }
      var childCbs = effects.map(function(eff, idx) {
        var chCbAtIdx = function chCbAtIdx(err, res) {
          if (completed)
            return;
          if (err) {
            try {
              cb.cancel(new _SagaCancellationException2.default(PARALLEL_AUTO_CANCEL, name, name));
            } catch (err) {
              void 0;
            }
            cb(err);
          } else {
            results[idx] = res;
            completedCount++;
            checkEffectEnd();
          }
        };
        chCbAtIdx.cancel = _utils.noop;
        return chCbAtIdx;
      });
      cb.cancel = function(cancelError) {
        if (!completed) {
          completed = true;
          childCbs.forEach(function(chCb) {
            return chCb.cancel(cancelError);
          });
        }
      };
      effects.forEach(function(eff, idx) {
        return runEffect(eff, effectId, idx, childCbs[idx]);
      });
    }
    function runRaceEffect(effects, effectId, cb) {
      var completed = undefined;
      var keys = Object.keys(effects);
      var childCbs = {};
      keys.forEach(function(key) {
        var chCbAtKey = function chCbAtKey(err, res) {
          if (completed)
            return;
          if (err) {
            try {
              cb.cancel(new _SagaCancellationException2.default(RACE_AUTO_CANCEL, name, name));
            } catch (err) {
              void 0;
            }
            cb(_defineProperty({}, key, err));
          } else {
            try {
              cb.cancel(new _SagaCancellationException2.default(RACE_AUTO_CANCEL, name, name));
            } catch (err) {
              void 0;
            }
            completed = true;
            cb(null, _defineProperty({}, key, res));
          }
        };
        chCbAtKey.cancel = _utils.noop;
        childCbs[key] = chCbAtKey;
      });
      cb.cancel = function(cancelError) {
        if (!completed) {
          completed = true;
          keys.forEach(function(key) {
            return childCbs[key].cancel(cancelError);
          });
        }
      };
      keys.forEach(function(key) {
        return runEffect(effects[key], effectId, key, childCbs[key]);
      });
    }
    function runSelectEffect(_ref5, cb) {
      var selector = _ref5.selector;
      var args = _ref5.args;
      try {
        var state = selector.apply(undefined, [getState()].concat(_toConsumableArray(args)));
        cb(null, state);
      } catch (error) {
        cb(error);
      }
    }
    function newTask(id, name, iterator, done, forked) {
      var _ref6;
      return _ref6 = {}, _defineProperty(_ref6, _utils.TASK, true), _defineProperty(_ref6, 'id', id), _defineProperty(_ref6, 'name', name), _defineProperty(_ref6, 'done', done), _defineProperty(_ref6, 'forked', forked), _defineProperty(_ref6, 'cancel', function cancel(error) {
        if (!(error instanceof _SagaCancellationException2.default)) {
          error = new _SagaCancellationException2.default(MANUAL_CANCEL, name, error);
        }
        done[CANCEL](error);
      }), _defineProperty(_ref6, 'isRunning', function isRunning() {
        return iterator._isRunning;
      }), _defineProperty(_ref6, 'result', function result() {
        return iterator._result;
      }), _defineProperty(_ref6, 'error', function error() {
        return iterator._error;
      }), _ref6;
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("246", ["9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    Object.defineProperty(exports, "__esModule", {value: true});
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    exports.ident = ident;
    exports.check = check;
    exports.remove = remove;
    exports.deferred = deferred;
    exports.arrayOfDeffered = arrayOfDeffered;
    exports.autoInc = autoInc;
    exports.asap = asap;
    exports.warnDeprecated = warnDeprecated;
    var sym = exports.sym = function sym(id) {
      return '@@redux-saga/' + id;
    };
    var TASK = exports.TASK = sym('TASK');
    var kTrue = exports.kTrue = function kTrue() {
      return true;
    };
    var noop = exports.noop = function noop() {};
    function ident(v) {
      return v;
    }
    var isDev = exports.isDev = typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'development';
    function check(value, predicate, error) {
      if (!predicate(value))
        throw new Error(error);
    }
    var is = exports.is = {
      undef: function undef(v) {
        return v === null || v === undefined;
      },
      notUndef: function notUndef(v) {
        return v !== null && v !== undefined;
      },
      func: function func(f) {
        return typeof f === 'function';
      },
      array: Array.isArray,
      promise: function promise(p) {
        return p && is.func(p.then);
      },
      iterator: function iterator(it) {
        return it && is.func(it.next) && is.func(it.throw);
      },
      task: function task(it) {
        return it && it[TASK];
      }
    };
    function remove(array, item) {
      var index = array.indexOf(item);
      if (index >= 0)
        array.splice(index, 1);
    }
    function deferred() {
      var props = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var def = _extends({}, props);
      var promise = new Promise(function(resolve, reject) {
        def.resolve = resolve;
        def.reject = reject;
      });
      def.promise = promise;
      return def;
    }
    function arrayOfDeffered(length) {
      var arr = [];
      for (var i = 0; i < length; i++) {
        arr.push(deferred());
      }
      return arr;
    }
    function autoInc() {
      var seed = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
      return function() {
        return ++seed;
      };
    }
    function asap(action) {
      return Promise.resolve(1).then(function() {
        return action();
      });
    }
    function warnDeprecated(msg) {
      if (isDev) {
        console.warn('DEPRECATION WARNING', msg);
      }
    }
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("24f", ["246"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.createMockTask = createMockTask;
  var _utils = $__require('246');
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function createMockTask() {
    var _ref;
    var running = true;
    var _result = undefined,
        _error = undefined;
    return _ref = {}, _defineProperty(_ref, _utils.TASK, true), _defineProperty(_ref, 'isRunning', function isRunning() {
      return running;
    }), _defineProperty(_ref, 'result', function result() {
      return _result;
    }), _defineProperty(_ref, 'error', function error() {
      return _error;
    }), _defineProperty(_ref, 'setRunning', function setRunning(b) {
      return running = b;
    }), _defineProperty(_ref, 'setResult', function setResult(r) {
      return _result = r;
    }), _defineProperty(_ref, 'setError', function setError(e) {
      return _error = e;
    }), _ref;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("24d", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.effectTriggered = effectTriggered;
  exports.effectResolved = effectResolved;
  exports.effectRejected = effectRejected;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var MONITOR_ACTION = exports.MONITOR_ACTION = 'MONITOR_ACTION';
  var EFFECT_TRIGGERED = exports.EFFECT_TRIGGERED = 'EFFECT_TRIGGERED';
  var EFFECT_RESOLVED = exports.EFFECT_RESOLVED = 'EFFECT_RESOLVED';
  var EFFECT_REJECTED = exports.EFFECT_REJECTED = 'EFFECT_REJECTED';
  function effectTriggered(effectId, parentEffectId, label, effect) {
    var _ref;
    return _ref = {}, _defineProperty(_ref, MONITOR_ACTION, true), _defineProperty(_ref, 'type', EFFECT_TRIGGERED), _defineProperty(_ref, 'effectId', effectId), _defineProperty(_ref, 'parentEffectId', parentEffectId), _defineProperty(_ref, 'label', label), _defineProperty(_ref, 'effect', effect), _ref;
  }
  function effectResolved(effectId, result) {
    var _ref2;
    return _ref2 = {}, _defineProperty(_ref2, MONITOR_ACTION, true), _defineProperty(_ref2, 'type', EFFECT_RESOLVED), _defineProperty(_ref2, 'effectId', effectId), _defineProperty(_ref2, 'result', result), _ref2;
  }
  function effectRejected(effectId, error) {
    var _ref3;
    return _ref3 = {}, _defineProperty(_ref3, MONITOR_ACTION, true), _defineProperty(_ref3, 'type', EFFECT_REJECTED), _defineProperty(_ref3, 'effectId', effectId), _defineProperty(_ref3, 'error', error), _ref3;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("250", ["246", "24a", "247", "24f", "24d"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.monitorActions = exports.createMockTask = exports.MANUAL_CANCEL = exports.PARALLEL_AUTO_CANCEL = exports.RACE_AUTO_CANCEL = exports.CANCEL = exports.asap = exports.arrayOfDeffered = exports.deferred = exports.asEffect = exports.is = exports.noop = exports.TASK = undefined;
  var _utils = $__require('246');
  var _io = $__require('24a');
  var _proc = $__require('247');
  var _testUtils = $__require('24f');
  var _monitorActions = $__require('24d');
  var monitorActions = _interopRequireWildcard(_monitorActions);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  exports.TASK = _utils.TASK;
  exports.noop = _utils.noop;
  exports.is = _utils.is;
  exports.asEffect = _io.asEffect;
  exports.deferred = _utils.deferred;
  exports.arrayOfDeffered = _utils.arrayOfDeffered;
  exports.asap = _utils.asap;
  exports.CANCEL = _proc.CANCEL;
  exports.RACE_AUTO_CANCEL = _proc.RACE_AUTO_CANCEL;
  exports.PARALLEL_AUTO_CANCEL = _proc.PARALLEL_AUTO_CANCEL;
  exports.MANUAL_CANCEL = _proc.MANUAL_CANCEL;
  exports.createMockTask = _testUtils.createMockTask;
  exports.monitorActions = monitorActions;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("251", ["245", "249", "24c", "24b", "24e", "250"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.utils = exports.effects = exports.takeLatest = exports.takeEvery = exports.storeIO = exports.runSaga = exports.isCancelError = exports.SagaCancellationException = undefined;
  var _runSaga = $__require('245');
  Object.defineProperty(exports, 'runSaga', {
    enumerable: true,
    get: function get() {
      return _runSaga.runSaga;
    }
  });
  Object.defineProperty(exports, 'storeIO', {
    enumerable: true,
    get: function get() {
      return _runSaga.storeIO;
    }
  });
  var _sagaHelpers = $__require('249');
  Object.defineProperty(exports, 'takeEvery', {
    enumerable: true,
    get: function get() {
      return _sagaHelpers.takeEvery;
    }
  });
  Object.defineProperty(exports, 'takeLatest', {
    enumerable: true,
    get: function get() {
      return _sagaHelpers.takeLatest;
    }
  });
  var _middleware = $__require('24c');
  var _middleware2 = _interopRequireDefault(_middleware);
  var _SagaCancellationException2 = $__require('24b');
  var _SagaCancellationException3 = _interopRequireDefault(_SagaCancellationException2);
  var _effects = $__require('24e');
  var effects = _interopRequireWildcard(_effects);
  var _utils = $__require('250');
  var utils = _interopRequireWildcard(_utils);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  exports.default = _middleware2.default;
  var SagaCancellationException = exports.SagaCancellationException = _SagaCancellationException3.default;
  var isCancelError = exports.isCancelError = function isCancelError(error) {
    return error instanceof SagaCancellationException;
  };
  exports.effects = effects;
  exports.utils = utils;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2e", ["251"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('251');
  global.define = __define;
  return module.exports;
});

$__System.register('33', ['34', '2e'], function (_export) {
  var _Promise, utils, CANCEL, cancellablePromise, delayedResolve;

  return {
    setters: [function (_) {
      _Promise = _['default'];
    }, function (_e) {
      utils = _e.utils;
    }],
    execute: function () {
      /* eslint no-param-reassign: [2, {"props": false }] */
      'use strict';

      CANCEL = utils.CANCEL;

      cancellablePromise = function cancellablePromise(p, doCancel) {
        p[CANCEL] = doCancel;
        return p;
      };

      _export('cancellablePromise', cancellablePromise);

      delayedResolve = function delayedResolve(ms) {
        return new _Promise(function (resolve) {
          return setTimeout(function () {
            return resolve(true);
          }, ms);
        });
      };

      _export('delayedResolve', delayedResolve);
    }
  };
});
$__System.register('252', [], function (_export) {
  // FIXME: Reference from serverSaga or, better, collated actions module.
  'use strict';

  var SERVER_SEND, selectors;
  return {
    setters: [],
    execute: function () {
      SERVER_SEND = '/server/SEND';

      // List of selected substate definitions that are checked upon an UPDATE_CLIENTS action
      // and converted into server actions if they have changed.
      selectors = [{ // rendererState state: 'run', 'pause', 'off'
        selector: function selector(state) {
          return state.rendererState.state;
        },
        memo: function memo(state) {
          return '' + state;
        },
        action: function action(state) {
          return {
            type: SERVER_SEND,
            addr: '/renderer/STATE',
            args: {
              state: state
            }
          };
        }
      }, { // photoState list: [ files that can be shown by the photo layer ]
        selector: function selector(state) {
          return state.photoState.list;
        },
        memo: function memo(state) {
          return '' + state;
        },
        action: function action(state) {
          return {
            type: SERVER_SEND,
            addr: '/photo/LIST',
            args: Array.isArray(state) ? state : [state]
          };
        }
      }];

      _export('default', selectors);
    }
  };
});
$__System.register('253', [], function (_export) {
  // Mapping of received websocket messages
  //   (with shape { addr: "", id: "", args: [] })
  // to Redux action with transformed payload.
  // Return a falsey value to inhibit dispatch.

  'use strict';

  var mungeArgs, dispatchHandler, wsHandlers;
  return {
    setters: [],
    execute: function () {
      mungeArgs = function mungeArgs(args) {
        return args.length === 1 ? args[0] : args;
      };

      dispatchHandler = function dispatchHandler(_ref) {
        var addr = _ref.addr;
        var id = _ref.id;
        var args = _ref.args;
        return { type: addr,
          id: id,
          payload: mungeArgs(args) };
      };

      // TODO: Coerce/validate args.
      wsHandlers = {
        '/renderer/STATE': dispatchHandler,
        '/renderer/FOREGROUND': dispatchHandler,
        '/renderer/BACKGROUND': dispatchHandler,
        '/renderer/INVERT': dispatchHandler,

        '/spurter/STATE': dispatchHandler,
        '/spurter/MERGE': dispatchHandler,
        '/spurter/MESSAGE': dispatchHandler,
        '/spurter/FONT_FAMILY': dispatchHandler,
        '/spurter/BOLD': dispatchHandler,
        '/spurter/ITALIC': dispatchHandler,
        '/spurter/HALIGN': dispatchHandler,
        '/spurter/VALIGN': dispatchHandler,
        '/spurter/ZOOM_SCALE': dispatchHandler,
        '/spurter/MARGIN_VH': dispatchHandler,
        '/spurter/LINE_SPACING': dispatchHandler,
        '/spurter/BACKGROUND_MODE': dispatchHandler,
        '/spurter/BACKGROUND_OFFSET_RATIO': dispatchHandler,

        '/photo/FILL': dispatchHandler,
        '/photo/FILE': dispatchHandler,
        '/photo/LIST': dispatchHandler,

        '/ext/ARENA': dispatchHandler
        // TODO: Update with full set of server exposed reducer actions.
      };

      _export('default', wsHandlers);
    }
  };
});
$__System.register('254', ['12', '33', '34', '56', '170', '183', '252', '253', '255', '2f', 'dc', 'cd', '2d', '2e'], function (_export) {
  var _extends, cancellablePromise, _Promise, _Object$keys, restifyPlugins, Watershed, selectors, wsHandlers, _getIterator, _regeneratorRuntime, restify, createHash, chalk, effects, isCancelError, marked0$0, util, call, cancel, fork, race, put, select, take, SERVER_STARTED, SERVER_STOPPED, CLIENT_CONNECTED, CLIENT_UPGRADED, SERVER_ERROR, START_SERVER, STOP_SERVER, SERVER_SEND, UPDATE_CLIENTS, conlog, connote, conwarn, conerr, toJS, dontLog, serveApi, serverSource, handlers, memos, createServer;

  function serveRequests(source) {
    var req, action;
    return _regeneratorRuntime.wrap(function serveRequests$(context$1$0) {
      while (1) switch (context$1$0.prev = context$1$0.next) {
        case 0:
          context$1$0.prev = 0;

          conlog('* serveRequests');

          context$1$0.next = 4;
          return call(source.nextRequest);

        case 4:
          req = context$1$0.sent;

        case 5:
          if (!req) {
            context$1$0.next = 20;
            break;
          }

          action = undefined;

          if (!req.addr || !(req.addr in dontLog)) {
            connote('**** request', util.inspect(req));
          }
          if (req.addr && req.addr in handlers) {
            action = handlers[req.addr](req);
            //        console.log('.... handled action:=', action);
          } else if (typeof req === 'string' && req in handlers) {
              action = handlers[req];
            } else {
              conerr('^^^^^ UNHANDLED SERVER REQUEST !!!!!\n');
            }

          if (!action) {
            context$1$0.next = 14;
            break;
          }

          context$1$0.next = 12;
          return put(action);

        case 12:
          context$1$0.next = 15;
          break;

        case 14:
          conwarn('^^^^ NO ACTION ^^^^\n');

        case 15:
          context$1$0.next = 17;
          return call(source.nextRequest);

        case 17:
          req = context$1$0.sent;
          context$1$0.next = 5;
          break;

        case 20:
          context$1$0.next = 25;
          break;

        case 22:
          context$1$0.prev = 22;
          context$1$0.t0 = context$1$0['catch'](0);

          if (!isCancelError(context$1$0.t0)) {
            console.error('* serveRequests error', context$1$0.t0);
          }

        case 25:
        case 'end':
          return context$1$0.stop();
      }
    }, marked0$0[0], this, [[0, 22]]);
  }

  function sendMessage(server, msg) {
    var addr, id, args, wsc, packet, ids, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, i, client;

    return _regeneratorRuntime.wrap(function sendMessage$(context$1$0) {
      while (1) switch (context$1$0.prev = context$1$0.next) {
        case 0:
          addr = msg.addr;
          id = msg.id;
          args = msg.args;

          if (!id) {
            context$1$0.next = 8;
            break;
          }

          wsc = id in server._wsc && server._wsc[id];

          if (wsc) {
            packet = JSON.stringify({ addr: addr, args: args });

            wsc.send(packet);
            if (!(addr in dontLog)) {
              console.log('--->', packet);
            }
          } else {
            conerr('!!!! SERVER_SEND request on DEAD CHANNEL', id, server._wsc);
          }
          context$1$0.next = 30;
          break;

        case 8:
          if (!server._wsc) {
            context$1$0.next = 30;
            break;
          }

          packet = JSON.stringify({ addr: addr, args: args });
          ids = _Object$keys(server._wsc);
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$1$0.prev = 14;

          for (_iterator = _getIterator(ids); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            i = _step.value;
            client = server._wsc[i];

            if (client) {
              conlog('[-=>', packet, i);
              client.send(packet);
            }
          }
          context$1$0.next = 22;
          break;

        case 18:
          context$1$0.prev = 18;
          context$1$0.t0 = context$1$0['catch'](14);
          _didIteratorError = true;
          _iteratorError = context$1$0.t0;

        case 22:
          context$1$0.prev = 22;
          context$1$0.prev = 23;

          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }

        case 25:
          context$1$0.prev = 25;

          if (!_didIteratorError) {
            context$1$0.next = 28;
            break;
          }

          throw _iteratorError;

        case 28:
          return context$1$0.finish(25);

        case 29:
          return context$1$0.finish(22);

        case 30:
        case 'end':
          return context$1$0.stop();
      }
    }, marked0$0[1], this, [[14, 18, 22, 30], [23,, 25, 29]]);
  }

  function updateSelector(_ref2, i) {
    var selector = _ref2.selector;
    var memo = _ref2.memo;
    var action = _ref2.action;
    var state, lastMemo, newMemo, act;
    return _regeneratorRuntime.wrap(function updateSelector$(context$1$0) {
      while (1) switch (context$1$0.prev = context$1$0.next) {
        case 0:
          context$1$0.next = 2;
          return select(selector);

        case 2:
          state = context$1$0.sent;
          lastMemo = memos[i];
          newMemo = memo && memo(state);

          if (!(lastMemo !== newMemo)) {
            context$1$0.next = 11;
            break;
          }

          act = action(state);

          if (!act) {
            context$1$0.next = 10;
            break;
          }

          context$1$0.next = 10;
          return put(act);

        case 10:
          memos[i] = newMemo;

        case 11:
        case 'end':
          return context$1$0.stop();
      }
    }, marked0$0[2], this);
  }

  function sendMessages(server) {
    var send, msg, i;
    return _regeneratorRuntime.wrap(function sendMessages$(context$1$0) {
      while (1) switch (context$1$0.prev = context$1$0.next) {
        case 0:
          context$1$0.prev = 0;
          context$1$0.next = 3;
          return take(SERVER_STARTED);

        case 3:
          send = true;

        case 4:
          if (!send) {
            context$1$0.next = 26;
            break;
          }

          context$1$0.next = 7;
          return race({
            send: take(SERVER_SEND),
            update: take(UPDATE_CLIENTS),
            upgraded: take(CLIENT_UPGRADED)
          });

        case 7:
          msg = context$1$0.sent;

          if (!msg.send) {
            context$1$0.next = 13;
            break;
          }

          context$1$0.next = 11;
          return fork(sendMessage, server, msg.send);

        case 11:
          context$1$0.next = 24;
          break;

        case 13:
          if (!msg.update) {
            context$1$0.next = 23;
            break;
          }

          i = 0;

        case 15:
          if (!(i < selectors.length)) {
            context$1$0.next = 21;
            break;
          }

          context$1$0.next = 18;
          return fork(updateSelector, selectors[i], i);

        case 18:
          ++i;
          context$1$0.next = 15;
          break;

        case 21:
          context$1$0.next = 24;
          break;

        case 23:
          if (msg.upgraded) {
            // Clear out all memos so all clients get updates.
            conwarn('- UPGRADED - MEMO CLEAR -');
            memos = [];
          } else {
            conerr(' how we got here?!!! ', msg);
          }

        case 24:
          context$1$0.next = 4;
          break;

        case 26:
          context$1$0.next = 31;
          break;

        case 28:
          context$1$0.prev = 28;
          context$1$0.t0 = context$1$0['catch'](0);

          if (!isCancelError(context$1$0.t0)) {
            conerr('*sendMessages error', context$1$0.t0);
          }

        case 31:
        case 'end':
          return context$1$0.stop();
      }
    }, marked0$0[3], this, [[0, 28]]);
  }

  function serverSaga() {
    var config,
        server,
        source,
        awaitStart,
        active,
        requestsTask,
        hostname,
        port,
        sendTask,
        winner,
        args$1$0 = arguments;
    return _regeneratorRuntime.wrap(function serverSaga$(context$1$0) {
      while (1) switch (context$1$0.prev = context$1$0.next) {
        case 0:
          config = args$1$0[1];
          context$1$0.next = 3;
          return take('/plask/INIT');

        case 3:
          conlog('* serverSaga/INIT');

          server = createServer(config);
          source = serverSource(server);
          awaitStart = false;
          active = true;

        case 8:
          if (!active) {
            context$1$0.next = 37;
            break;
          }

          if (!awaitStart) {
            context$1$0.next = 13;
            break;
          }

          context$1$0.next = 12;
          return take(START_SERVER);

        case 12:
          console.log(START_SERVER);

        case 13:
          context$1$0.next = 15;
          return fork(serveRequests, source);

        case 15:
          requestsTask = context$1$0.sent;

          // Start server listening.
          conlog('socket/opening...');
          hostname = config.hostname || '127.0.0.1';
          port = config.port || 9336;

          if (hostname === '127.0.0.1' || hostname === 'localhost') {
            conwarn('\n---- **** SERVER LISTENING on LOCALHOST ONLY **** [ ' + hostname + ':' + port + ' ] ----');
          } else if (hostname === '0.0.0.0') {
            conwarn('\n---- **** SERVER LISTENING on ALL INTERFACES **** [ *:' + port + ' ] ----');
          }
          server.listen(port, hostname, function () {
            return server.emit('opened');
          });

          // Fork server sending.
          context$1$0.next = 23;
          return fork(sendMessages, server);

        case 23:
          sendTask = context$1$0.sent;
          context$1$0.next = 26;
          return race({
            didStop: take(SERVER_STOPPED),
            erred: take(SERVER_ERROR),
            stop: take(STOP_SERVER),
            start: take(START_SERVER)
          });

        case 26:
          winner = context$1$0.sent;

          conlog('***** serveSaga race!', winner, requestsTask.isRunning(), sendTask.isRunning());

          // Cancel fetch & send tasks.
          conlog('cancelling server request handling');
          context$1$0.next = 31;
          return cancel(requestsTask);

        case 31:

          conlog('cancelling server sending');
          context$1$0.next = 34;
          return cancel(sendTask);

        case 34:

          // TODO: Dispatch socket status as per the race winner.

          // Stop server if didClose didn't win race.
          if (!winner.didStop) {
            server.close();
          }
          context$1$0.next = 8;
          break;

        case 37:
        case 'end':
          return context$1$0.stop();
      }
    }, marked0$0[4], this);
  }
  return {
    setters: [function (_) {
      _extends = _['default'];
    }, function (_7) {
      cancellablePromise = _7.cancellablePromise;
    }, function (_2) {
      _Promise = _2['default'];
    }, function (_3) {
      _Object$keys = _3['default'];
    }, function (_5) {
      restifyPlugins = _5['default'];
    }, function (_6) {
      Watershed = _6.Watershed;
    }, function (_8) {
      selectors = _8['default'];
    }, function (_9) {
      wsHandlers = _9['default'];
    }, function (_4) {
      _getIterator = _4['default'];
    }, function (_f) {
      _regeneratorRuntime = _f['default'];
    }, function (_dc) {
      restify = _dc['default'];
    }, function (_cd) {
      createHash = _cd.createHash;
    }, function (_d) {
      chalk = _d['default'];
    }, function (_e) {
      effects = _e.effects;
      isCancelError = _e.isCancelError;
    }],
    execute: function () {
      /* eslint-disable no-console */
      /* eslint no-param-reassign: [2, {"props": false }] */
      /* eslint no-underscore-dangle: [2, { "allow": ['_wsc', '_remote'] }] */

      // Server notifications.
      'use strict';

      marked0$0 = [serveRequests, sendMessage, updateSelector, sendMessages, serverSaga].map(_regeneratorRuntime.mark);
      util = require('util');
      call = effects.call;
      cancel = effects.cancel;
      fork = effects.fork;
      race = effects.race;
      put = effects.put;
      select = effects.select;
      take = effects.take;
      SERVER_STARTED = '/server/STARTED';
      SERVER_STOPPED = '/server/STOPPED';
      CLIENT_CONNECTED = '/client/CONNECTED';
      CLIENT_UPGRADED = '/client/UPGRADED';
      SERVER_ERROR = '/server/ERROR';

      // Server manipulation requests.
      START_SERVER = '/server/START';
      STOP_SERVER = '/server/STOP';
      SERVER_SEND = '/server/SEND';
      UPDATE_CLIENTS = '/server/UPDATE_CLIENTS';

      conlog = function conlog() {
        var _chalk$green;

        return console.log((_chalk$green = chalk.green).bold.apply(_chalk$green, arguments));
      };

      connote = function connote() {
        var _chalk$magenta;

        return console.log((_chalk$magenta = chalk.magenta).bold.apply(_chalk$magenta, arguments));
      };

      conwarn = function conwarn() {
        var _chalk$bgYellow;

        return console.warn((_chalk$bgYellow = chalk.bgYellow).black.apply(_chalk$bgYellow, arguments));
      };

      conerr = function conerr() {
        var _chalk$bgRed$bold;

        return console.error((_chalk$bgRed$bold = chalk.bgRed.bold).white.apply(_chalk$bgRed$bold, arguments));
      };

      toJS = function toJS(obj) {
        return JSON.stringify(obj);
      };

      dontLog = {
        '/renderer/STATE': true,
        '/ping': true,
        '/pong': true
      };

      serveApi = function serveApi(req, res) {
        console.log(chalk.bgGreen.white.bold('\n' + req.serverName + '$ ' + req.method + ' ' + req.url + '\n    ' + req.headers.host + ' ' + req.headers['user-agent'] + ' ' + req.headers.accept + '\n    ' + toJS(req.params) + '\n'));
        res.send({ ok: 'OK', request: req.url });
      };

      serverSource = function serverSource(server) {
        var shed = new Watershed();
        var messageQueue = [];
        var resolveQueue = [];
        var resolve = function resolve(msg) {
          if (resolveQueue.length) {
            var nextResolve = resolveQueue.shift();
            nextResolve(msg);
          } else {
            messageQueue.push(msg);
          }
        };
        server._wsc = {};
        server.on('opened', function () {
          conwarn('server/opened');
          resolve('opened');
        });
        server.on('connect', function (request /* , socket, head */) {
          conwarn('server/connect', request);
          resolve('connect');
        });
        server.on('upgrade', function (request, socket, head) {
          console.log(chalk.bgYellow.white.bold('**** socket:upgrade', request.headers.origin, request.headers['sec-websocket-key']));
          var wsc = undefined;
          var id = undefined;
          try {
            wsc = shed.accept(request, socket, head);
            var hash = createHash('sha256');
            hash.update('' + request.headers.origin);
            hash.update('' + request.headers['sec-websocket-key']);
            hash.update('' + wsc._remote);
            var rand = Math.random() * 0xffffffff | 0;
            hash.update('' + rand);
            id = hash.digest('hex');
          } catch (ex) {
            conerr('**** socket:error', ex);
            socket.end();
            return resolve(ex);
          }
          wsc.on('text', function (text) {
            var action = 'badmsg: ' + text;
            try {
              action = JSON.parse(text);
              if (!(action.addr in dontLog)) {
                conlog('>>>> socket:text', text, util.inspect(action));
              }
            } catch (ex) {
              conerr('>>>> ---- >>>> socket:text', text);
              conerr(text, ex);
            }
            resolve(action);
          });
          wsc.on('end', function (code, reason) {
            conlog('---- socket:end [code, reason, remote]', code, reason, wsc._remote);
            server._wsc[id] = null;
          });
          if (id) {
            wsc.send(JSON.stringify({ addr: '*HIHO*', id: id }));
            server._wsc[id] = wsc;
            conwarn('++ HIHO:', id, wsc._remote);
          }
          return resolve('upgraded');
        });
        server.on('clientError', function (ex, socket) {
          conerr('**** clientError', ex, socket);
          resolve('clienterror');
        });
        server.on('close', function () {
          conerr('---- server/closed');
          resolve('closed');
        });

        server.get(/^\/api(\/.+)/, function (request, response, next) {
          serveApi(request, response);
          resolve('api');
          return next(false);
        });

        return {
          nextRequest: function nextRequest() {
            return messageQueue.length ? cancellablePromise(_Promise.resolve(messageQueue.shift())) : cancellablePromise(new _Promise(function (resolver) {
              return resolveQueue.push(resolver);
            }));
          }
        };
      };

      handlers = _extends({}, wsHandlers, {
        // ---- internal notifications ----
        '/ping': function ping(_ref) {
          var args = _ref.args;
          var id = _ref.id;
          return { type: SERVER_SEND, addr: '/pong', args: args, id: id };
        }, // ping => pong
        opened: { type: SERVER_STARTED },
        closed: { type: SERVER_STOPPED },
        connected: { type: CLIENT_CONNECTED },
        upgraded: { type: CLIENT_UPGRADED },
        clienterror: null
      });
      memos = [];

      createServer = function createServer(config) {
        conlog('* createServer\n', util.inspect(config), '\n');
        var server = restify.createServer(config);

        server.pre(restify.CORS()); // eslint-disable-line new-cap
        server.pre(restifyPlugins.pre.sanitizePath());
        server.pre(restifyPlugins.pre.userAgentConnection());

        server.use(restifyPlugins.fullResponse());
        server.use(restifyPlugins.queryParser());
        if (config.gzip) {
          server.use(restifyPlugins.gzipResponse());
        }

        var statics = config.statics;
        _Object$keys(statics).forEach(function (key) {
          var cfg = statics[key];
          conlog('** static:', key, '\n', util.inspect(cfg), '\n');
          var handler = restifyPlugins.serveStatic(cfg.config);
          server.get(cfg.path, handler);
        });

        return server;
      };

      _export('default', serverSaga);
    }
  };
});

//        console.log('>>>>', action);
// Send message to specific recipient.

// Broadcast message to all clients.
//    console.log(' :: --==>', server._wsc);

//  console.log('up', state, lastMemo, newMemo);

//    console.log('\n~~~ selector update ~~~\n', state, act);

// Update clients with pieces of state as required.

// Server always tries to start up.
// Await user-initiated start server request.

// Fork server request handling.

// Race: didStop, stop, error, start.
$__System.register('256', ['32', '254', '2c'], function (_export) {
  'use strict';

  var oscSaga, serverSaga, extSaga;
  return {
    setters: [function (_) {
      oscSaga = _['default'];
    }, function (_2) {
      serverSaga = _2['default'];
    }, function (_c) {
      extSaga = _c['default'];
    }],
    execute: function () {
      _export('extSaga', extSaga);

      _export('oscSaga', oscSaga);

      _export('serverSaga', serverSaga);
    }
  };
});
$__System.registerDynamic("230", ["45"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('45');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("231", ["257", "44"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = $__require('257'),
      ITERATOR = $__require('44')('iterator'),
      ArrayProto = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("232", ["258"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('258'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("241", ["44"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ITERATOR = $__require('44')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("259", ["22f", "3e", "54", "230", "231", "232", "233", "241"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('22f'),
      $export = $__require('3e'),
      toObject = $__require('54'),
      call = $__require('230'),
      isArrayIter = $__require('231'),
      toLength = $__require('232'),
      getIterFn = $__require('233');
  $export($export.S + $export.F * !$__require('241')(function(iter) {
    Array.from(iter);
  }), 'Array', {from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          $$ = arguments,
          $$len = $$.length,
          mapfn = $$len > 1 ? $$[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping)
        mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("25a", ["243", "259", "4a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('243');
  $__require('259');
  module.exports = $__require('4a').Array.from;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2b", ["25a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('25a'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("25b", ["2b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Array$from = $__require('2b')["default"];
  exports["default"] = function(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++)
        arr2[i] = arr[i];
      return arr2;
    } else {
      return _Array$from(arr);
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.register('25c', ['12', '25d', '25b', '2d'], function (_export) {
  var _extends, _slicedToArray, _toConsumableArray, chalk, util, Plask, initMessage, subcanvasCache, getMakeSubcanvas, cullCache, canvases, lines, renderLines, lastMessage, lastFontFamily, lastBold, lastItalic, lastColour, emHeight, emWidth, checkRerender, drawMessage;

  return {
    setters: [function (_) {
      _extends = _['default'];
    }, function (_d) {
      _slicedToArray = _d['default'];
    }, function (_b) {
      _toConsumableArray = _b['default'];
    }, function (_d2) {
      chalk = _d2['default'];
    }],
    execute: function () {
      /* eslint-disable no-console */
      'use strict';

      util = require('util');
      Plask = require('plask');

      // ---- INIT ----

      initMessage = function initMessage(gl, canvas, paint /* , settings */) {
        paint.setFontFamily('Rockwell', 0);
        paint.setTextSize(320);
        paint.setFakeBoldText(true);
        paint.setAntiAlias(true);
        paint.setSubpixelText(true);
        paint.setLCDRenderText(true);
        paint.setAutohinted(true);
      };

      // ---- SUBCANVAS CACHE ----
      subcanvasCache = [];

      getMakeSubcanvas = function getMakeSubcanvas(reqw, reqh, frame, line) {
        //  console.log(`   searching subcanvasCache: ${subcanvasCache.length}`);
        var index = subcanvasCache.findIndex(function (canvas) {
          return reqw <= canvas.w && reqh <= canvas.h;
        });

        var canvas = undefined;
        if (index === -1) {
          // Make and return new subcanvas.
          // Round up dimensions to a power of two or similar nonsense.
          var upw = (1 + Math.floor(reqw / 128)) * 128;
          var uph = (1 + Math.floor(reqh / 128)) * 128;
          canvas = {
            w: upw,
            h: uph,
            reqw: reqw,
            reqh: reqh,
            frame: frame,
            line: line,
            canvas: Plask.SkCanvas.create(upw, uph)
          };
          console.log('NEW CANVAS: ' + reqw + ' x ' + reqh + ' => ' + upw + ' x ' + uph);
        } else {
          // Use this subcanvas, remove it from cache.
          var sub = subcanvasCache[index];
          canvas = _extends({}, sub, {
            reqw: reqw,
            reqh: reqh,
            frame: frame,
            line: line
          });
          console.log('OLD CANVAS ' + index + ': ' + reqw + ' x ' + reqh + ' => ' + canvas.w + ' x ' + canvas.h);
          subcanvasCache.splice(index, 1);
          /*
             subcanvasCache = [
             ...subcanvasCache.slice(0, index),
             ...subcanvasCache.slice(index + 1)
             ];
           */
        }
        //  console.log(`      now subcanvasCache: ${subcanvasCache.length}`);
        return canvas;
      };

      cullCache = function cullCache(frame) {
        var subLifetime = 10 * 60; // Ten seconds at 60 FPS.
        var preSize = subcanvasCache.length;
        subcanvasCache = subcanvasCache.filter(function (sub) {
          return frame - sub.frame < subLifetime;
        });
        var postSize = subcanvasCache.length;

        if (postSize !== preSize) {
          var culled = preSize - postSize;
          console.log('  ', chalk.magenta(culled + ' canvases culled'));
        }
      };

      // ---- RENDERING ----
      canvases = [];
      lines = undefined;

      renderLines = function renderLines(paint, frame) {
        // Reset overall bounds.
        canvases = [];

        // For each line of text:
        for (var i = 0; i < lines.length; ++i) {
          var line = lines[i];

          // Measure bounds.
          var bounds = paint.measureTextBounds(line);
          var x0 = bounds[0];
          var y0 = bounds[1];
          var x1 = bounds[2];
          var y1 = bounds[3];
          var w = x1 - x0;
          var h = y1 - y0;

          // Make subcanvas of appropriate size.
          var subcanvas = getMakeSubcanvas(w, h, frame, line);
          var canvas = subcanvas.canvas;

          // Clear subcanvas to transparent.
          canvas.clear(0, 0, 0, 0);

          // Render line of text into subcanvas.
          canvas.drawText(paint, line, -x0, -y0);

          canvases.push(subcanvas);
        }
      };

      lastMessage = undefined;
      lastFontFamily = undefined;
      lastBold = undefined;
      lastItalic = undefined;
      lastColour = undefined;
      emHeight = 10;
      emWidth = 10;

      checkRerender = function checkRerender(paint, message, fontFamily, bold, italic) {
        var render = false;

        if (fontFamily !== lastFontFamily || bold !== lastBold || italic !== lastItalic) {
          lastFontFamily = fontFamily;
          lastBold = bold;
          lastItalic = italic;
          render = true;

          var fontFlag = (bold ? 1 : 0) + (italic ? 2 : 0);
          paint.setFontFamily(fontFamily, fontFlag);

          var embounds = paint.measureTextBounds('m');
          emWidth = embounds[2] - embounds[0];
          emHeight = embounds[3] - embounds[1];

          console.log(chalk.bgBlue.white('= FONT ' + fontFamily + ' b:' + bold + ' i:' + italic + ', ' + ('emHeight:' + emHeight + ' emWidth: ' + emWidth)));
        }

        if (message !== lastMessage) {
          lastMessage = message;
          render = true;

          lines = message.split('\n');
          while (lines.length && lines[0] === '') {
            lines.shift();
          }
          while (lines.length && lines[lines.length - 1] === '') {
            lines.pop();
          }
          console.log(chalk.bgRed.white(util.inspect(lines)));
        }

        return render;
      };

      // ---- DRAW ---

      drawMessage = function drawMessage(gl, canvas, paint, state) {
        var rendererState = state.rendererState;
        var spurterState = state.spurterState;
        var width = rendererState.width;
        var height = rendererState.height;
        var frame = rendererState.frame;
        var foreground = rendererState.foreground;
        var background = rendererState.background;
        var invert = rendererState.invert;
        var message = spurterState.message;
        var fontFamily = spurterState.fontFamily;
        var bold = spurterState.bold;
        var italic = spurterState.italic;
        var zoomScale = spurterState.zoomScale;
        var marginVH = spurterState.marginVH;
        var lineSpacing = spurterState.lineSpacing;
        var halign = spurterState.halign;
        var valign = spurterState.valign;
        var backgroundMode = spurterState.backgroundMode;
        var backgroundOffsetRatio = spurterState.backgroundOffsetRatio;
        var debug = spurterState.debug;

        var rerender = checkRerender(paint, message, fontFamily, bold, italic);

        var fgColour = invert ? background : foreground;
        var bgColour = invert ? foreground : background;
        if (fgColour !== lastColour) {
          console.log(chalk.bgMagenta.white('---- NEW COLOUR: ' + fgColour + ' ----'));
          lastColour = fgColour;
          rerender = true;
        }

        var _fgColour = _slicedToArray(fgColour, 4);

        var fgR = _fgColour[0];
        var fgG = _fgColour[1];
        var fgB = _fgColour[2];
        var fgA = _fgColour[3];

        var _bgColour = _slicedToArray(bgColour, 4);

        var bgR = _bgColour[0];
        var bgG = _bgColour[1];
        var bgB = _bgColour[2];
        var bgA = _bgColour[3];

        if (rerender) {
          if ((frame & 0xff) === 0xff) {
            cullCache();
          }

          // Add existing canvases back into cache for reuse this frame.
          subcanvasCache = [].concat(_toConsumableArray(subcanvasCache), _toConsumableArray(canvases));
          canvases = [];

          console.log(chalk.bgRed.white('* RENDER *'));

          paint.setColor(fgR, fgG, fgB, fgA | 0);

          renderLines(paint, frame);
        }

        // Calculate overall bounding box of text in src canvas units.
        var dstMargin = marginVH * height;
        var srcLineSpacing = lineSpacing * emHeight;

        var srcW = canvases.reduce(function (prev, cvs) {
          return Math.max(prev, cvs.reqw);
        }, 0);
        var srcH = canvases.reduce(function (prev, cvs) {
          return prev + Math.max(cvs.reqh, emHeight) + srcLineSpacing;
        }, 0);

        // Calculate scaling to fit text within margins.
        var dstBoxW = width - dstMargin * 2;
        var dstBoxH = height - dstMargin * 2;
        var zoomW = dstBoxW / srcW;
        var zoomH = dstBoxH / srcH;
        var zoomA = Math.min(zoomW, zoomH) * (zoomScale / 100);

        var dstW = srcW * zoomA;
        var dstH = srcH * zoomA;
        var dstLineSpacing = srcLineSpacing * zoomA;

        if (rerender) {
          console.log('src bounds: ' + srcW + ' x ' + srcH);
          console.log('dst bounds: ' + dstW + ' x ' + dstH + ', (' + zoomW + ', ' + zoomH + '), margin: ' + dstMargin);
          console.log(zoomA === zoomW ? 'WIDTH CONSTRAINED' : 'HEIGHT CONSTRAINED');
        }

        canvas.resetMatrix();

        var hOffset = 0; // left
        if (halign === 1) {
          // centre
          hOffset = (dstBoxW - dstW) * 0.5;
        } else if (halign === 2) {
          // right
          hOffset = dstBoxW - dstW;
        }

        var vOffset = 0; // top
        if (valign === 1) {
          // middle
          vOffset = (dstBoxH - dstH) * 0.5;
        } else if (valign === 2) {
          // bottom
          vOffset = dstBoxH - dstH;
        }

        var dstx0 = dstMargin + hOffset;
        var dsty0 = dstMargin + vOffset;
        var dstx1 = dstx0 + dstW;
        var dsty1 = dsty0 + dstH;

        if (debug) {
          // Overall boundary outline.
          paint.setStroke();
          paint.setColor(255, 255, 255, 127);
          canvas.drawRect(paint, dstx0, dsty0, dstx1, dsty1);
        }

        var y0 = dsty0;
        var coords = canvases.reduce(function (prev, cvs, idx) {
          var reqw = cvs.reqw;
          var reqh = cvs.reqh;

          var w = reqw * zoomA;
          var h = reqh * zoomA;
          var lh = Math.max(h, emHeight * zoomA);
          var x0 = undefined;
          if (halign === 0) {
            // left
            x0 = dstx0;
          } else if (halign === 2) {
            // right
            x0 = dstx1 - w;
          } else {
            // centre
            x0 = dstx0 + dstW * 0.5 - w * 0.5;
          }
          y0 += dstLineSpacing * 0.5; // + (lh - h);
          var ords = {
            idx: idx,
            x0: x0,
            y0: y0,
            x1: x0 + w,
            y1: y0 + h
          };
          y0 += lh + dstLineSpacing * 0.5;
          return [].concat(_toConsumableArray(prev), [ords]);
        }, []);

        if (rerender) {
          console.log('~~ coords: ' + util.inspect(coords));
        }

        if (backgroundMode > 0) {
          (function () {
            // Tape background.
            var ofs = dstLineSpacing * backgroundOffsetRatio;
            paint.setFill();
            paint.setColor(bgR, bgG, bgB, bgA | 128);
            coords.forEach(function (coord) {
              canvas.drawRect(paint, coord.x0 - ofs, coord.y0 - ofs, coord.x1 + ofs, coord.y1 + ofs);
            });
          })();
        }

        if (debug) {
          // Outline each line of text.
          paint.setStroke();
          paint.setColor(255, 255, 255, 127);
          coords.forEach(function (coord) {
            canvas.drawRect(paint, coord.x0, coord.y0, coord.x1, coord.y1);
          });
        }

        paint.setFill();
        paint.setColor(255, 255, 255, 255);
        coords.forEach(function (coord, idx) {
          // Draw each line of text.
          var cvs = canvases[idx];
          canvas.drawCanvas(paint, cvs.canvas, coord.x0, coord.y0, coord.x1, coord.y1, 0, 0, cvs.reqw, cvs.reqh);
        });
      };

      _export('initMessage', initMessage);

      _export('drawMessage', drawMessage);
    }
  };
});
$__System.registerDynamic("234", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("45", ["234"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('234');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("233", ["240", "44", "257", "4a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('240'),
      ITERATOR = $__require('44')('iterator'),
      Iterators = $__require('257');
  module.exports = $__require('4a').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("25e", ["45", "233", "4a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('45'),
      get = $__require('233');
  module.exports = $__require('4a').getIterator = function(it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function')
      throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("25f", ["244", "243", "25e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('244');
  $__require('243');
  module.exports = $__require('25e');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("255", ["25f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('25f'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("260", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("261", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("20", ["262", "263"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = $__require('262'),
      defined = $__require('263');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("264", ["260", "261", "257", "20", "265"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var addToUnscopables = $__require('260'),
      step = $__require('261'),
      Iterators = $__require('257'),
      toIObject = $__require('20');
  module.exports = $__require('265')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("244", ["264", "257"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('264');
  var Iterators = $__require('257');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("258", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("266", ["258", "263"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('258'),
      defined = $__require('263');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("47", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3f", ["267"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('267');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("46", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3d", ["40"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !$__require('40')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("267", ["23", "46", "3d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('23'),
      createDesc = $__require('46');
  module.exports = $__require('3d') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("268", ["23", "46", "42", "267", "44"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('23'),
      descriptor = $__require('46'),
      setToStringTag = $__require('42'),
      IteratorPrototype = {};
  $__require('267')(IteratorPrototype, $__require('44')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3c", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("42", ["23", "3c", "44"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var def = $__require('23').setDesc,
      has = $__require('3c'),
      TAG = $__require('44')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("265", ["47", "3e", "3f", "267", "3c", "257", "268", "42", "23", "44"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LIBRARY = $__require('47'),
      $export = $__require('3e'),
      redefine = $__require('3f'),
      hide = $__require('267'),
      has = $__require('3c'),
      Iterators = $__require('257'),
      $iterCreate = $__require('268'),
      setToStringTag = $__require('42'),
      getProto = $__require('23').getProto,
      ITERATOR = $__require('44')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("243", ["266", "265"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $at = $__require('266')(true);
  $__require('265')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("240", ["39", "44"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('39'),
      TAG = $__require('44')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("41", ["3b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('3b'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("43", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("44", ["41", "43", "3b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = $__require('41')('wks'),
      uid = $__require('43'),
      Symbol = $__require('3b').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("257", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("269", ["240", "44", "257", "4a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('240'),
      ITERATOR = $__require('44')('iterator'),
      Iterators = $__require('257');
  module.exports = $__require('4a').isIterable = function(it) {
    var O = Object(it);
    return O[ITERATOR] !== undefined || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("26a", ["244", "243", "269"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('244');
  $__require('243');
  module.exports = $__require('269');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("26b", ["26a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('26a'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("25d", ["255", "26b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _getIterator = $__require('255')["default"];
  var _isIterable = $__require('26b')["default"];
  exports["default"] = (function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = _getIterator(arr),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (_isIterable(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.register('14', ['25d', '2d'], function (_export) {
  var _slicedToArray, chalk, Plask, fs, path, process, util, photoDir, photoFullname, photoFillmode, photoCanvas, drawCoords, listPhotos, initPhoto, calcPos, lastErrorFilename, drawPhoto;

  return {
    setters: [function (_d) {
      _slicedToArray = _d['default'];
    }, function (_d2) {
      chalk = _d2['default'];
    }],
    execute: function () {
      /* eslint-disable no-console */
      'use strict';

      Plask = require('plask');
      fs = require('fs');
      path = require('path');
      process = require('process');
      util = require('util');
      photoDir = './photos';
      photoFullname = undefined;
      photoFillmode = undefined;
      photoCanvas = undefined;
      drawCoords = undefined;

      listPhotos = function listPhotos() {
        var dir = arguments.length <= 0 || arguments[0] === undefined ? photoDir : arguments[0];

        try {
          var files = fs.readdirSync(dir);
          console.log(chalk.green(':::: ' + dir + ' ::::\n' + util.inspect(files)));
          return files;
        } catch (e) {
          console.error(e);
          return [];
        }
      };

      // ---- initPhoto ----

      initPhoto = function initPhoto() /* gl, canvas, paint, settings */{
        var cwd = process.cwd();
        photoDir = path.join(cwd, '/photos');
        console.log(chalk.green(':::: photoDir: ' + photoDir + ' ::::'));

        listPhotos();
      };

      // ---- calcPos ----

      calcPos = function calcPos(dw, dh, sw, sh, fillmode) {
        var xscale = dw / sw;
        var yscale = dh / sh;

        var w = undefined;
        var h = undefined;
        var dxm = undefined;
        var dym = undefined;
        var sxm = undefined;
        var sym = undefined;

        // Retain aspect ratio according to a scaling mode.
        switch (fillmode) {
          case 'scale-down':
            console.error('photo: scale-down fill mode not implemented');
          // INTENTIONAL FALLTHROUGH!

          case 'contain':
            if (xscale > yscale) {
              // Source image will be height constrained.
              // Margin to be added on left/right.
              w = sw * yscale;
              dxm = (dw - w) / 2;
              drawCoords = [dxm, 0, dxm + w, dh, 0, 0, sw, sh];
            } else {
              // Source image will be width constrained.
              // Margin to be added on top/bottom.
              h = sh * xscale;
              dym = (dh - h) / 2;
              drawCoords = [0, dym, dw, dym + h, 0, 0, sw, sh];
            }
            break;

          case 'cover':
            if (yscale > xscale) {
              // Source height will scale to fill exactly device height.
              // Source image will be cropped left/right.
              w = dw / yscale;
              sxm = (sw * yscale - dw) / 2;
              drawCoords = [0, 0, dw, dh, sxm, 0, sxm + w, sh];
            } else {
              // Source width will scale to fill exactly device width.
              // Source image will be cropped top/bottom.
              h = dh / xscale;
              sym = (sh * xscale - dh) / 2;
              drawCoords = [0, 0, dw, dh, 0, sym, sw, sym + h];
            }
            break;

          case 'fill':
            drawCoords = [0, 0, dw, dh, 0, 0, sw, sh];
            break;

          default:
            // none
            w = Math.min(dw, sw);
            h = Math.min(dh, sh);
            dxm = (dw - w) / 2;
            dym = (dh - h) / 2;
            sxm = (sw - w) / 2;
            sym = (sh - h) / 2;
            drawCoords = [dxm, dym, dxm + w, dym + h, sxm, sym, sxm + w, sym + h];
            break;
        }
      };

      // ---- drawPhoto ----
      lastErrorFilename = undefined;

      drawPhoto = function drawPhoto(gl, canvas, paint, state) {
        var rendererState = state.rendererState;
        var photoState = state.photoState;
        var filename = photoState.filename;
        var fillmode = photoState.fillmode;
        var width = rendererState.width;
        var height = rendererState.height;

        var recalc = false;

        if (!filename || !filename.length) {
          // No photo to show: early out.
          return;
        }

        var fullname = path.join(photoDir, filename);
        if (!fs.existsSync(fullname)) {
          if (fullname !== lastErrorFilename) {
            console.log(chalk.white.bgRed('Missing photo: ' + fullname));
            lastErrorFilename = fullname;
          }
          return;
        }

        if (fullname !== photoFullname) {
          // Load photo into canvas.
          photoCanvas = Plask.SkCanvas.createFromImage(fullname);
          console.log(chalk.black.bgYellow('Photo loaded: ' + fullname));
          photoFullname = fullname;
          recalc = true;
        }

        if (fillmode !== photoFillmode) {
          recalc = true;
        }

        if (recalc) {
          calcPos(width, height, photoCanvas.width, photoCanvas.height, fillmode);
          photoFillmode = fillmode;
        }

        var _drawCoords = drawCoords;

        var _drawCoords2 = _slicedToArray(_drawCoords, 8);

        var dx = _drawCoords2[0];
        var dy = _drawCoords2[1];
        var dw = _drawCoords2[2];
        var dh = _drawCoords2[3];
        var sx = _drawCoords2[4];
        var sy = _drawCoords2[5];
        var sw = _drawCoords2[6];
        var sh = _drawCoords2[7];

        canvas.drawCanvas(paint, photoCanvas, dx, dy, dw, dh, sx, sy, sw, sh);
      };

      _export('initPhoto', initPhoto);

      _export('drawPhoto', drawPhoto);

      _export('listPhotos', listPhotos);
    }
  };
});
$__System.register('26c', ['14', '25c'], function (_export) {
  /* eslint-disable no-console */

  // import { initVideo, drawVideo } from './videoTest.js';

  // TODO: Multi-renderer support.
  /*
     init() {
       rendererList = renderers.map(r => r.init(gl, canvas, paint, settings));
     }
     draw() {
       rendererList.sort();
       rendererList.forEach(r => r.draw());
     }
  */

  // ---- INIT ----
  'use strict';

  var initPhoto, drawPhoto, initMessage, drawMessage, init, draw;
  return {
    setters: [function (_) {
      initPhoto = _.initPhoto;
      drawPhoto = _.drawPhoto;
    }, function (_c) {
      initMessage = _c.initMessage;
      drawMessage = _c.drawMessage;
    }],
    execute: function () {
      init = function init(gl, canvas, paint, settings) {
        initMessage(gl, canvas, paint, settings);
        initPhoto(gl, canvas, paint, settings);
        // initVideo(gl, canvas, paint, settings);
      };

      // ---- DRAW ----

      draw = function draw(gl, canvas, paint, state) {
        //  drawVideo(gl, canvas, paint, state);
        drawPhoto(gl, canvas, paint, state);
        drawMessage(gl, canvas, paint, state);
      };

      _export('default', {
        init: init,
        draw: draw
      });
    }
  };
});
$__System.registerDynamic("26d", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  module.exports = function(str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }
    return str.replace(matchOperatorsRe, '\\$&');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("26e", ["26d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('26d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("26f", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  function assembleStyles() {
    var styles = {
      modifiers: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      colors: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39]
      },
      bgColors: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49]
      }
    };
    styles.colors.grey = styles.colors.gray;
    Object.keys(styles).forEach(function(groupName) {
      var group = styles[groupName];
      Object.keys(group).forEach(function(styleName) {
        var style = group[styleName];
        styles[styleName] = group[styleName] = {
          open: '\u001b[' + style[0] + 'm',
          close: '\u001b[' + style[1] + 'm'
        };
      });
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    });
    return styles;
  }
  Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("270", ["26f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('26f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("271", ["272"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ansiRegex = $__require('272')();
  module.exports = function(str) {
    return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("273", ["271"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('271');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("274", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {
    return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("272", ["274"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('274');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("275", ["272"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ansiRegex = $__require('272');
  var re = new RegExp(ansiRegex().source);
  module.exports = re.test.bind(re);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("276", ["275"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('275');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("277", ["9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var argv = process.argv;
    var terminator = argv.indexOf('--');
    var hasFlag = function(flag) {
      flag = '--' + flag;
      var pos = argv.indexOf(flag);
      return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
    };
    module.exports = (function() {
      if ('FORCE_COLOR' in process.env) {
        return true;
      }
      if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
        return false;
      }
      if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
        return true;
      }
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
      if (process.platform === 'win32') {
        return true;
      }
      if ('COLORTERM' in process.env) {
        return true;
      }
      if (process.env.TERM === 'dumb') {
        return false;
      }
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
      return false;
    })();
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("278", ["277"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('277');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("279", ["26e", "270", "273", "276", "278", "9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var escapeStringRegexp = $__require('26e');
    var ansiStyles = $__require('270');
    var stripAnsi = $__require('273');
    var hasAnsi = $__require('276');
    var supportsColor = $__require('278');
    var defineProps = Object.defineProperties;
    var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);
    function Chalk(options) {
      this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = '\u001b[94m';
    }
    var styles = (function() {
      var ret = {};
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
        ret[key] = {get: function() {
            return build.call(this, this._styles.concat(key));
          }};
      });
      return ret;
    })();
    var proto = defineProps(function chalk() {}, styles);
    function build(_styles) {
      var builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder.enabled = this.enabled;
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = argsLen !== 0 && String(arguments[0]);
      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += ' ' + args[a];
        }
      }
      if (!this.enabled || !str) {
        return str;
      }
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      var originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
        ansiStyles.dim.open = '';
      }
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {get: function() {
            return build.call(this, [name]);
          }};
      });
      return ret;
    }
    defineProps(Chalk.prototype, init());
    module.exports = new Chalk();
    module.exports.styles = ansiStyles;
    module.exports.hasColor = hasAnsi;
    module.exports.stripColor = stripAnsi;
    module.exports.supportsColor = supportsColor;
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2d", ["279"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('279');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3b", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("237", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("22f", ["237"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = $__require('237');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3e", ["3b", "4a", "22f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('3b'),
      core = $__require('4a'),
      ctx = $__require('22f'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("23", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("263", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("54", ["263"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = $__require('263');
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("39", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("262", ["39"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('39');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("40", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("27a", ["23", "54", "262", "40"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('23'),
      toObject = $__require('54'),
      IObject = $__require('262');
  module.exports = $__require('40')(function() {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        if (isEnum.call(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : Object.assign;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("27b", ["3e", "27a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('3e');
  $export($export.S + $export.F, 'Object', {assign: $__require('27a')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4a", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("27c", ["27b", "4a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('27b');
  module.exports = $__require('4a').Object.assign;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("27d", ["27c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('27c'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12", ["27d"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$assign = $__require('27d')["default"];
  exports["default"] = _Object$assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.register('27e', ['12'], function (_export) {
  var _extends, name, port, hostname, version, appServer, settings, appSettings;

  return {
    setters: [function (_) {
      _extends = _['default'];
    }],
    execute: function () {
      'use strict';

      name = '[beep]spurt';
      port = 9336;
      hostname = '0.0.0.0';
      version = '1.0.2';

      appServer = function appServer(onDevelopment) {
        return {
          name: name,
          port: port,
          hostname: hostname,
          version: version,
          autoStart: true,
          gzip: true,

          statics: {
            index: {
              path: /^\/[^\/]*$/,
              config: {
                'default': onDevelopment ? 'index.html' : 'index.min.html',
                directory: './dist',
                maxAge: onDevelopment ? 0 : 60 * 60
              }
            },
            fonts: {
              path: /^\/fonts\/.*$/,
              config: {
                directory: './dist',
                maxAge: onDevelopment ? 15 * 60 : 24 * 60 * 60 // 15 minutes : 24 hours.
              }
            }
          }
        };
      };

      settings = {
        width: 800,
        height: 600,
        position: { x: 400, y: 1200 },
        //  center: true,
        framerate: 30,
        title: name,

        osc: {
          port: 6339
        },

        type: '3d2d',
        syphon_server: name
      };

      appSettings = function appSettings(onDevelopment) {
        return _extends({}, settings, {
          server: _extends({}, appServer(onDevelopment))
        });
      };

      _export('default', appSettings);
    }
  };
});
$__System.registerDynamic("27f", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
  }
  (function() {
    try {
      if (typeof setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e) {
      cachedClearTimeout = defaultClearTimeout;
    }
  }());
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("280", ["27f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('27f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("281", ["280"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? process : $__require('280');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9", ["281"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('281');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("282", ["9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    (function() {
      var getNanoSeconds,
          hrtime,
          loadTime;
      if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
        module.exports = function() {
          return performance.now();
        };
      } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
        module.exports = function() {
          return (getNanoSeconds() - loadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        loadTime = getNanoSeconds();
      } else if (Date.now) {
        module.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }
    }).call(this);
  })($__require('9'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("283", ["282"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('282');
  global.define = __define;
  return module.exports;
});

$__System.register('1', ['17', '18', '29', '256', '283', '25d', '2e', '26c', '2d', '27e'], function (_export) {
  var createStore, Socket, OscSender, extSaga, oscSaga, serverSaga, perfnow, _slicedToArray, createSagaMiddleware, renderer, chalk, appSettings, Plask, util, ON_DEV, NO_RENDER, log, bootMsg, settings, sagaMiddleware, _createStore, store, dispatch, fps, reportInterval, reportFrames, realFrame, maxFrameTime, lastState, lastFrame, lastClock;

  return {
    setters: [function (_) {
      createStore = _['default'];
    }, function (_2) {
      Socket = _2['default'];
    }, function (_3) {
      OscSender = _3['default'];
    }, function (_4) {
      extSaga = _4.extSaga;
      oscSaga = _4.oscSaga;
      serverSaga = _4.serverSaga;
    }, function (_5) {
      perfnow = _5['default'];
    }, function (_d) {
      _slicedToArray = _d['default'];
    }, function (_e) {
      createSagaMiddleware = _e['default'];
    }, function (_c) {
      renderer = _c['default'];
    }, function (_d2) {
      chalk = _d2['default'];
    }, function (_e2) {
      appSettings = _e2['default'];
    }],
    execute: function () {
      'use strict';

      Plask = require('plask');
      util = require('util');
      ON_DEV = process.env.NODE_ENV && process.env.NODE_ENV.startsWith('dev');
      NO_RENDER = process.env.NO_RENDER !== undefined;
      log = ON_DEV ? function () {
        return console.log.apply(console, arguments);
      } // eslint-disable-line no-console
      : function noop() {};
      bootMsg = '\n\n      --=-=-=-==-=-=-=--\n    ---=  PRODUCTION  =---\n      --=-=-=-==-=-=-=--\n';

      if (ON_DEV) {
        bootMsg = '\n\n    <<<<---->>>> DEVELOPMENT <<<<---->>>>\n';
      }
      log(chalk.bgMagenta.white.bold(bootMsg));
      if (NO_RENDER) {
        log(chalk.bgRed.white.bold('\n\n    [[ XX ]] RENDERING DISABLED [[ XX ]]\n'));
      }

      settings = appSettings(ON_DEV);

      log(chalk.yellow.bold('Settings: ', util.inspect(settings, { depth: 5 }), '\n'));

      sagaMiddleware = createSagaMiddleware();
      _createStore = createStore(sagaMiddleware);
      store = _createStore.store;
      dispatch = _createStore.dispatch;

      log(chalk.cyan.bold('Initial state: ', util.inspect(store.getState()), '\n'));

      sagaMiddleware.run(oscSaga, new Socket(settings.osc));
      sagaMiddleware.run(serverSaga, settings.server);
      sagaMiddleware.run(extSaga(new OscSender({ port: 7000 }), '/ext/ARENA'));

      fps = settings.framerate || 30;
      reportInterval = 5;
      reportFrames = fps * reportInterval;
      realFrame = 0;
      maxFrameTime = 0;
      lastState = undefined;
      lastFrame = undefined;
      lastClock = undefined;

      log('---- ---- ' + perfnow() + ' ---- ----');

      Plask.simpleWindow({
        settings: settings,

        init: function init() {
          //    this.setTitle('-- test --');
          var gl = this.gl;
          var canvas = this.canvas;
          var paint = this.paint;

          renderer.init(gl, canvas, paint, settings);
          dispatch('/plask/INIT');
          dispatch('/renderer/FRAME_INIT', settings);
          dispatch('/photo/LIST');
        },

        draw: function draw() {
          var gl = this.gl;
          var canvas = this.canvas;
          var paint = this.paint;

          var storeState = store.getState();
          var rendererState = storeState.rendererState;
          var state = rendererState.state;
          var frame = rendererState.frame;
          var clearColour = rendererState.clearColour;

          if (state !== 'pause') {
            dispatch('/renderer/FRAME_ADVANCE');
          }
          dispatch('/server/UPDATE_CLIENTS');

          var now = perfnow();
          if (lastFrame) {
            var frameTime = now - lastFrame;
            if (frameTime > maxFrameTime) {
              maxFrameTime = frameTime;
            }
          }
          lastFrame = now;

          if (NO_RENDER) {
            return;
          }

          // Every expected second show amortised draw timing stats.
          if (realFrame % reportFrames === 0) {
            var mspf = lastClock ? (now - lastClock) / reportFrames : 0;
            log(chalk.cyan('#' + realFrame + '/' + frame + ': ' + state + ' : ' + now + ' : ' + mspf + ' : ' + maxFrameTime));
            lastClock = now;
            maxFrameTime = 0;
          }
          realFrame += 1;

          var _clearColour = _slicedToArray(clearColour, 4);

          var clrr = _clearColour[0];
          var clrg = _clearColour[1];
          var clrb = _clearColour[2];
          var clra = _clearColour[3];

          if (state === 'pause') {
            // No need to do any clearing or rendering.
          } else if (state === 'off') {
              if (lastState !== 'off') {
                // Only clear on first frame after being turned off.
                canvas.clear(clrr, clrg, clrb, clra);
              }
            } else {
              // Clear canvas, then render.
              canvas.clear(clrr, clrg, clrb, clra);
              renderer.draw(gl, canvas, paint, storeState);
            }

          lastState = state;
        }
      });
    }
  };
});
})
(function(factory) {
  factory();
});
//# sourceMappingURL=server.js.map